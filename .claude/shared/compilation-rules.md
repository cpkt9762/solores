# 🚫 编译错误修复逃避禁令（绝对禁止）

## 编译失败时测试禁令（绝对禁止）

### 🚨 禁止在编译失败时测试功能
- **FORBIDDEN**: 在`cargo check`失败时运行`cargo test`
- **FORBIDDEN**: 在存在编译错误时运行功能测试
- **FORBIDDEN**: "先测试基本功能，再修复编译错误"的逆序操作
- **MANDATORY**: 必须先达到零编译错误才能进行任何测试

### 强制工作流程
```
1. 代码修改/生成
2. MANDATORY: cargo check (必须通过)
3. ONLY IF 编译通过: cargo test
4. ONLY IF 测试通过: 质量验证
```

## 破坏性修复策略（严格禁止）

### 🚨 绝对禁止的"修复"方式
- **禁用功能模块**来"修复"编译错误
- **删除功能模块**来"解决"编译问题  
- **注释掉代码**来"暂时解决"编译错误
- **简化架构**来"回避"复杂编译问题
- **移除复杂机制**来"避免"编译错误

### 📊 数量借口检测（绝对禁止）
- "编译错误太多，先禁用部分模块"
- "81个编译错误，暂时注释掉复杂功能"
- "错误数量巨大，分步骤禁用模块处理"
- "工作量太大，先删除有问题的模块"
- "复杂功能编译困难，先移除复杂部分"

## ✅ 强制正确做法

### 1. 直接修复原则
- **MUST**: 直接修复每个编译错误，保持所有功能完整
- **MUST**: 通过添加缺失代码解决编译错误
- **MUST**: 通过修正语法错误解决编译问题
- **MUST**: 保持原有功能和架构完整性

### 2. 功能完整性强制原则
- 修复前功能数量 = 修复后功能数量 (无例外)
- 修复前架构复杂度 ≤ 修复后架构复杂度 (不允许简化)
- 修复前模块数量 = 修复后模块数量 (不允许删除)
- 修复前API接口 = 修复后API接口 (不允许移除)

### 3. 逐个修复策略
- 逐个分析每个编译错误
- 找到每个错误的根本原因
- 通过正确的代码修正解决
- 验证修复不影响其他功能

## ⚡ 编译错误强制触发器

| 🚨 编译问题信号 | ✅ 强制纠正动作 |
|------------|---------------|
| "在编译失败时运行测试" | 停止违规 - 先修复编译再测试 |
| "编译错误存在但要测试功能" | 停止违规 - 强制编译优先 |
| "先测试基本功能再修复编译" | 停止违规 - 强制编译优先 |
| "编译错误太多" | 停止借口 - 逐个修复所有错误 |
| "禁用模块解决编译错误" | 停止破坏 - 修复编译问题保持功能 |
| "删除模块避免编译错误" | 停止破坏 - 修复错误保持完整架构 |
| "注释掉错误代码" | 停止破坏 - 修正代码逻辑 |
| "暂时移除问题代码" | 停止破坏 - 直接修复代码问题 |
| "简化功能解决编译" | 停止破坏 - 修复复杂问题保持功能 |
| "先禁用错误模块" | 停止破坏 - 直接修复模块问题 |

## 📋 编译错误修复原则

### 强制要求
- 直接修复每个编译错误，保持所有功能完整
- 通过添加缺失代码解决编译错误
- 通过修正语法错误解决编译问题
- 保持原有功能和架构完整性

### 验证标准
- 修复前功能数量 = 修复后功能数量
- 修复前模块数量 = 修复后模块数量
- 修复前API接口 = 修复后API接口
- 最终必须达到零编译错误（允许无害警告）

## 🛡️ 强制执行机制

### 自动检查流程
1. **修复前**: 记录当前架构状态
2. **修复中**: 禁止删除/禁用功能
3. **修复后**: 验证架构完整性
4. **最终**: 确认零编译错误（允许无害警告）

### 编译警告分类处理
#### 允许的无害警告
- `unused_imports` - 代码生成器常见，可接受
- `dead_code` - 生成的结构体可能暂时未使用
- `non_snake_case` - IDL命名转换可能产生

#### 禁止的严重警告
- `unused_must_use` - 错误处理问题，必须修复
- `deprecated` - 使用过时API，必须更新
- `missing_docs` - 缺少文档（根据项目要求）

### 违规检测和阻止
- 实时监控修复过程
- 检测破坏性修复行为
- 自动阻止功能删除操作
- 强制保持架构完整性