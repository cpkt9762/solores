//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-16
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

//! Instructions parser for Anchor contracts with 8-byte discriminators
use crate::instructions::*;
#[allow(unused_imports)]
use solana_pubkey::Pubkey;
/// Program instruction types for Anchor contract
#[derive(Clone, Debug, PartialEq)]
pub enum LifinityInstruction {
    Swap(SwapKeys, SwapIxData),
    DepositAllTokenTypes(DepositAllTokenTypesKeys, DepositAllTokenTypesIxData),
    WithdrawAllTokenTypes(WithdrawAllTokenTypesKeys, WithdrawAllTokenTypesIxData),
}
impl LifinityInstruction {
    /// Manual JSON serialization
    #[cfg(feature = "serde")]
    pub fn to_json(&self) -> String {
        match self {
            Self::Swap(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "swap",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::DepositAllTokenTypes(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "depositAllTokenTypes",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::WithdrawAllTokenTypes(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "withdrawAllTokenTypes",
                    keys.to_json(),
                    data.to_json()
                )
            }
        }
    }
}
/// Helper function to check minimum accounts requirement
fn check_min_accounts_req(
    accounts: &[Pubkey],
    required_len: usize,
    instruction_name: &str,
) -> Result<(), std::io::Error> {
    if accounts.len() < required_len {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Insufficient accounts for instruction {}", instruction_name),
        ));
    }
    Ok(())
}
/// Parse instruction data based on 8-byte discriminator (Anchor contracts)
pub fn parse_instruction(
    data: &[u8],
    accounts: &[Pubkey],
) -> Result<LifinityInstruction, std::io::Error> {
    if data.len() < 8 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data too short for discriminator",
        ));
    }
    let discriminator: [u8; 8] = data[0..8].try_into().map_err(|_| {
        std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Failed to read discriminator",
        )
    })?;
    match discriminator {
        SWAP_IX_DISCM => {
            check_min_accounts_req(accounts, SWAP_IX_ACCOUNTS_LEN, "Swap")?;
            let ix_accounts = SwapKeys::from(&accounts[..SWAP_IX_ACCOUNTS_LEN]);
            let args = SwapIxData::from_bytes(&data[..])?;
            Ok(LifinityInstruction::Swap(ix_accounts, args))
        }
        DEPOSIT_ALL_TOKEN_TYPES_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                DEPOSIT_ALL_TOKEN_TYPES_IX_ACCOUNTS_LEN,
                "DepositAllTokenTypes",
            )?;
            let ix_accounts = DepositAllTokenTypesKeys::from(
                &accounts[..DEPOSIT_ALL_TOKEN_TYPES_IX_ACCOUNTS_LEN],
            );
            let args = DepositAllTokenTypesIxData::from_bytes(&data[..])?;
            Ok(LifinityInstruction::DepositAllTokenTypes(ix_accounts, args))
        }
        WITHDRAW_ALL_TOKEN_TYPES_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                WITHDRAW_ALL_TOKEN_TYPES_IX_ACCOUNTS_LEN,
                "WithdrawAllTokenTypes",
            )?;
            let ix_accounts = WithdrawAllTokenTypesKeys::from(
                &accounts[..WITHDRAW_ALL_TOKEN_TYPES_IX_ACCOUNTS_LEN],
            );
            let args = WithdrawAllTokenTypesIxData::from_bytes(&data[..])?;
            Ok(LifinityInstruction::WithdrawAllTokenTypes(
                ix_accounts,
                args,
            ))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {:?}", discriminator),
        )),
    }
}
