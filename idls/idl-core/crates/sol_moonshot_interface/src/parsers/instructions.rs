//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-16
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

//! Instructions parser for Anchor contracts with 8-byte discriminators
use crate::instructions::*;
#[allow(unused_imports)]
use solana_pubkey::Pubkey;
/// Program instruction types for Anchor contract
#[derive(Clone, Debug, PartialEq)]
pub enum MoonshotInstruction {
    TokenMint(TokenMintKeys, TokenMintIxData),
    Buy(BuyKeys, BuyIxData),
    Sell(SellKeys, SellIxData),
    MigrateFunds(MigrateFundsKeys, MigrateFundsIxData),
    ConfigInit(ConfigInitKeys, ConfigInitIxData),
    ConfigUpdate(ConfigUpdateKeys, ConfigUpdateIxData),
}
impl MoonshotInstruction {
    /// Manual JSON serialization
    #[cfg(feature = "serde")]
    pub fn to_json(&self) -> String {
        match self {
            Self::TokenMint(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "tokenMint",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Buy(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "buy",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Sell(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "sell",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MigrateFunds(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "migrateFunds",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ConfigInit(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "configInit",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ConfigUpdate(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "configUpdate",
                    keys.to_json(),
                    data.to_json()
                )
            }
        }
    }
}
/// Helper function to check minimum accounts requirement
fn check_min_accounts_req(
    accounts: &[Pubkey],
    required_len: usize,
    instruction_name: &str,
) -> Result<(), std::io::Error> {
    if accounts.len() < required_len {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Insufficient accounts for instruction {}", instruction_name),
        ));
    }
    Ok(())
}
/// Parse instruction data based on 8-byte discriminator (Anchor contracts)
pub fn parse_instruction(
    data: &[u8],
    accounts: &[Pubkey],
) -> Result<MoonshotInstruction, std::io::Error> {
    if data.len() < 8 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data too short for discriminator",
        ));
    }
    let discriminator: [u8; 8] = data[0..8].try_into().map_err(|_| {
        std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Failed to read discriminator",
        )
    })?;
    match discriminator {
        TOKEN_MINT_IX_DISCM => {
            check_min_accounts_req(accounts, TOKEN_MINT_IX_ACCOUNTS_LEN, "TokenMint")?;
            let ix_accounts = TokenMintKeys::from(&accounts[..TOKEN_MINT_IX_ACCOUNTS_LEN]);
            let args = TokenMintIxData::from_bytes(&data[..])?;
            Ok(MoonshotInstruction::TokenMint(ix_accounts, args))
        }
        BUY_IX_DISCM => {
            check_min_accounts_req(accounts, BUY_IX_ACCOUNTS_LEN, "Buy")?;
            let ix_accounts = BuyKeys::from(&accounts[..BUY_IX_ACCOUNTS_LEN]);
            let args = BuyIxData::from_bytes(&data[..])?;
            Ok(MoonshotInstruction::Buy(ix_accounts, args))
        }
        SELL_IX_DISCM => {
            check_min_accounts_req(accounts, SELL_IX_ACCOUNTS_LEN, "Sell")?;
            let ix_accounts = SellKeys::from(&accounts[..SELL_IX_ACCOUNTS_LEN]);
            let args = SellIxData::from_bytes(&data[..])?;
            Ok(MoonshotInstruction::Sell(ix_accounts, args))
        }
        MIGRATE_FUNDS_IX_DISCM => {
            check_min_accounts_req(accounts, MIGRATE_FUNDS_IX_ACCOUNTS_LEN, "MigrateFunds")?;
            let ix_accounts = MigrateFundsKeys::from(&accounts[..MIGRATE_FUNDS_IX_ACCOUNTS_LEN]);
            let args = MigrateFundsIxData::from_bytes(&data[..])?;
            Ok(MoonshotInstruction::MigrateFunds(ix_accounts, args))
        }
        CONFIG_INIT_IX_DISCM => {
            check_min_accounts_req(accounts, CONFIG_INIT_IX_ACCOUNTS_LEN, "ConfigInit")?;
            let ix_accounts = ConfigInitKeys::from(&accounts[..CONFIG_INIT_IX_ACCOUNTS_LEN]);
            let args = ConfigInitIxData::from_bytes(&data[..])?;
            Ok(MoonshotInstruction::ConfigInit(ix_accounts, args))
        }
        CONFIG_UPDATE_IX_DISCM => {
            check_min_accounts_req(accounts, CONFIG_UPDATE_IX_ACCOUNTS_LEN, "ConfigUpdate")?;
            let ix_accounts = ConfigUpdateKeys::from(&accounts[..CONFIG_UPDATE_IX_ACCOUNTS_LEN]);
            let args = ConfigUpdateIxData::from_bytes(&data[..])?;
            Ok(MoonshotInstruction::ConfigUpdate(ix_accounts, args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {:?}", discriminator),
        )),
    }
}
