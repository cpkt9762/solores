//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-16
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

//! Instructions parser for Anchor contracts with 8-byte discriminators
use crate::instructions::*;
#[allow(unused_imports)]
use solana_pubkey::Pubkey;
/// Program instruction types for Anchor contract
#[derive(Clone, Debug, PartialEq)]
pub enum StableSwapInstruction {
    AcceptOwner(AcceptOwnerKeys, AcceptOwnerIxData),
    ApproveStrategy(ApproveStrategyKeys, ApproveStrategyIxData),
    ChangeAmpFactor(ChangeAmpFactorKeys, ChangeAmpFactorIxData),
    ChangeMaxSupply(ChangeMaxSupplyKeys, ChangeMaxSupplyIxData),
    ChangeSwapFee(ChangeSwapFeeKeys, ChangeSwapFeeIxData),
    ChangeSwapFeePrivileged(ChangeSwapFeePrivilegedKeys, ChangeSwapFeePrivilegedIxData),
    CloseStrategy(CloseStrategyKeys, CloseStrategyIxData),
    CreateStrategy(CreateStrategyKeys, CreateStrategyIxData),
    ///add liquidity
    Deposit(DepositKeys, DepositIxData),
    ExecStrategy(ExecStrategyKeys, ExecStrategyIxData),
    ///initialize a pool
    Initialize(InitializeKeys, InitializeIxData),
    Pause(PauseKeys, PauseIxData),
    RejectOwner(RejectOwnerKeys, RejectOwnerIxData),
    ///shutdown the zero-liquidity pool
    Shutdown(ShutdownKeys, ShutdownIxData),
    ///swap
    Swap(SwapKeys, SwapIxData),
    SwapV2(SwapV2Keys, SwapV2IxData),
    TransferOwner(TransferOwnerKeys, TransferOwnerIxData),
    Unpause(UnpauseKeys, UnpauseIxData),
    ///remove liquidity
    Withdraw(WithdrawKeys, WithdrawIxData),
}
impl StableSwapInstruction {
    /// Manual JSON serialization
    #[cfg(feature = "serde")]
    pub fn to_json(&self) -> String {
        match self {
            Self::AcceptOwner(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "accept_owner",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ApproveStrategy(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "approve_strategy",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ChangeAmpFactor(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "change_amp_factor",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ChangeMaxSupply(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "change_max_supply",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ChangeSwapFee(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "change_swap_fee",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ChangeSwapFeePrivileged(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "change_swap_fee_privileged",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CloseStrategy(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "close_strategy",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CreateStrategy(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "create_strategy",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Deposit(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "deposit",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ExecStrategy(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "exec_strategy",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Initialize(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initialize",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Pause(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "pause",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::RejectOwner(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "reject_owner",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Shutdown(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "shutdown",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Swap(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "swap",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SwapV2(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "swap_v2",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::TransferOwner(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "transfer_owner",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Unpause(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "unpause",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Withdraw(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "withdraw",
                    keys.to_json(),
                    data.to_json()
                )
            }
        }
    }
}
/// Helper function to check minimum accounts requirement
fn check_min_accounts_req(
    accounts: &[Pubkey],
    required_len: usize,
    instruction_name: &str,
) -> Result<(), std::io::Error> {
    if accounts.len() < required_len {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Insufficient accounts for instruction {}", instruction_name),
        ));
    }
    Ok(())
}
/// Parse instruction data based on 8-byte discriminator (Anchor contracts)
pub fn parse_instruction(
    data: &[u8],
    accounts: &[Pubkey],
) -> Result<StableSwapInstruction, std::io::Error> {
    if data.len() < 8 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data too short for discriminator",
        ));
    }
    let discriminator: [u8; 8] = data[0..8].try_into().map_err(|_| {
        std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Failed to read discriminator",
        )
    })?;
    match discriminator {
        ACCEPT_OWNER_IX_DISCM => {
            check_min_accounts_req(accounts, ACCEPT_OWNER_IX_ACCOUNTS_LEN, "AcceptOwner")?;
            let ix_accounts = AcceptOwnerKeys::from(&accounts[..ACCEPT_OWNER_IX_ACCOUNTS_LEN]);
            let args = AcceptOwnerIxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::AcceptOwner(ix_accounts, args))
        }
        APPROVE_STRATEGY_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                APPROVE_STRATEGY_IX_ACCOUNTS_LEN,
                "ApproveStrategy",
            )?;
            let ix_accounts =
                ApproveStrategyKeys::from(&accounts[..APPROVE_STRATEGY_IX_ACCOUNTS_LEN]);
            let args = ApproveStrategyIxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::ApproveStrategy(ix_accounts, args))
        }
        CHANGE_AMP_FACTOR_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CHANGE_AMP_FACTOR_IX_ACCOUNTS_LEN,
                "ChangeAmpFactor",
            )?;
            let ix_accounts =
                ChangeAmpFactorKeys::from(&accounts[..CHANGE_AMP_FACTOR_IX_ACCOUNTS_LEN]);
            let args = ChangeAmpFactorIxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::ChangeAmpFactor(ix_accounts, args))
        }
        CHANGE_MAX_SUPPLY_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CHANGE_MAX_SUPPLY_IX_ACCOUNTS_LEN,
                "ChangeMaxSupply",
            )?;
            let ix_accounts =
                ChangeMaxSupplyKeys::from(&accounts[..CHANGE_MAX_SUPPLY_IX_ACCOUNTS_LEN]);
            let args = ChangeMaxSupplyIxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::ChangeMaxSupply(ix_accounts, args))
        }
        CHANGE_SWAP_FEE_IX_DISCM => {
            check_min_accounts_req(accounts, CHANGE_SWAP_FEE_IX_ACCOUNTS_LEN, "ChangeSwapFee")?;
            let ix_accounts = ChangeSwapFeeKeys::from(&accounts[..CHANGE_SWAP_FEE_IX_ACCOUNTS_LEN]);
            let args = ChangeSwapFeeIxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::ChangeSwapFee(ix_accounts, args))
        }
        CHANGE_SWAP_FEE_PRIVILEGED_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CHANGE_SWAP_FEE_PRIVILEGED_IX_ACCOUNTS_LEN,
                "ChangeSwapFeePrivileged",
            )?;
            let ix_accounts = ChangeSwapFeePrivilegedKeys::from(
                &accounts[..CHANGE_SWAP_FEE_PRIVILEGED_IX_ACCOUNTS_LEN],
            );
            let args = ChangeSwapFeePrivilegedIxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::ChangeSwapFeePrivileged(
                ix_accounts,
                args,
            ))
        }
        CLOSE_STRATEGY_IX_DISCM => {
            check_min_accounts_req(accounts, CLOSE_STRATEGY_IX_ACCOUNTS_LEN, "CloseStrategy")?;
            let ix_accounts = CloseStrategyKeys::from(&accounts[..CLOSE_STRATEGY_IX_ACCOUNTS_LEN]);
            let args = CloseStrategyIxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::CloseStrategy(ix_accounts, args))
        }
        CREATE_STRATEGY_IX_DISCM => {
            check_min_accounts_req(accounts, CREATE_STRATEGY_IX_ACCOUNTS_LEN, "CreateStrategy")?;
            let ix_accounts =
                CreateStrategyKeys::from(&accounts[..CREATE_STRATEGY_IX_ACCOUNTS_LEN]);
            let args = CreateStrategyIxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::CreateStrategy(ix_accounts, args))
        }
        DEPOSIT_IX_DISCM => {
            check_min_accounts_req(accounts, DEPOSIT_IX_ACCOUNTS_LEN, "Deposit")?;
            let ix_accounts = DepositKeys::from(&accounts[..DEPOSIT_IX_ACCOUNTS_LEN]);
            let args = DepositIxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::Deposit(ix_accounts, args))
        }
        EXEC_STRATEGY_IX_DISCM => {
            check_min_accounts_req(accounts, EXEC_STRATEGY_IX_ACCOUNTS_LEN, "ExecStrategy")?;
            let ix_accounts = ExecStrategyKeys::from(&accounts[..EXEC_STRATEGY_IX_ACCOUNTS_LEN]);
            let args = ExecStrategyIxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::ExecStrategy(ix_accounts, args))
        }
        INITIALIZE_IX_DISCM => {
            check_min_accounts_req(accounts, INITIALIZE_IX_ACCOUNTS_LEN, "Initialize")?;
            let ix_accounts = InitializeKeys::from(&accounts[..INITIALIZE_IX_ACCOUNTS_LEN]);
            let args = InitializeIxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::Initialize(ix_accounts, args))
        }
        PAUSE_IX_DISCM => {
            check_min_accounts_req(accounts, PAUSE_IX_ACCOUNTS_LEN, "Pause")?;
            let ix_accounts = PauseKeys::from(&accounts[..PAUSE_IX_ACCOUNTS_LEN]);
            let args = PauseIxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::Pause(ix_accounts, args))
        }
        REJECT_OWNER_IX_DISCM => {
            check_min_accounts_req(accounts, REJECT_OWNER_IX_ACCOUNTS_LEN, "RejectOwner")?;
            let ix_accounts = RejectOwnerKeys::from(&accounts[..REJECT_OWNER_IX_ACCOUNTS_LEN]);
            let args = RejectOwnerIxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::RejectOwner(ix_accounts, args))
        }
        SHUTDOWN_IX_DISCM => {
            check_min_accounts_req(accounts, SHUTDOWN_IX_ACCOUNTS_LEN, "Shutdown")?;
            let ix_accounts = ShutdownKeys::from(&accounts[..SHUTDOWN_IX_ACCOUNTS_LEN]);
            let args = ShutdownIxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::Shutdown(ix_accounts, args))
        }
        SWAP_IX_DISCM => {
            check_min_accounts_req(accounts, SWAP_IX_ACCOUNTS_LEN, "Swap")?;
            let ix_accounts = SwapKeys::from(&accounts[..SWAP_IX_ACCOUNTS_LEN]);
            let args = SwapIxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::Swap(ix_accounts, args))
        }
        SWAP_V_2_IX_DISCM => {
            check_min_accounts_req(accounts, SWAP_V_2_IX_ACCOUNTS_LEN, "SwapV2")?;
            let ix_accounts = SwapV2Keys::from(&accounts[..SWAP_V_2_IX_ACCOUNTS_LEN]);
            let args = SwapV2IxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::SwapV2(ix_accounts, args))
        }
        TRANSFER_OWNER_IX_DISCM => {
            check_min_accounts_req(accounts, TRANSFER_OWNER_IX_ACCOUNTS_LEN, "TransferOwner")?;
            let ix_accounts = TransferOwnerKeys::from(&accounts[..TRANSFER_OWNER_IX_ACCOUNTS_LEN]);
            let args = TransferOwnerIxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::TransferOwner(ix_accounts, args))
        }
        UNPAUSE_IX_DISCM => {
            check_min_accounts_req(accounts, UNPAUSE_IX_ACCOUNTS_LEN, "Unpause")?;
            let ix_accounts = UnpauseKeys::from(&accounts[..UNPAUSE_IX_ACCOUNTS_LEN]);
            let args = UnpauseIxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::Unpause(ix_accounts, args))
        }
        WITHDRAW_IX_DISCM => {
            check_min_accounts_req(accounts, WITHDRAW_IX_ACCOUNTS_LEN, "Withdraw")?;
            let ix_accounts = WithdrawKeys::from(&accounts[..WITHDRAW_IX_ACCOUNTS_LEN]);
            let args = WithdrawIxData::from_bytes(&data[..])?;
            Ok(StableSwapInstruction::Withdraw(ix_accounts, args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {:?}", discriminator),
        )),
    }
}
