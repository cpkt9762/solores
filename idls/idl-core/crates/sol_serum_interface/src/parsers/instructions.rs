//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-16
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

//! Instructions parser for non-Anchor contracts with 1-byte discriminators
use crate::instructions::*;
use solana_pubkey::Pubkey;
/// Program instruction types for non-Anchor contracts
#[derive(Clone, Debug, PartialEq)]
pub enum ProgramInstruction {
    InitializeMarket(InitializeMarketKeys, InitializeMarketIxData),
    NewOrder(NewOrderKeys, NewOrderIxData),
    MatchOrders(MatchOrdersKeys, MatchOrdersIxData),
    ConsumeEvents(ConsumeEventsKeys, ConsumeEventsIxData),
    CancelOrder(CancelOrderKeys, CancelOrderIxData),
    SettleFunds(SettleFundsKeys, SettleFundsIxData),
    CancelOrderByClientId(CancelOrderByClientIdKeys, CancelOrderByClientIdIxData),
    DisableMarket(DisableMarketKeys, DisableMarketIxData),
    SweepFees(SweepFeesKeys, SweepFeesIxData),
    NewOrderV2(NewOrderV2Keys, NewOrderV2IxData),
    NewOrderV3(NewOrderV3Keys, NewOrderV3IxData),
    CancelOrderV2(CancelOrderV2Keys, CancelOrderV2IxData),
    CancelOrderByClientIdV2(CancelOrderByClientIdV2Keys, CancelOrderByClientIdV2IxData),
    SendTake(SendTakeKeys, SendTakeIxData),
    CloseOpenOrders(CloseOpenOrdersKeys, CloseOpenOrdersIxData),
    InitOpenOrders(InitOpenOrdersKeys, InitOpenOrdersIxData),
    Prune(PruneKeys, PruneIxData),
    ConsumeEventsPermissioned(
        ConsumeEventsPermissionedKeys,
        ConsumeEventsPermissionedIxData,
    ),
}
impl ProgramInstruction {
    /// Manual JSON serialization
    #[cfg(feature = "serde")]
    pub fn to_json(&self) -> String {
        match self {
            Self::InitializeMarket(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "InitializeMarket",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::NewOrder(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "NewOrder",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MatchOrders(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "MatchOrders",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ConsumeEvents(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "ConsumeEvents",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CancelOrder(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "CancelOrder",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SettleFunds(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "SettleFunds",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CancelOrderByClientId(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "CancelOrderByClientId",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::DisableMarket(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "DisableMarket",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SweepFees(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "SweepFees",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::NewOrderV2(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "NewOrderV2",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::NewOrderV3(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "NewOrderV3",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CancelOrderV2(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "CancelOrderV2",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CancelOrderByClientIdV2(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "CancelOrderByClientIdV2",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SendTake(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "SendTake",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CloseOpenOrders(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "CloseOpenOrders",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::InitOpenOrders(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "InitOpenOrders",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Prune(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "Prune",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ConsumeEventsPermissioned(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "ConsumeEventsPermissioned",
                    keys.to_json(),
                    data.to_json()
                )
            }
        }
    }
}
/// Parse instruction data using 1-byte discriminator for non-Anchor contracts
pub fn parse_instruction(
    data: &[u8],
    accounts: &[Pubkey],
) -> Result<ProgramInstruction, std::io::Error> {
    if data.is_empty() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Empty instruction data",
        ));
    }
    match data[0] {
        INITIALIZE_MARKET_IX_DISCM => {
            if accounts.len() < INITIALIZE_MARKET_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(InitializeMarket)
                    ),
                ));
            }
            let keys = InitializeMarketKeys::from(&accounts[..INITIALIZE_MARKET_IX_ACCOUNTS_LEN]);
            let args = InitializeMarketIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::InitializeMarket(keys, args))
        }
        NEW_ORDER_IX_DISCM => {
            if accounts.len() < NEW_ORDER_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(NewOrder)
                    ),
                ));
            }
            let keys = NewOrderKeys::from(&accounts[..NEW_ORDER_IX_ACCOUNTS_LEN]);
            let args = NewOrderIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::NewOrder(keys, args))
        }
        MATCH_ORDERS_IX_DISCM => {
            if accounts.len() < MATCH_ORDERS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(MatchOrders)
                    ),
                ));
            }
            let keys = MatchOrdersKeys::from(&accounts[..MATCH_ORDERS_IX_ACCOUNTS_LEN]);
            let args = MatchOrdersIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::MatchOrders(keys, args))
        }
        CONSUME_EVENTS_IX_DISCM => {
            if accounts.len() < CONSUME_EVENTS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(ConsumeEvents)
                    ),
                ));
            }
            let keys = ConsumeEventsKeys::from(&accounts[..CONSUME_EVENTS_IX_ACCOUNTS_LEN]);
            let args = ConsumeEventsIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::ConsumeEvents(keys, args))
        }
        CANCEL_ORDER_IX_DISCM => {
            if accounts.len() < CANCEL_ORDER_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(CancelOrder)
                    ),
                ));
            }
            let keys = CancelOrderKeys::from(&accounts[..CANCEL_ORDER_IX_ACCOUNTS_LEN]);
            let args = CancelOrderIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::CancelOrder(keys, args))
        }
        SETTLE_FUNDS_IX_DISCM => {
            if accounts.len() < SETTLE_FUNDS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(SettleFunds)
                    ),
                ));
            }
            let keys = SettleFundsKeys::from(&accounts[..SETTLE_FUNDS_IX_ACCOUNTS_LEN]);
            let args = SettleFundsIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::SettleFunds(keys, args))
        }
        CANCEL_ORDER_BY_CLIENT_ID_IX_DISCM => {
            if accounts.len() < CANCEL_ORDER_BY_CLIENT_ID_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(CancelOrderByClientId)
                    ),
                ));
            }
            let keys = CancelOrderByClientIdKeys::from(
                &accounts[..CANCEL_ORDER_BY_CLIENT_ID_IX_ACCOUNTS_LEN],
            );
            let args = CancelOrderByClientIdIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::CancelOrderByClientId(keys, args))
        }
        DISABLE_MARKET_IX_DISCM => {
            if accounts.len() < DISABLE_MARKET_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(DisableMarket)
                    ),
                ));
            }
            let keys = DisableMarketKeys::from(&accounts[..DISABLE_MARKET_IX_ACCOUNTS_LEN]);
            let args = DisableMarketIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::DisableMarket(keys, args))
        }
        SWEEP_FEES_IX_DISCM => {
            if accounts.len() < SWEEP_FEES_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(SweepFees)
                    ),
                ));
            }
            let keys = SweepFeesKeys::from(&accounts[..SWEEP_FEES_IX_ACCOUNTS_LEN]);
            let args = SweepFeesIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::SweepFees(keys, args))
        }
        NEW_ORDER_V2_IX_DISCM => {
            if accounts.len() < NEW_ORDER_V2_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(NewOrderV2)
                    ),
                ));
            }
            let keys = NewOrderV2Keys::from(&accounts[..NEW_ORDER_V2_IX_ACCOUNTS_LEN]);
            let args = NewOrderV2IxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::NewOrderV2(keys, args))
        }
        NEW_ORDER_V3_IX_DISCM => {
            if accounts.len() < NEW_ORDER_V3_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(NewOrderV3)
                    ),
                ));
            }
            let keys = NewOrderV3Keys::from(&accounts[..NEW_ORDER_V3_IX_ACCOUNTS_LEN]);
            let args = NewOrderV3IxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::NewOrderV3(keys, args))
        }
        CANCEL_ORDER_V2_IX_DISCM => {
            if accounts.len() < CANCEL_ORDER_V2_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(CancelOrderV2)
                    ),
                ));
            }
            let keys = CancelOrderV2Keys::from(&accounts[..CANCEL_ORDER_V2_IX_ACCOUNTS_LEN]);
            let args = CancelOrderV2IxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::CancelOrderV2(keys, args))
        }
        CANCEL_ORDER_BY_CLIENT_ID_V2_IX_DISCM => {
            if accounts.len() < CANCEL_ORDER_BY_CLIENT_ID_V2_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(CancelOrderByClientIdV2)
                    ),
                ));
            }
            let keys = CancelOrderByClientIdV2Keys::from(
                &accounts[..CANCEL_ORDER_BY_CLIENT_ID_V2_IX_ACCOUNTS_LEN],
            );
            let args = CancelOrderByClientIdV2IxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::CancelOrderByClientIdV2(keys, args))
        }
        SEND_TAKE_IX_DISCM => {
            if accounts.len() < SEND_TAKE_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(SendTake)
                    ),
                ));
            }
            let keys = SendTakeKeys::from(&accounts[..SEND_TAKE_IX_ACCOUNTS_LEN]);
            let args = SendTakeIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::SendTake(keys, args))
        }
        CLOSE_OPEN_ORDERS_IX_DISCM => {
            if accounts.len() < CLOSE_OPEN_ORDERS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(CloseOpenOrders)
                    ),
                ));
            }
            let keys = CloseOpenOrdersKeys::from(&accounts[..CLOSE_OPEN_ORDERS_IX_ACCOUNTS_LEN]);
            let args = CloseOpenOrdersIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::CloseOpenOrders(keys, args))
        }
        INIT_OPEN_ORDERS_IX_DISCM => {
            if accounts.len() < INIT_OPEN_ORDERS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(InitOpenOrders)
                    ),
                ));
            }
            let keys = InitOpenOrdersKeys::from(&accounts[..INIT_OPEN_ORDERS_IX_ACCOUNTS_LEN]);
            let args = InitOpenOrdersIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::InitOpenOrders(keys, args))
        }
        PRUNE_IX_DISCM => {
            if accounts.len() < PRUNE_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(Prune)
                    ),
                ));
            }
            let keys = PruneKeys::from(&accounts[..PRUNE_IX_ACCOUNTS_LEN]);
            let args = PruneIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::Prune(keys, args))
        }
        CONSUME_EVENTS_PERMISSIONED_IX_DISCM => {
            if accounts.len() < CONSUME_EVENTS_PERMISSIONED_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(ConsumeEventsPermissioned)
                    ),
                ));
            }
            let keys = ConsumeEventsPermissionedKeys::from(
                &accounts[..CONSUME_EVENTS_PERMISSIONED_IX_ACCOUNTS_LEN],
            );
            let args = ConsumeEventsPermissionedIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::ConsumeEventsPermissioned(keys, args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {}", data[0]),
        )),
    }
}
