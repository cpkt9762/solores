//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-16
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

//! Instructions parser for Anchor contracts with 8-byte discriminators
use crate::instructions::*;
#[allow(unused_imports)]
use solana_pubkey::Pubkey;
/// Program instruction types for Anchor contract
#[derive(Clone, Debug, PartialEq)]
pub enum SquadsInstruction {
    ///Initialize the program config.
    ProgramConfigInit(ProgramConfigInitKeys, ProgramConfigInitIxData),
    ///Set the `authority` parameter of the program config.
    ProgramConfigSetAuthority(
        ProgramConfigSetAuthorityKeys,
        ProgramConfigSetAuthorityIxData,
    ),
    ///Set the `multisig_creation_fee` parameter of the program config.
    ProgramConfigSetMultisigCreationFee(
        ProgramConfigSetMultisigCreationFeeKeys,
        ProgramConfigSetMultisigCreationFeeIxData,
    ),
    ///Set the `treasury` parameter of the program config.
    ProgramConfigSetTreasury(ProgramConfigSetTreasuryKeys, ProgramConfigSetTreasuryIxData),
    ///Create a multisig.
    MultisigCreate(MultisigCreateKeys, MultisigCreateIxData),
    ///Create a multisig.
    MultisigCreateV2(MultisigCreateV2Keys, MultisigCreateV2IxData),
    ///Add a new member to the controlled multisig.
    MultisigAddMember(MultisigAddMemberKeys, MultisigAddMemberIxData),
    ///Remove a member/key from the controlled multisig.
    MultisigRemoveMember(MultisigRemoveMemberKeys, MultisigRemoveMemberIxData),
    ///Set the `time_lock` config parameter for the controlled multisig.
    MultisigSetTimeLock(MultisigSetTimeLockKeys, MultisigSetTimeLockIxData),
    ///Set the `threshold` config parameter for the controlled multisig.
    MultisigChangeThreshold(MultisigChangeThresholdKeys, MultisigChangeThresholdIxData),
    ///Set the multisig `config_authority`.
    MultisigSetConfigAuthority(
        MultisigSetConfigAuthorityKeys,
        MultisigSetConfigAuthorityIxData,
    ),
    ///Set the multisig `rent_collector`.
    MultisigSetRentCollector(MultisigSetRentCollectorKeys, MultisigSetRentCollectorIxData),
    ///Create a new spending limit for the controlled multisig.
    MultisigAddSpendingLimit(MultisigAddSpendingLimitKeys, MultisigAddSpendingLimitIxData),
    ///Remove the spending limit from the controlled multisig.
    MultisigRemoveSpendingLimit(
        MultisigRemoveSpendingLimitKeys,
        MultisigRemoveSpendingLimitIxData,
    ),
    ///Create a new config transaction.
    ConfigTransactionCreate(ConfigTransactionCreateKeys, ConfigTransactionCreateIxData),
    ///Execute a config transaction.
    ///The transaction must be `Approved`.
    ConfigTransactionExecute(ConfigTransactionExecuteKeys, ConfigTransactionExecuteIxData),
    ///Create a new vault transaction.
    VaultTransactionCreate(VaultTransactionCreateKeys, VaultTransactionCreateIxData),
    ///Execute a vault transaction.
    ///The transaction must be `Approved`.
    VaultTransactionExecute(VaultTransactionExecuteKeys, VaultTransactionExecuteIxData),
    ///Create a new batch.
    BatchCreate(BatchCreateKeys, BatchCreateIxData),
    ///Add a transaction to the batch.
    BatchAddTransaction(BatchAddTransactionKeys, BatchAddTransactionIxData),
    ///Execute a transaction from the batch.
    BatchExecuteTransaction(BatchExecuteTransactionKeys, BatchExecuteTransactionIxData),
    ///Create a new multisig proposal.
    ProposalCreate(ProposalCreateKeys, ProposalCreateIxData),
    ///Update status of a multisig proposal from `Draft` to `Active`.
    ProposalActivate(ProposalActivateKeys, ProposalActivateIxData),
    ///Approve a multisig proposal on behalf of the `member`.
    ///The proposal must be `Active`.
    ProposalApprove(ProposalApproveKeys, ProposalApproveIxData),
    ///Reject a multisig proposal on behalf of the `member`.
    ///The proposal must be `Active`.
    ProposalReject(ProposalRejectKeys, ProposalRejectIxData),
    ///Cancel a multisig proposal on behalf of the `member`.
    ///The proposal must be `Approved`.
    ProposalCancel(ProposalCancelKeys, ProposalCancelIxData),
    ///Use a spending limit to transfer tokens from a multisig vault to a destination account.
    SpendingLimitUse(SpendingLimitUseKeys, SpendingLimitUseIxData),
    ///Closes a `ConfigTransaction` and the corresponding `Proposal`.
    ///`transaction` can be closed if either:
    ///- the `proposal` is in a terminal state: `Executed`, `Rejected`, or `Cancelled`.
    ///- the `proposal` is stale.
    ConfigTransactionAccountsClose(
        ConfigTransactionAccountsCloseKeys,
        ConfigTransactionAccountsCloseIxData,
    ),
    ///Closes a `VaultTransaction` and the corresponding `Proposal`.
    ///`transaction` can be closed if either:
    ///- the `proposal` is in a terminal state: `Executed`, `Rejected`, or `Cancelled`.
    ///- the `proposal` is stale and not `Approved`.
    VaultTransactionAccountsClose(
        VaultTransactionAccountsCloseKeys,
        VaultTransactionAccountsCloseIxData,
    ),
    ///Closes a `VaultBatchTransaction` belonging to the `batch` and `proposal`.
    ///`transaction` can be closed if either:
    ///- it's marked as executed within the `batch`;
    ///- the `proposal` is in a terminal state: `Executed`, `Rejected`, or `Cancelled`.
    ///- the `proposal` is stale and not `Approved`.
    VaultBatchTransactionAccountClose(
        VaultBatchTransactionAccountCloseKeys,
        VaultBatchTransactionAccountCloseIxData,
    ),
    ///Closes Batch and the corresponding Proposal accounts for proposals in terminal states:
    ///`Executed`, `Rejected`, or `Cancelled` or stale proposals that aren't `Approved`.
    ///This instruction is only allowed to be executed when all `VaultBatchTransaction` accounts
    ///in the `batch` are already closed: `batch.size == 0`.
    BatchAccountsClose(BatchAccountsCloseKeys, BatchAccountsCloseIxData),
}
impl SquadsInstruction {
    /// Manual JSON serialization
    #[cfg(feature = "serde")]
    pub fn to_json(&self) -> String {
        match self {
            Self::ProgramConfigInit(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "programConfigInit",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ProgramConfigSetAuthority(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "programConfigSetAuthority",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ProgramConfigSetMultisigCreationFee(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "programConfigSetMultisigCreationFee",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ProgramConfigSetTreasury(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "programConfigSetTreasury",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MultisigCreate(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "multisigCreate",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MultisigCreateV2(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "multisigCreateV2",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MultisigAddMember(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "multisigAddMember",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MultisigRemoveMember(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "multisigRemoveMember",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MultisigSetTimeLock(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "multisigSetTimeLock",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MultisigChangeThreshold(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "multisigChangeThreshold",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MultisigSetConfigAuthority(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "multisigSetConfigAuthority",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MultisigSetRentCollector(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "multisigSetRentCollector",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MultisigAddSpendingLimit(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "multisigAddSpendingLimit",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MultisigRemoveSpendingLimit(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "multisigRemoveSpendingLimit",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ConfigTransactionCreate(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "configTransactionCreate",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ConfigTransactionExecute(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "configTransactionExecute",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::VaultTransactionCreate(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "vaultTransactionCreate",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::VaultTransactionExecute(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "vaultTransactionExecute",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::BatchCreate(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "batchCreate",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::BatchAddTransaction(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "batchAddTransaction",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::BatchExecuteTransaction(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "batchExecuteTransaction",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ProposalCreate(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "proposalCreate",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ProposalActivate(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "proposalActivate",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ProposalApprove(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "proposalApprove",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ProposalReject(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "proposalReject",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ProposalCancel(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "proposalCancel",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SpendingLimitUse(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "spendingLimitUse",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ConfigTransactionAccountsClose(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "configTransactionAccountsClose",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::VaultTransactionAccountsClose(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "vaultTransactionAccountsClose",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::VaultBatchTransactionAccountClose(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "vaultBatchTransactionAccountClose",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::BatchAccountsClose(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "batchAccountsClose",
                    keys.to_json(),
                    data.to_json()
                )
            }
        }
    }
}
/// Helper function to check minimum accounts requirement
fn check_min_accounts_req(
    accounts: &[Pubkey],
    required_len: usize,
    instruction_name: &str,
) -> Result<(), std::io::Error> {
    if accounts.len() < required_len {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Insufficient accounts for instruction {}", instruction_name),
        ));
    }
    Ok(())
}
/// Parse instruction data based on 8-byte discriminator (Anchor contracts)
pub fn parse_instruction(
    data: &[u8],
    accounts: &[Pubkey],
) -> Result<SquadsInstruction, std::io::Error> {
    if data.len() < 8 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data too short for discriminator",
        ));
    }
    let discriminator: [u8; 8] = data[0..8].try_into().map_err(|_| {
        std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Failed to read discriminator",
        )
    })?;
    match discriminator {
        PROGRAM_CONFIG_INIT_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                PROGRAM_CONFIG_INIT_IX_ACCOUNTS_LEN,
                "ProgramConfigInit",
            )?;
            let ix_accounts =
                ProgramConfigInitKeys::from(&accounts[..PROGRAM_CONFIG_INIT_IX_ACCOUNTS_LEN]);
            let args = ProgramConfigInitIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::ProgramConfigInit(ix_accounts, args))
        }
        PROGRAM_CONFIG_SET_AUTHORITY_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                PROGRAM_CONFIG_SET_AUTHORITY_IX_ACCOUNTS_LEN,
                "ProgramConfigSetAuthority",
            )?;
            let ix_accounts = ProgramConfigSetAuthorityKeys::from(
                &accounts[..PROGRAM_CONFIG_SET_AUTHORITY_IX_ACCOUNTS_LEN],
            );
            let args = ProgramConfigSetAuthorityIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::ProgramConfigSetAuthority(
                ix_accounts,
                args,
            ))
        }
        PROGRAM_CONFIG_SET_MULTISIG_CREATION_FEE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                PROGRAM_CONFIG_SET_MULTISIG_CREATION_FEE_IX_ACCOUNTS_LEN,
                "ProgramConfigSetMultisigCreationFee",
            )?;
            let ix_accounts = ProgramConfigSetMultisigCreationFeeKeys::from(
                &accounts[..PROGRAM_CONFIG_SET_MULTISIG_CREATION_FEE_IX_ACCOUNTS_LEN],
            );
            let args = ProgramConfigSetMultisigCreationFeeIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::ProgramConfigSetMultisigCreationFee(
                ix_accounts,
                args,
            ))
        }
        PROGRAM_CONFIG_SET_TREASURY_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                PROGRAM_CONFIG_SET_TREASURY_IX_ACCOUNTS_LEN,
                "ProgramConfigSetTreasury",
            )?;
            let ix_accounts = ProgramConfigSetTreasuryKeys::from(
                &accounts[..PROGRAM_CONFIG_SET_TREASURY_IX_ACCOUNTS_LEN],
            );
            let args = ProgramConfigSetTreasuryIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::ProgramConfigSetTreasury(
                ix_accounts,
                args,
            ))
        }
        MULTISIG_CREATE_IX_DISCM => {
            check_min_accounts_req(accounts, MULTISIG_CREATE_IX_ACCOUNTS_LEN, "MultisigCreate")?;
            let ix_accounts =
                MultisigCreateKeys::from(&accounts[..MULTISIG_CREATE_IX_ACCOUNTS_LEN]);
            let args = MultisigCreateIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::MultisigCreate(ix_accounts, args))
        }
        MULTISIG_CREATE_V_2_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                MULTISIG_CREATE_V_2_IX_ACCOUNTS_LEN,
                "MultisigCreateV2",
            )?;
            let ix_accounts =
                MultisigCreateV2Keys::from(&accounts[..MULTISIG_CREATE_V_2_IX_ACCOUNTS_LEN]);
            let args = MultisigCreateV2IxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::MultisigCreateV2(ix_accounts, args))
        }
        MULTISIG_ADD_MEMBER_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                MULTISIG_ADD_MEMBER_IX_ACCOUNTS_LEN,
                "MultisigAddMember",
            )?;
            let ix_accounts =
                MultisigAddMemberKeys::from(&accounts[..MULTISIG_ADD_MEMBER_IX_ACCOUNTS_LEN]);
            let args = MultisigAddMemberIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::MultisigAddMember(ix_accounts, args))
        }
        MULTISIG_REMOVE_MEMBER_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                MULTISIG_REMOVE_MEMBER_IX_ACCOUNTS_LEN,
                "MultisigRemoveMember",
            )?;
            let ix_accounts =
                MultisigRemoveMemberKeys::from(&accounts[..MULTISIG_REMOVE_MEMBER_IX_ACCOUNTS_LEN]);
            let args = MultisigRemoveMemberIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::MultisigRemoveMember(ix_accounts, args))
        }
        MULTISIG_SET_TIME_LOCK_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                MULTISIG_SET_TIME_LOCK_IX_ACCOUNTS_LEN,
                "MultisigSetTimeLock",
            )?;
            let ix_accounts =
                MultisigSetTimeLockKeys::from(&accounts[..MULTISIG_SET_TIME_LOCK_IX_ACCOUNTS_LEN]);
            let args = MultisigSetTimeLockIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::MultisigSetTimeLock(ix_accounts, args))
        }
        MULTISIG_CHANGE_THRESHOLD_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                MULTISIG_CHANGE_THRESHOLD_IX_ACCOUNTS_LEN,
                "MultisigChangeThreshold",
            )?;
            let ix_accounts = MultisigChangeThresholdKeys::from(
                &accounts[..MULTISIG_CHANGE_THRESHOLD_IX_ACCOUNTS_LEN],
            );
            let args = MultisigChangeThresholdIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::MultisigChangeThreshold(
                ix_accounts,
                args,
            ))
        }
        MULTISIG_SET_CONFIG_AUTHORITY_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                MULTISIG_SET_CONFIG_AUTHORITY_IX_ACCOUNTS_LEN,
                "MultisigSetConfigAuthority",
            )?;
            let ix_accounts = MultisigSetConfigAuthorityKeys::from(
                &accounts[..MULTISIG_SET_CONFIG_AUTHORITY_IX_ACCOUNTS_LEN],
            );
            let args = MultisigSetConfigAuthorityIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::MultisigSetConfigAuthority(
                ix_accounts,
                args,
            ))
        }
        MULTISIG_SET_RENT_COLLECTOR_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                MULTISIG_SET_RENT_COLLECTOR_IX_ACCOUNTS_LEN,
                "MultisigSetRentCollector",
            )?;
            let ix_accounts = MultisigSetRentCollectorKeys::from(
                &accounts[..MULTISIG_SET_RENT_COLLECTOR_IX_ACCOUNTS_LEN],
            );
            let args = MultisigSetRentCollectorIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::MultisigSetRentCollector(
                ix_accounts,
                args,
            ))
        }
        MULTISIG_ADD_SPENDING_LIMIT_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                MULTISIG_ADD_SPENDING_LIMIT_IX_ACCOUNTS_LEN,
                "MultisigAddSpendingLimit",
            )?;
            let ix_accounts = MultisigAddSpendingLimitKeys::from(
                &accounts[..MULTISIG_ADD_SPENDING_LIMIT_IX_ACCOUNTS_LEN],
            );
            let args = MultisigAddSpendingLimitIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::MultisigAddSpendingLimit(
                ix_accounts,
                args,
            ))
        }
        MULTISIG_REMOVE_SPENDING_LIMIT_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                MULTISIG_REMOVE_SPENDING_LIMIT_IX_ACCOUNTS_LEN,
                "MultisigRemoveSpendingLimit",
            )?;
            let ix_accounts = MultisigRemoveSpendingLimitKeys::from(
                &accounts[..MULTISIG_REMOVE_SPENDING_LIMIT_IX_ACCOUNTS_LEN],
            );
            let args = MultisigRemoveSpendingLimitIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::MultisigRemoveSpendingLimit(
                ix_accounts,
                args,
            ))
        }
        CONFIG_TRANSACTION_CREATE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CONFIG_TRANSACTION_CREATE_IX_ACCOUNTS_LEN,
                "ConfigTransactionCreate",
            )?;
            let ix_accounts = ConfigTransactionCreateKeys::from(
                &accounts[..CONFIG_TRANSACTION_CREATE_IX_ACCOUNTS_LEN],
            );
            let args = ConfigTransactionCreateIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::ConfigTransactionCreate(
                ix_accounts,
                args,
            ))
        }
        CONFIG_TRANSACTION_EXECUTE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CONFIG_TRANSACTION_EXECUTE_IX_ACCOUNTS_LEN,
                "ConfigTransactionExecute",
            )?;
            let ix_accounts = ConfigTransactionExecuteKeys::from(
                &accounts[..CONFIG_TRANSACTION_EXECUTE_IX_ACCOUNTS_LEN],
            );
            let args = ConfigTransactionExecuteIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::ConfigTransactionExecute(
                ix_accounts,
                args,
            ))
        }
        VAULT_TRANSACTION_CREATE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                VAULT_TRANSACTION_CREATE_IX_ACCOUNTS_LEN,
                "VaultTransactionCreate",
            )?;
            let ix_accounts = VaultTransactionCreateKeys::from(
                &accounts[..VAULT_TRANSACTION_CREATE_IX_ACCOUNTS_LEN],
            );
            let args = VaultTransactionCreateIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::VaultTransactionCreate(ix_accounts, args))
        }
        VAULT_TRANSACTION_EXECUTE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                VAULT_TRANSACTION_EXECUTE_IX_ACCOUNTS_LEN,
                "VaultTransactionExecute",
            )?;
            let ix_accounts = VaultTransactionExecuteKeys::from(
                &accounts[..VAULT_TRANSACTION_EXECUTE_IX_ACCOUNTS_LEN],
            );
            let args = VaultTransactionExecuteIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::VaultTransactionExecute(
                ix_accounts,
                args,
            ))
        }
        BATCH_CREATE_IX_DISCM => {
            check_min_accounts_req(accounts, BATCH_CREATE_IX_ACCOUNTS_LEN, "BatchCreate")?;
            let ix_accounts = BatchCreateKeys::from(&accounts[..BATCH_CREATE_IX_ACCOUNTS_LEN]);
            let args = BatchCreateIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::BatchCreate(ix_accounts, args))
        }
        BATCH_ADD_TRANSACTION_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                BATCH_ADD_TRANSACTION_IX_ACCOUNTS_LEN,
                "BatchAddTransaction",
            )?;
            let ix_accounts =
                BatchAddTransactionKeys::from(&accounts[..BATCH_ADD_TRANSACTION_IX_ACCOUNTS_LEN]);
            let args = BatchAddTransactionIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::BatchAddTransaction(ix_accounts, args))
        }
        BATCH_EXECUTE_TRANSACTION_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                BATCH_EXECUTE_TRANSACTION_IX_ACCOUNTS_LEN,
                "BatchExecuteTransaction",
            )?;
            let ix_accounts = BatchExecuteTransactionKeys::from(
                &accounts[..BATCH_EXECUTE_TRANSACTION_IX_ACCOUNTS_LEN],
            );
            let args = BatchExecuteTransactionIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::BatchExecuteTransaction(
                ix_accounts,
                args,
            ))
        }
        PROPOSAL_CREATE_IX_DISCM => {
            check_min_accounts_req(accounts, PROPOSAL_CREATE_IX_ACCOUNTS_LEN, "ProposalCreate")?;
            let ix_accounts =
                ProposalCreateKeys::from(&accounts[..PROPOSAL_CREATE_IX_ACCOUNTS_LEN]);
            let args = ProposalCreateIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::ProposalCreate(ix_accounts, args))
        }
        PROPOSAL_ACTIVATE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                PROPOSAL_ACTIVATE_IX_ACCOUNTS_LEN,
                "ProposalActivate",
            )?;
            let ix_accounts =
                ProposalActivateKeys::from(&accounts[..PROPOSAL_ACTIVATE_IX_ACCOUNTS_LEN]);
            let args = ProposalActivateIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::ProposalActivate(ix_accounts, args))
        }
        PROPOSAL_APPROVE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                PROPOSAL_APPROVE_IX_ACCOUNTS_LEN,
                "ProposalApprove",
            )?;
            let ix_accounts =
                ProposalApproveKeys::from(&accounts[..PROPOSAL_APPROVE_IX_ACCOUNTS_LEN]);
            let args = ProposalApproveIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::ProposalApprove(ix_accounts, args))
        }
        PROPOSAL_REJECT_IX_DISCM => {
            check_min_accounts_req(accounts, PROPOSAL_REJECT_IX_ACCOUNTS_LEN, "ProposalReject")?;
            let ix_accounts =
                ProposalRejectKeys::from(&accounts[..PROPOSAL_REJECT_IX_ACCOUNTS_LEN]);
            let args = ProposalRejectIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::ProposalReject(ix_accounts, args))
        }
        PROPOSAL_CANCEL_IX_DISCM => {
            check_min_accounts_req(accounts, PROPOSAL_CANCEL_IX_ACCOUNTS_LEN, "ProposalCancel")?;
            let ix_accounts =
                ProposalCancelKeys::from(&accounts[..PROPOSAL_CANCEL_IX_ACCOUNTS_LEN]);
            let args = ProposalCancelIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::ProposalCancel(ix_accounts, args))
        }
        SPENDING_LIMIT_USE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                SPENDING_LIMIT_USE_IX_ACCOUNTS_LEN,
                "SpendingLimitUse",
            )?;
            let ix_accounts =
                SpendingLimitUseKeys::from(&accounts[..SPENDING_LIMIT_USE_IX_ACCOUNTS_LEN]);
            let args = SpendingLimitUseIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::SpendingLimitUse(ix_accounts, args))
        }
        CONFIG_TRANSACTION_ACCOUNTS_CLOSE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CONFIG_TRANSACTION_ACCOUNTS_CLOSE_IX_ACCOUNTS_LEN,
                "ConfigTransactionAccountsClose",
            )?;
            let ix_accounts = ConfigTransactionAccountsCloseKeys::from(
                &accounts[..CONFIG_TRANSACTION_ACCOUNTS_CLOSE_IX_ACCOUNTS_LEN],
            );
            let args = ConfigTransactionAccountsCloseIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::ConfigTransactionAccountsClose(
                ix_accounts,
                args,
            ))
        }
        VAULT_TRANSACTION_ACCOUNTS_CLOSE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                VAULT_TRANSACTION_ACCOUNTS_CLOSE_IX_ACCOUNTS_LEN,
                "VaultTransactionAccountsClose",
            )?;
            let ix_accounts = VaultTransactionAccountsCloseKeys::from(
                &accounts[..VAULT_TRANSACTION_ACCOUNTS_CLOSE_IX_ACCOUNTS_LEN],
            );
            let args = VaultTransactionAccountsCloseIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::VaultTransactionAccountsClose(
                ix_accounts,
                args,
            ))
        }
        VAULT_BATCH_TRANSACTION_ACCOUNT_CLOSE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                VAULT_BATCH_TRANSACTION_ACCOUNT_CLOSE_IX_ACCOUNTS_LEN,
                "VaultBatchTransactionAccountClose",
            )?;
            let ix_accounts = VaultBatchTransactionAccountCloseKeys::from(
                &accounts[..VAULT_BATCH_TRANSACTION_ACCOUNT_CLOSE_IX_ACCOUNTS_LEN],
            );
            let args = VaultBatchTransactionAccountCloseIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::VaultBatchTransactionAccountClose(
                ix_accounts,
                args,
            ))
        }
        BATCH_ACCOUNTS_CLOSE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                BATCH_ACCOUNTS_CLOSE_IX_ACCOUNTS_LEN,
                "BatchAccountsClose",
            )?;
            let ix_accounts =
                BatchAccountsCloseKeys::from(&accounts[..BATCH_ACCOUNTS_CLOSE_IX_ACCOUNTS_LEN]);
            let args = BatchAccountsCloseIxData::from_bytes(&data[..])?;
            Ok(SquadsInstruction::BatchAccountsClose(ix_accounts, args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {:?}", discriminator),
        )),
    }
}
