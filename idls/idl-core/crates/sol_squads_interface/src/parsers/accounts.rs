//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-16
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

//! Account parser for Anchor contracts with 8-byte discriminators
use crate::accounts::*;
#[allow(unused_imports)]
use solana_pubkey::Pubkey;
/// Account parsing error types
#[derive(Clone, Debug, PartialEq)]
pub enum AccountParseError {
    /// Discriminator does not match any known account type - can try next account
    DiscriminatorMismatch { expected: [u8; 8], found: [u8; 8] },
    /// Data is too short to contain discriminator - should not try other accounts
    DataTooShort { expected: usize, found: usize },
    /// Data length is incorrect for this account type - should not try other accounts
    IncorrectLength { expected: usize, found: usize },
    /// Failed to deserialize account data - should not try other accounts
    DeserializationFailed(String),
}
impl std::fmt::Display for AccountParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AccountParseError::DiscriminatorMismatch { expected, found } => {
                write!(
                    f,
                    "Discriminator mismatch. Expected: {:?}, found: {:?}",
                    expected, found
                )
            }
            AccountParseError::DataTooShort { expected, found } => {
                write!(
                    f,
                    "Account data too short. Expected at least {} bytes, got: {}",
                    expected, found
                )
            }
            AccountParseError::IncorrectLength { expected, found } => {
                write!(
                    f,
                    "Account data length mismatch. Expected: {}, got: {}",
                    expected, found
                )
            }
            AccountParseError::DeserializationFailed(msg) => {
                write!(f, "Failed to deserialize account data: {}", msg)
            }
        }
    }
}
impl std::error::Error for AccountParseError {}
impl From<AccountParseError> for std::io::Error {
    fn from(err: AccountParseError) -> std::io::Error {
        std::io::Error::new(std::io::ErrorKind::InvalidData, err.to_string())
    }
}
/// Program account types
#[derive(Clone, Debug, PartialEq)]
pub enum SquadsAccount {
    Batch(Batch),
    VaultBatchTransaction(VaultBatchTransaction),
    ConfigTransaction(ConfigTransaction),
    Multisig(Multisig),
    ProgramConfig(ProgramConfig),
    Proposal(Proposal),
    SpendingLimit(SpendingLimit),
    VaultTransaction(VaultTransaction),
}
/// Try to parse account data into one of the known account types
pub fn try_unpack_account(data: &[u8]) -> Result<SquadsAccount, std::io::Error> {
    match Batch::from_bytes(data) {
        Ok(account) => return Ok(SquadsAccount::Batch(account)),
        Err(AccountParseError::DiscriminatorMismatch { .. }) => {}
        Err(e) => {
            return Err(e.into());
        }
    }
    match VaultBatchTransaction::from_bytes(data) {
        Ok(account) => return Ok(SquadsAccount::VaultBatchTransaction(account)),
        Err(AccountParseError::DiscriminatorMismatch { .. }) => {}
        Err(e) => {
            return Err(e.into());
        }
    }
    match ConfigTransaction::from_bytes(data) {
        Ok(account) => return Ok(SquadsAccount::ConfigTransaction(account)),
        Err(AccountParseError::DiscriminatorMismatch { .. }) => {}
        Err(e) => {
            return Err(e.into());
        }
    }
    match Multisig::from_bytes(data) {
        Ok(account) => return Ok(SquadsAccount::Multisig(account)),
        Err(AccountParseError::DiscriminatorMismatch { .. }) => {}
        Err(e) => {
            return Err(e.into());
        }
    }
    match ProgramConfig::from_bytes(data) {
        Ok(account) => return Ok(SquadsAccount::ProgramConfig(account)),
        Err(AccountParseError::DiscriminatorMismatch { .. }) => {}
        Err(e) => {
            return Err(e.into());
        }
    }
    match Proposal::from_bytes(data) {
        Ok(account) => return Ok(SquadsAccount::Proposal(account)),
        Err(AccountParseError::DiscriminatorMismatch { .. }) => {}
        Err(e) => {
            return Err(e.into());
        }
    }
    match SpendingLimit::from_bytes(data) {
        Ok(account) => return Ok(SquadsAccount::SpendingLimit(account)),
        Err(AccountParseError::DiscriminatorMismatch { .. }) => {}
        Err(e) => {
            return Err(e.into());
        }
    }
    match VaultTransaction::from_bytes(data) {
        Ok(account) => return Ok(SquadsAccount::VaultTransaction(account)),
        Err(AccountParseError::DiscriminatorMismatch { .. }) => {}
        Err(e) => {
            return Err(e.into());
        }
    }
    Err(std::io::Error::new(
        std::io::ErrorKind::InvalidData,
        "Unable to parse account data into any known account type",
    ))
}
