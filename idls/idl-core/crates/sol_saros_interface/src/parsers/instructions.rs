//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-16
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

//! Instructions parser for non-Anchor contracts with 1-byte discriminators
use crate::instructions::*;
use solana_pubkey::Pubkey;
/// Program instruction types for non-Anchor contracts
#[derive(Clone, Debug, PartialEq)]
pub enum ProgramInstruction {
    CreateFeed(CreateFeedKeys, CreateFeedIxData),
    SubmitFeed(SubmitFeedKeys, SubmitFeedIxData),
    Query(QueryKeys, QueryIxData),
}
impl ProgramInstruction {
    /// Manual JSON serialization
    #[cfg(feature = "serde")]
    pub fn to_json(&self) -> String {
        match self {
            Self::CreateFeed(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "createFeed",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SubmitFeed(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "submitFeed",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Query(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "query",
                    keys.to_json(),
                    data.to_json()
                )
            }
        }
    }
}
/// Parse instruction data using 1-byte discriminator for non-Anchor contracts
pub fn parse_instruction(
    data: &[u8],
    accounts: &[Pubkey],
) -> Result<ProgramInstruction, std::io::Error> {
    if data.is_empty() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Empty instruction data",
        ));
    }
    match data[0] {
        CREATE_FEED_IX_DISCM => {
            if accounts.len() < CREATE_FEED_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(CreateFeed)
                    ),
                ));
            }
            let keys = CreateFeedKeys::from(&accounts[..CREATE_FEED_IX_ACCOUNTS_LEN]);
            let args = CreateFeedIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::CreateFeed(keys, args))
        }
        SUBMIT_FEED_IX_DISCM => {
            if accounts.len() < SUBMIT_FEED_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(SubmitFeed)
                    ),
                ));
            }
            let keys = SubmitFeedKeys::from(&accounts[..SUBMIT_FEED_IX_ACCOUNTS_LEN]);
            let args = SubmitFeedIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::SubmitFeed(keys, args))
        }
        QUERY_IX_DISCM => {
            if accounts.len() < QUERY_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(Query)
                    ),
                ));
            }
            let keys = QueryKeys::from(&accounts[..QUERY_IX_ACCOUNTS_LEN]);
            let args = QueryIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::Query(keys, args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {}", data[0]),
        )),
    }
}
