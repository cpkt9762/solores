//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-15
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

//! Instructions parser for Anchor contracts with 8-byte discriminators
use crate::instructions::*;
#[allow(unused_imports)]
use solana_pubkey::Pubkey;
/// Program instruction types for Anchor contract
#[derive(Clone, Debug, PartialEq)]
pub enum RaydiumLaunchpadInstruction {
    ///Use the given amount of quote tokens to purchase base tokens.
    ///# Arguments
    ///* `ctx` - The context of accounts
    ///* `amount_in` - Amount of quote token to purchase
    ///* `minimum_amount_out` - Minimum amount of base token to receive (slippage protection)
    ///* `share_fee_rate` - Fee rate for the share
    BuyExactIn(BuyExactInKeys, BuyExactInIxData),
    ///Use quote tokens to purchase the given amount of base tokens.
    ///# Arguments
    ///* `ctx` - The context of accounts
    ///* `amount_out` - Amount of base token to receive
    ///* `maximum_amount_in` - Maximum amount of quote token to purchase (slippage protection)
    ///* `share_fee_rate` - Fee rate for the share
    BuyExactOut(BuyExactOutKeys, BuyExactOutIxData),
    ///Claim platform fee
    ///# Arguments
    ///* `ctx` - The context of accounts
    ClaimPlatformFee(ClaimPlatformFeeKeys, ClaimPlatformFeeIxData),
    ///Claim vested token
    ///# Arguments
    ClaimVestedToken(ClaimVestedTokenKeys, ClaimVestedTokenIxData),
    ///Collects accumulated fees from the pool
    ///# Arguments
    ///* `ctx` - The context of accounts
    CollectFee(CollectFeeKeys, CollectFeeIxData),
    ///Collects  migrate fees from the pool
    ///# Arguments
    ///* `ctx` - The context of accounts
    CollectMigrateFee(CollectMigrateFeeKeys, CollectMigrateFeeIxData),
    ///Creates a new configuration
    ///# Arguments
    ///* `ctx` - The accounts needed by instruction
    ///* `curve_type` - The type of bonding curve (0: ConstantProduct)
    ///* `index` - The index of config, there may be multiple config with the same curve type.
    ///* `trade_fee_rate` - Trade fee rate, must be less than RATE_DENOMINATOR_VALUE
    CreateConfig(CreateConfigKeys, CreateConfigIxData),
    ///Create platform config account
    ///# Arguments
    ///* `ctx` - The context of accounts
    ///# Fields
    ///* `fee_rate` - Fee rate of the platform
    ///* `name` - Name of the platform
    ///* `web` - Website of the platform
    ///* `img` - Image link of the platform
    CreatePlatformConfig(CreatePlatformConfigKeys, CreatePlatformConfigIxData),
    ///Create vesting account
    ///# Arguments
    ///* `ctx` - The context of accounts
    ///* `share` - The share amount of base token to be vested
    CreateVestingAccount(CreateVestingAccountKeys, CreateVestingAccountIxData),
    ///Initializes a new trading pool
    ///# Arguments
    ///* `ctx` - The context of accounts containing pool and token information
    Initialize(InitializeKeys, InitializeIxData),
    ///# Arguments
    ///* `ctx` - The context of accounts
    MigrateToAmm(MigrateToAmmKeys, MigrateToAmmIxData),
    ///# Arguments
    ///* `ctx` - The context of accounts
    MigrateToCpswap(MigrateToCpswapKeys, MigrateToCpswapIxData),
    ///Use the given amount of base tokens to sell for quote tokens.
    ///# Arguments
    ///* `ctx` - The context of accounts
    ///* `amount_in` - Amount of base token to sell
    ///* `minimum_amount_out` - Minimum amount of quote token to receive (slippage protection)
    ///* `share_fee_rate` - Fee rate for the share
    SellExactIn(SellExactInKeys, SellExactInIxData),
    ///Sell base tokens for the given amount of quote tokens.
    ///# Arguments
    ///* `ctx` - The context of accounts
    ///* `amount_out` - Amount of quote token to receive
    ///* `maximum_amount_in` - Maximum amount of base token to purchase (slippage protection)
    ///* `share_fee_rate` - Fee rate for the share
    SellExactOut(SellExactOutKeys, SellExactOutIxData),
    ///Updates configuration parameters
    ///# Arguments
    ///* `ctx` - The context of accounts
    ///* `param` - Parameter to update:
    ///- 0: Update trade_fee_rate
    ///- 1: Update fee owner
    ///* `value` - New value for the selected parameter
    UpdateConfig(UpdateConfigKeys, UpdateConfigIxData),
    ///Update platform config
    ///# Arguments
    ///* `ctx` - The context of accounts
    ///* `param` - Parameter to update
    UpdatePlatformConfig(UpdatePlatformConfigKeys, UpdatePlatformConfigIxData),
}
impl RaydiumLaunchpadInstruction {
    /// Manual JSON serialization
    #[cfg(feature = "serde")]
    pub fn to_json(&self) -> String {
        match self {
            Self::BuyExactIn(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "buy_exact_in",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::BuyExactOut(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "buy_exact_out",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ClaimPlatformFee(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "claim_platform_fee",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ClaimVestedToken(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "claim_vested_token",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CollectFee(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "collect_fee",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CollectMigrateFee(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "collect_migrate_fee",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CreateConfig(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "create_config",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CreatePlatformConfig(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "create_platform_config",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CreateVestingAccount(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "create_vesting_account",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Initialize(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initialize",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MigrateToAmm(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "migrate_to_amm",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MigrateToCpswap(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "migrate_to_cpswap",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SellExactIn(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "sell_exact_in",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SellExactOut(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "sell_exact_out",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::UpdateConfig(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "update_config",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::UpdatePlatformConfig(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "update_platform_config",
                    keys.to_json(),
                    data.to_json()
                )
            }
        }
    }
}
/// Helper function to check minimum accounts requirement
fn check_min_accounts_req(
    accounts: &[Pubkey],
    required_len: usize,
    instruction_name: &str,
) -> Result<(), std::io::Error> {
    if accounts.len() < required_len {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Insufficient accounts for instruction {}", instruction_name),
        ));
    }
    Ok(())
}
/// Parse instruction data based on 8-byte discriminator (Anchor contracts)
pub fn parse_instruction(
    data: &[u8],
    accounts: &[Pubkey],
) -> Result<RaydiumLaunchpadInstruction, std::io::Error> {
    if data.len() < 8 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data too short for discriminator",
        ));
    }
    let discriminator: [u8; 8] = data[0..8].try_into().map_err(|_| {
        std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Failed to read discriminator",
        )
    })?;
    match discriminator {
        BUY_EXACT_IN_IX_DISCM => {
            check_min_accounts_req(accounts, BUY_EXACT_IN_IX_ACCOUNTS_LEN, "BuyExactIn")?;
            let ix_accounts = BuyExactInKeys::from(&accounts[..BUY_EXACT_IN_IX_ACCOUNTS_LEN]);
            let args = BuyExactInIxData::from_bytes(&data[..])?;
            Ok(RaydiumLaunchpadInstruction::BuyExactIn(ix_accounts, args))
        }
        BUY_EXACT_OUT_IX_DISCM => {
            check_min_accounts_req(accounts, BUY_EXACT_OUT_IX_ACCOUNTS_LEN, "BuyExactOut")?;
            let ix_accounts = BuyExactOutKeys::from(&accounts[..BUY_EXACT_OUT_IX_ACCOUNTS_LEN]);
            let args = BuyExactOutIxData::from_bytes(&data[..])?;
            Ok(RaydiumLaunchpadInstruction::BuyExactOut(ix_accounts, args))
        }
        CLAIM_PLATFORM_FEE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CLAIM_PLATFORM_FEE_IX_ACCOUNTS_LEN,
                "ClaimPlatformFee",
            )?;
            let ix_accounts =
                ClaimPlatformFeeKeys::from(&accounts[..CLAIM_PLATFORM_FEE_IX_ACCOUNTS_LEN]);
            let args = ClaimPlatformFeeIxData::from_bytes(&data[..])?;
            Ok(RaydiumLaunchpadInstruction::ClaimPlatformFee(
                ix_accounts,
                args,
            ))
        }
        CLAIM_VESTED_TOKEN_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CLAIM_VESTED_TOKEN_IX_ACCOUNTS_LEN,
                "ClaimVestedToken",
            )?;
            let ix_accounts =
                ClaimVestedTokenKeys::from(&accounts[..CLAIM_VESTED_TOKEN_IX_ACCOUNTS_LEN]);
            let args = ClaimVestedTokenIxData::from_bytes(&data[..])?;
            Ok(RaydiumLaunchpadInstruction::ClaimVestedToken(
                ix_accounts,
                args,
            ))
        }
        COLLECT_FEE_IX_DISCM => {
            check_min_accounts_req(accounts, COLLECT_FEE_IX_ACCOUNTS_LEN, "CollectFee")?;
            let ix_accounts = CollectFeeKeys::from(&accounts[..COLLECT_FEE_IX_ACCOUNTS_LEN]);
            let args = CollectFeeIxData::from_bytes(&data[..])?;
            Ok(RaydiumLaunchpadInstruction::CollectFee(ix_accounts, args))
        }
        COLLECT_MIGRATE_FEE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                COLLECT_MIGRATE_FEE_IX_ACCOUNTS_LEN,
                "CollectMigrateFee",
            )?;
            let ix_accounts =
                CollectMigrateFeeKeys::from(&accounts[..COLLECT_MIGRATE_FEE_IX_ACCOUNTS_LEN]);
            let args = CollectMigrateFeeIxData::from_bytes(&data[..])?;
            Ok(RaydiumLaunchpadInstruction::CollectMigrateFee(
                ix_accounts,
                args,
            ))
        }
        CREATE_CONFIG_IX_DISCM => {
            check_min_accounts_req(accounts, CREATE_CONFIG_IX_ACCOUNTS_LEN, "CreateConfig")?;
            let ix_accounts = CreateConfigKeys::from(&accounts[..CREATE_CONFIG_IX_ACCOUNTS_LEN]);
            let args = CreateConfigIxData::from_bytes(&data[..])?;
            Ok(RaydiumLaunchpadInstruction::CreateConfig(ix_accounts, args))
        }
        CREATE_PLATFORM_CONFIG_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CREATE_PLATFORM_CONFIG_IX_ACCOUNTS_LEN,
                "CreatePlatformConfig",
            )?;
            let ix_accounts =
                CreatePlatformConfigKeys::from(&accounts[..CREATE_PLATFORM_CONFIG_IX_ACCOUNTS_LEN]);
            let args = CreatePlatformConfigIxData::from_bytes(&data[..])?;
            Ok(RaydiumLaunchpadInstruction::CreatePlatformConfig(
                ix_accounts,
                args,
            ))
        }
        CREATE_VESTING_ACCOUNT_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CREATE_VESTING_ACCOUNT_IX_ACCOUNTS_LEN,
                "CreateVestingAccount",
            )?;
            let ix_accounts =
                CreateVestingAccountKeys::from(&accounts[..CREATE_VESTING_ACCOUNT_IX_ACCOUNTS_LEN]);
            let args = CreateVestingAccountIxData::from_bytes(&data[..])?;
            Ok(RaydiumLaunchpadInstruction::CreateVestingAccount(
                ix_accounts,
                args,
            ))
        }
        INITIALIZE_IX_DISCM => {
            check_min_accounts_req(accounts, INITIALIZE_IX_ACCOUNTS_LEN, "Initialize")?;
            let ix_accounts = InitializeKeys::from(&accounts[..INITIALIZE_IX_ACCOUNTS_LEN]);
            let args = InitializeIxData::from_bytes(&data[..])?;
            Ok(RaydiumLaunchpadInstruction::Initialize(ix_accounts, args))
        }
        MIGRATE_TO_AMM_IX_DISCM => {
            check_min_accounts_req(accounts, MIGRATE_TO_AMM_IX_ACCOUNTS_LEN, "MigrateToAmm")?;
            let ix_accounts = MigrateToAmmKeys::from(&accounts[..MIGRATE_TO_AMM_IX_ACCOUNTS_LEN]);
            let args = MigrateToAmmIxData::from_bytes(&data[..])?;
            Ok(RaydiumLaunchpadInstruction::MigrateToAmm(ix_accounts, args))
        }
        MIGRATE_TO_CPSWAP_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                MIGRATE_TO_CPSWAP_IX_ACCOUNTS_LEN,
                "MigrateToCpswap",
            )?;
            let ix_accounts =
                MigrateToCpswapKeys::from(&accounts[..MIGRATE_TO_CPSWAP_IX_ACCOUNTS_LEN]);
            let args = MigrateToCpswapIxData::from_bytes(&data[..])?;
            Ok(RaydiumLaunchpadInstruction::MigrateToCpswap(
                ix_accounts,
                args,
            ))
        }
        SELL_EXACT_IN_IX_DISCM => {
            check_min_accounts_req(accounts, SELL_EXACT_IN_IX_ACCOUNTS_LEN, "SellExactIn")?;
            let ix_accounts = SellExactInKeys::from(&accounts[..SELL_EXACT_IN_IX_ACCOUNTS_LEN]);
            let args = SellExactInIxData::from_bytes(&data[..])?;
            Ok(RaydiumLaunchpadInstruction::SellExactIn(ix_accounts, args))
        }
        SELL_EXACT_OUT_IX_DISCM => {
            check_min_accounts_req(accounts, SELL_EXACT_OUT_IX_ACCOUNTS_LEN, "SellExactOut")?;
            let ix_accounts = SellExactOutKeys::from(&accounts[..SELL_EXACT_OUT_IX_ACCOUNTS_LEN]);
            let args = SellExactOutIxData::from_bytes(&data[..])?;
            Ok(RaydiumLaunchpadInstruction::SellExactOut(ix_accounts, args))
        }
        UPDATE_CONFIG_IX_DISCM => {
            check_min_accounts_req(accounts, UPDATE_CONFIG_IX_ACCOUNTS_LEN, "UpdateConfig")?;
            let ix_accounts = UpdateConfigKeys::from(&accounts[..UPDATE_CONFIG_IX_ACCOUNTS_LEN]);
            let args = UpdateConfigIxData::from_bytes(&data[..])?;
            Ok(RaydiumLaunchpadInstruction::UpdateConfig(ix_accounts, args))
        }
        UPDATE_PLATFORM_CONFIG_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                UPDATE_PLATFORM_CONFIG_IX_ACCOUNTS_LEN,
                "UpdatePlatformConfig",
            )?;
            let ix_accounts =
                UpdatePlatformConfigKeys::from(&accounts[..UPDATE_PLATFORM_CONFIG_IX_ACCOUNTS_LEN]);
            let args = UpdatePlatformConfigIxData::from_bytes(&data[..])?;
            Ok(RaydiumLaunchpadInstruction::UpdatePlatformConfig(
                ix_accounts,
                args,
            ))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {:?}", discriminator),
        )),
    }
}
