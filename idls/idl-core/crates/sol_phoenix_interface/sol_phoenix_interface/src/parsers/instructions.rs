//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-16
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

//! Instructions parser for non-Anchor contracts with 1-byte discriminators
use crate::instructions::*;
use solana_pubkey::Pubkey;
/// Program instruction types for non-Anchor contracts
#[derive(Clone, Debug, PartialEq)]
pub enum ProgramInstruction {
    Swap(SwapKeys, SwapIxData),
    SwapWithFreeFunds(SwapWithFreeFundsKeys, SwapWithFreeFundsIxData),
    PlaceLimitOrder(PlaceLimitOrderKeys, PlaceLimitOrderIxData),
    PlaceLimitOrderWithFreeFunds(
        PlaceLimitOrderWithFreeFundsKeys,
        PlaceLimitOrderWithFreeFundsIxData,
    ),
    ReduceOrder(ReduceOrderKeys, ReduceOrderIxData),
    ReduceOrderWithFreeFunds(ReduceOrderWithFreeFundsKeys, ReduceOrderWithFreeFundsIxData),
    CancelAllOrders(CancelAllOrdersKeys, CancelAllOrdersIxData),
    CancelAllOrdersWithFreeFunds(
        CancelAllOrdersWithFreeFundsKeys,
        CancelAllOrdersWithFreeFundsIxData,
    ),
    CancelUpTo(CancelUpToKeys, CancelUpToIxData),
    CancelUpToWithFreeFunds(CancelUpToWithFreeFundsKeys, CancelUpToWithFreeFundsIxData),
    CancelMultipleOrdersById(CancelMultipleOrdersByIdKeys, CancelMultipleOrdersByIdIxData),
    CancelMultipleOrdersByIdWithFreeFunds(
        CancelMultipleOrdersByIdWithFreeFundsKeys,
        CancelMultipleOrdersByIdWithFreeFundsIxData,
    ),
    WithdrawFunds(WithdrawFundsKeys, WithdrawFundsIxData),
    DepositFunds(DepositFundsKeys, DepositFundsIxData),
    RequestSeat(RequestSeatKeys, RequestSeatIxData),
    Log(LogKeys, LogIxData),
    PlaceMultiplePostOnlyOrders(
        PlaceMultiplePostOnlyOrdersKeys,
        PlaceMultiplePostOnlyOrdersIxData,
    ),
    PlaceMultiplePostOnlyOrdersWithFreeFunds(
        PlaceMultiplePostOnlyOrdersWithFreeFundsKeys,
        PlaceMultiplePostOnlyOrdersWithFreeFundsIxData,
    ),
    InitializeMarket(InitializeMarketKeys, InitializeMarketIxData),
    ClaimAuthority(ClaimAuthorityKeys, ClaimAuthorityIxData),
    NameSuccessor(NameSuccessorKeys, NameSuccessorIxData),
    ChangeMarketStatus(ChangeMarketStatusKeys, ChangeMarketStatusIxData),
    ChangeSeatStatus(ChangeSeatStatusKeys, ChangeSeatStatusIxData),
    RequestSeatAuthorized(RequestSeatAuthorizedKeys, RequestSeatAuthorizedIxData),
    EvictSeat(EvictSeatKeys, EvictSeatIxData),
    ForceCancelOrders(ForceCancelOrdersKeys, ForceCancelOrdersIxData),
    CollectFees(CollectFeesKeys, CollectFeesIxData),
    ChangeFeeRecipient(ChangeFeeRecipientKeys, ChangeFeeRecipientIxData),
}
impl ProgramInstruction {
    /// Manual JSON serialization
    #[cfg(feature = "serde")]
    pub fn to_json(&self) -> String {
        match self {
            Self::Swap(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "Swap",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SwapWithFreeFunds(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "SwapWithFreeFunds",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::PlaceLimitOrder(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "PlaceLimitOrder",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::PlaceLimitOrderWithFreeFunds(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "PlaceLimitOrderWithFreeFunds",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ReduceOrder(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "ReduceOrder",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ReduceOrderWithFreeFunds(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "ReduceOrderWithFreeFunds",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CancelAllOrders(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "CancelAllOrders",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CancelAllOrdersWithFreeFunds(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "CancelAllOrdersWithFreeFunds",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CancelUpTo(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "CancelUpTo",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CancelUpToWithFreeFunds(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "CancelUpToWithFreeFunds",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CancelMultipleOrdersById(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "CancelMultipleOrdersById",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CancelMultipleOrdersByIdWithFreeFunds(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "CancelMultipleOrdersByIdWithFreeFunds",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::WithdrawFunds(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "WithdrawFunds",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::DepositFunds(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "DepositFunds",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::RequestSeat(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "RequestSeat",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Log(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "Log",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::PlaceMultiplePostOnlyOrders(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "PlaceMultiplePostOnlyOrders",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::PlaceMultiplePostOnlyOrdersWithFreeFunds(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "PlaceMultiplePostOnlyOrdersWithFreeFunds",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::InitializeMarket(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "InitializeMarket",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ClaimAuthority(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "ClaimAuthority",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::NameSuccessor(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "NameSuccessor",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ChangeMarketStatus(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "ChangeMarketStatus",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ChangeSeatStatus(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "ChangeSeatStatus",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::RequestSeatAuthorized(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "RequestSeatAuthorized",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::EvictSeat(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "EvictSeat",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ForceCancelOrders(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "ForceCancelOrders",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CollectFees(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "CollectFees",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ChangeFeeRecipient(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "ChangeFeeRecipient",
                    keys.to_json(),
                    data.to_json()
                )
            }
        }
    }
}
/// Parse instruction data using 1-byte discriminator for non-Anchor contracts
pub fn parse_instruction(
    data: &[u8],
    accounts: &[Pubkey],
) -> Result<ProgramInstruction, std::io::Error> {
    if data.is_empty() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Empty instruction data",
        ));
    }
    match data[0] {
        SWAP_IX_DISCM => {
            if accounts.len() < SWAP_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!("Insufficient accounts for instruction {}", stringify!(Swap)),
                ));
            }
            let keys = SwapKeys::from(&accounts[..SWAP_IX_ACCOUNTS_LEN]);
            let args = SwapIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::Swap(keys, args))
        }
        SWAP_WITH_FREE_FUNDS_IX_DISCM => {
            if accounts.len() < SWAP_WITH_FREE_FUNDS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(SwapWithFreeFunds)
                    ),
                ));
            }
            let keys =
                SwapWithFreeFundsKeys::from(&accounts[..SWAP_WITH_FREE_FUNDS_IX_ACCOUNTS_LEN]);
            let args = SwapWithFreeFundsIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::SwapWithFreeFunds(keys, args))
        }
        PLACE_LIMIT_ORDER_IX_DISCM => {
            if accounts.len() < PLACE_LIMIT_ORDER_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(PlaceLimitOrder)
                    ),
                ));
            }
            let keys = PlaceLimitOrderKeys::from(&accounts[..PLACE_LIMIT_ORDER_IX_ACCOUNTS_LEN]);
            let args = PlaceLimitOrderIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::PlaceLimitOrder(keys, args))
        }
        PLACE_LIMIT_ORDER_WITH_FREE_FUNDS_IX_DISCM => {
            if accounts.len() < PLACE_LIMIT_ORDER_WITH_FREE_FUNDS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(PlaceLimitOrderWithFreeFunds)
                    ),
                ));
            }
            let keys = PlaceLimitOrderWithFreeFundsKeys::from(
                &accounts[..PLACE_LIMIT_ORDER_WITH_FREE_FUNDS_IX_ACCOUNTS_LEN],
            );
            let args = PlaceLimitOrderWithFreeFundsIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::PlaceLimitOrderWithFreeFunds(keys, args))
        }
        REDUCE_ORDER_IX_DISCM => {
            if accounts.len() < REDUCE_ORDER_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(ReduceOrder)
                    ),
                ));
            }
            let keys = ReduceOrderKeys::from(&accounts[..REDUCE_ORDER_IX_ACCOUNTS_LEN]);
            let args = ReduceOrderIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::ReduceOrder(keys, args))
        }
        REDUCE_ORDER_WITH_FREE_FUNDS_IX_DISCM => {
            if accounts.len() < REDUCE_ORDER_WITH_FREE_FUNDS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(ReduceOrderWithFreeFunds)
                    ),
                ));
            }
            let keys = ReduceOrderWithFreeFundsKeys::from(
                &accounts[..REDUCE_ORDER_WITH_FREE_FUNDS_IX_ACCOUNTS_LEN],
            );
            let args = ReduceOrderWithFreeFundsIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::ReduceOrderWithFreeFunds(keys, args))
        }
        CANCEL_ALL_ORDERS_IX_DISCM => {
            if accounts.len() < CANCEL_ALL_ORDERS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(CancelAllOrders)
                    ),
                ));
            }
            let keys = CancelAllOrdersKeys::from(&accounts[..CANCEL_ALL_ORDERS_IX_ACCOUNTS_LEN]);
            let args = CancelAllOrdersIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::CancelAllOrders(keys, args))
        }
        CANCEL_ALL_ORDERS_WITH_FREE_FUNDS_IX_DISCM => {
            if accounts.len() < CANCEL_ALL_ORDERS_WITH_FREE_FUNDS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(CancelAllOrdersWithFreeFunds)
                    ),
                ));
            }
            let keys = CancelAllOrdersWithFreeFundsKeys::from(
                &accounts[..CANCEL_ALL_ORDERS_WITH_FREE_FUNDS_IX_ACCOUNTS_LEN],
            );
            let args = CancelAllOrdersWithFreeFundsIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::CancelAllOrdersWithFreeFunds(keys, args))
        }
        CANCEL_UP_TO_IX_DISCM => {
            if accounts.len() < CANCEL_UP_TO_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(CancelUpTo)
                    ),
                ));
            }
            let keys = CancelUpToKeys::from(&accounts[..CANCEL_UP_TO_IX_ACCOUNTS_LEN]);
            let args = CancelUpToIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::CancelUpTo(keys, args))
        }
        CANCEL_UP_TO_WITH_FREE_FUNDS_IX_DISCM => {
            if accounts.len() < CANCEL_UP_TO_WITH_FREE_FUNDS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(CancelUpToWithFreeFunds)
                    ),
                ));
            }
            let keys = CancelUpToWithFreeFundsKeys::from(
                &accounts[..CANCEL_UP_TO_WITH_FREE_FUNDS_IX_ACCOUNTS_LEN],
            );
            let args = CancelUpToWithFreeFundsIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::CancelUpToWithFreeFunds(keys, args))
        }
        CANCEL_MULTIPLE_ORDERS_BY_ID_IX_DISCM => {
            if accounts.len() < CANCEL_MULTIPLE_ORDERS_BY_ID_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(CancelMultipleOrdersById)
                    ),
                ));
            }
            let keys = CancelMultipleOrdersByIdKeys::from(
                &accounts[..CANCEL_MULTIPLE_ORDERS_BY_ID_IX_ACCOUNTS_LEN],
            );
            let args = CancelMultipleOrdersByIdIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::CancelMultipleOrdersById(keys, args))
        }
        CANCEL_MULTIPLE_ORDERS_BY_ID_WITH_FREE_FUNDS_IX_DISCM => {
            if accounts.len() < CANCEL_MULTIPLE_ORDERS_BY_ID_WITH_FREE_FUNDS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(CancelMultipleOrdersByIdWithFreeFunds)
                    ),
                ));
            }
            let keys = CancelMultipleOrdersByIdWithFreeFundsKeys::from(
                &accounts[..CANCEL_MULTIPLE_ORDERS_BY_ID_WITH_FREE_FUNDS_IX_ACCOUNTS_LEN],
            );
            let args = CancelMultipleOrdersByIdWithFreeFundsIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::CancelMultipleOrdersByIdWithFreeFunds(
                keys, args,
            ))
        }
        WITHDRAW_FUNDS_IX_DISCM => {
            if accounts.len() < WITHDRAW_FUNDS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(WithdrawFunds)
                    ),
                ));
            }
            let keys = WithdrawFundsKeys::from(&accounts[..WITHDRAW_FUNDS_IX_ACCOUNTS_LEN]);
            let args = WithdrawFundsIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::WithdrawFunds(keys, args))
        }
        DEPOSIT_FUNDS_IX_DISCM => {
            if accounts.len() < DEPOSIT_FUNDS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(DepositFunds)
                    ),
                ));
            }
            let keys = DepositFundsKeys::from(&accounts[..DEPOSIT_FUNDS_IX_ACCOUNTS_LEN]);
            let args = DepositFundsIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::DepositFunds(keys, args))
        }
        REQUEST_SEAT_IX_DISCM => {
            if accounts.len() < REQUEST_SEAT_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(RequestSeat)
                    ),
                ));
            }
            let keys = RequestSeatKeys::from(&accounts[..REQUEST_SEAT_IX_ACCOUNTS_LEN]);
            let args = RequestSeatIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::RequestSeat(keys, args))
        }
        LOG_IX_DISCM => {
            if accounts.len() < LOG_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!("Insufficient accounts for instruction {}", stringify!(Log)),
                ));
            }
            let keys = LogKeys::from(&accounts[..LOG_IX_ACCOUNTS_LEN]);
            let args = LogIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::Log(keys, args))
        }
        PLACE_MULTIPLE_POST_ONLY_ORDERS_IX_DISCM => {
            if accounts.len() < PLACE_MULTIPLE_POST_ONLY_ORDERS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(PlaceMultiplePostOnlyOrders)
                    ),
                ));
            }
            let keys = PlaceMultiplePostOnlyOrdersKeys::from(
                &accounts[..PLACE_MULTIPLE_POST_ONLY_ORDERS_IX_ACCOUNTS_LEN],
            );
            let args = PlaceMultiplePostOnlyOrdersIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::PlaceMultiplePostOnlyOrders(keys, args))
        }
        PLACE_MULTIPLE_POST_ONLY_ORDERS_WITH_FREE_FUNDS_IX_DISCM => {
            if accounts.len() < PLACE_MULTIPLE_POST_ONLY_ORDERS_WITH_FREE_FUNDS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(PlaceMultiplePostOnlyOrdersWithFreeFunds)
                    ),
                ));
            }
            let keys = PlaceMultiplePostOnlyOrdersWithFreeFundsKeys::from(
                &accounts[..PLACE_MULTIPLE_POST_ONLY_ORDERS_WITH_FREE_FUNDS_IX_ACCOUNTS_LEN],
            );
            let args = PlaceMultiplePostOnlyOrdersWithFreeFundsIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::PlaceMultiplePostOnlyOrdersWithFreeFunds(keys, args))
        }
        INITIALIZE_MARKET_IX_DISCM => {
            if accounts.len() < INITIALIZE_MARKET_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(InitializeMarket)
                    ),
                ));
            }
            let keys = InitializeMarketKeys::from(&accounts[..INITIALIZE_MARKET_IX_ACCOUNTS_LEN]);
            let args = InitializeMarketIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::InitializeMarket(keys, args))
        }
        CLAIM_AUTHORITY_IX_DISCM => {
            if accounts.len() < CLAIM_AUTHORITY_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(ClaimAuthority)
                    ),
                ));
            }
            let keys = ClaimAuthorityKeys::from(&accounts[..CLAIM_AUTHORITY_IX_ACCOUNTS_LEN]);
            let args = ClaimAuthorityIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::ClaimAuthority(keys, args))
        }
        NAME_SUCCESSOR_IX_DISCM => {
            if accounts.len() < NAME_SUCCESSOR_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(NameSuccessor)
                    ),
                ));
            }
            let keys = NameSuccessorKeys::from(&accounts[..NAME_SUCCESSOR_IX_ACCOUNTS_LEN]);
            let args = NameSuccessorIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::NameSuccessor(keys, args))
        }
        CHANGE_MARKET_STATUS_IX_DISCM => {
            if accounts.len() < CHANGE_MARKET_STATUS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(ChangeMarketStatus)
                    ),
                ));
            }
            let keys =
                ChangeMarketStatusKeys::from(&accounts[..CHANGE_MARKET_STATUS_IX_ACCOUNTS_LEN]);
            let args = ChangeMarketStatusIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::ChangeMarketStatus(keys, args))
        }
        CHANGE_SEAT_STATUS_IX_DISCM => {
            if accounts.len() < CHANGE_SEAT_STATUS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(ChangeSeatStatus)
                    ),
                ));
            }
            let keys = ChangeSeatStatusKeys::from(&accounts[..CHANGE_SEAT_STATUS_IX_ACCOUNTS_LEN]);
            let args = ChangeSeatStatusIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::ChangeSeatStatus(keys, args))
        }
        REQUEST_SEAT_AUTHORIZED_IX_DISCM => {
            if accounts.len() < REQUEST_SEAT_AUTHORIZED_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(RequestSeatAuthorized)
                    ),
                ));
            }
            let keys = RequestSeatAuthorizedKeys::from(
                &accounts[..REQUEST_SEAT_AUTHORIZED_IX_ACCOUNTS_LEN],
            );
            let args = RequestSeatAuthorizedIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::RequestSeatAuthorized(keys, args))
        }
        EVICT_SEAT_IX_DISCM => {
            if accounts.len() < EVICT_SEAT_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(EvictSeat)
                    ),
                ));
            }
            let keys = EvictSeatKeys::from(&accounts[..EVICT_SEAT_IX_ACCOUNTS_LEN]);
            let args = EvictSeatIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::EvictSeat(keys, args))
        }
        FORCE_CANCEL_ORDERS_IX_DISCM => {
            if accounts.len() < FORCE_CANCEL_ORDERS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(ForceCancelOrders)
                    ),
                ));
            }
            let keys =
                ForceCancelOrdersKeys::from(&accounts[..FORCE_CANCEL_ORDERS_IX_ACCOUNTS_LEN]);
            let args = ForceCancelOrdersIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::ForceCancelOrders(keys, args))
        }
        COLLECT_FEES_IX_DISCM => {
            if accounts.len() < COLLECT_FEES_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(CollectFees)
                    ),
                ));
            }
            let keys = CollectFeesKeys::from(&accounts[..COLLECT_FEES_IX_ACCOUNTS_LEN]);
            let args = CollectFeesIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::CollectFees(keys, args))
        }
        CHANGE_FEE_RECIPIENT_IX_DISCM => {
            if accounts.len() < CHANGE_FEE_RECIPIENT_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(ChangeFeeRecipient)
                    ),
                ));
            }
            let keys =
                ChangeFeeRecipientKeys::from(&accounts[..CHANGE_FEE_RECIPIENT_IX_ACCOUNTS_LEN]);
            let args = ChangeFeeRecipientIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::ChangeFeeRecipient(keys, args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {}", data[0]),
        )),
    }
}
