//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-16
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

//! Instructions parser for Anchor contracts with 8-byte discriminators
use crate::instructions::*;
#[allow(unused_imports)]
use solana_pubkey::Pubkey;
/// Program instruction types for Anchor contract
#[derive(Clone, Debug, PartialEq)]
pub enum MeteoraDbcInstruction {
    ClaimCreatorTradingFee(ClaimCreatorTradingFeeKeys, ClaimCreatorTradingFeeIxData),
    ClaimProtocolFee(ClaimProtocolFeeKeys, ClaimProtocolFeeIxData),
    ClaimTradingFee(ClaimTradingFeeKeys, ClaimTradingFeeIxData),
    CloseClaimFeeOperator(CloseClaimFeeOperatorKeys, CloseClaimFeeOperatorIxData),
    ///ADMIN FUNCTIONS ///
    CreateClaimFeeOperator(CreateClaimFeeOperatorKeys, CreateClaimFeeOperatorIxData),
    CreateConfig(CreateConfigKeys, CreateConfigIxData),
    ///PERMISSIONLESS FUNCTIONS ///
    ///create locker
    CreateLocker(CreateLockerKeys, CreateLockerIxData),
    ///PARTNER FUNCTIONS ////
    CreatePartnerMetadata(CreatePartnerMetadataKeys, CreatePartnerMetadataIxData),
    CreateVirtualPoolMetadata(
        CreateVirtualPoolMetadataKeys,
        CreateVirtualPoolMetadataIxData,
    ),
    CreatorWithdrawSurplus(CreatorWithdrawSurplusKeys, CreatorWithdrawSurplusIxData),
    ///POOL CREATOR FUNCTIONS ////
    InitializeVirtualPoolWithSplToken(
        InitializeVirtualPoolWithSplTokenKeys,
        InitializeVirtualPoolWithSplTokenIxData,
    ),
    InitializeVirtualPoolWithToken2022(
        InitializeVirtualPoolWithToken2022Keys,
        InitializeVirtualPoolWithToken2022IxData,
    ),
    MigrateMeteoraDamm(MigrateMeteoraDammKeys, MigrateMeteoraDammIxData),
    MigrateMeteoraDammClaimLpToken(
        MigrateMeteoraDammClaimLpTokenKeys,
        MigrateMeteoraDammClaimLpTokenIxData,
    ),
    MigrateMeteoraDammLockLpToken(
        MigrateMeteoraDammLockLpTokenKeys,
        MigrateMeteoraDammLockLpTokenIxData,
    ),
    MigrationDammV2(MigrationDammV2Keys, MigrationDammV2IxData),
    MigrationDammV2CreateMetadata(
        MigrationDammV2CreateMetadataKeys,
        MigrationDammV2CreateMetadataIxData,
    ),
    ///migrate damm v1
    MigrationMeteoraDammCreateMetadata(
        MigrationMeteoraDammCreateMetadataKeys,
        MigrationMeteoraDammCreateMetadataIxData,
    ),
    PartnerWithdrawSurplus(PartnerWithdrawSurplusKeys, PartnerWithdrawSurplusIxData),
    ProtocolWithdrawSurplus(ProtocolWithdrawSurplusKeys, ProtocolWithdrawSurplusIxData),
    ///TRADING BOTS FUNCTIONS ////
    Swap(SwapKeys, SwapIxData),
    TransferPoolCreator(TransferPoolCreatorKeys, TransferPoolCreatorIxData),
    WithdrawLeftover(WithdrawLeftoverKeys, WithdrawLeftoverIxData),
    ///BOTH partner and creator FUNCTIONS ///
    WithdrawMigrationFee(WithdrawMigrationFeeKeys, WithdrawMigrationFeeIxData),
}
impl MeteoraDbcInstruction {
    /// Manual JSON serialization
    #[cfg(feature = "serde")]
    pub fn to_json(&self) -> String {
        match self {
            Self::ClaimCreatorTradingFee(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "claim_creator_trading_fee",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ClaimProtocolFee(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "claim_protocol_fee",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ClaimTradingFee(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "claim_trading_fee",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CloseClaimFeeOperator(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "close_claim_fee_operator",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CreateClaimFeeOperator(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "create_claim_fee_operator",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CreateConfig(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "create_config",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CreateLocker(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "create_locker",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CreatePartnerMetadata(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "create_partner_metadata",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CreateVirtualPoolMetadata(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "create_virtual_pool_metadata",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CreatorWithdrawSurplus(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "creator_withdraw_surplus",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::InitializeVirtualPoolWithSplToken(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initialize_virtual_pool_with_spl_token",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::InitializeVirtualPoolWithToken2022(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initialize_virtual_pool_with_token2022",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MigrateMeteoraDamm(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "migrate_meteora_damm",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MigrateMeteoraDammClaimLpToken(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "migrate_meteora_damm_claim_lp_token",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MigrateMeteoraDammLockLpToken(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "migrate_meteora_damm_lock_lp_token",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MigrationDammV2(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "migration_damm_v2",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MigrationDammV2CreateMetadata(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "migration_damm_v2_create_metadata",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MigrationMeteoraDammCreateMetadata(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "migration_meteora_damm_create_metadata",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::PartnerWithdrawSurplus(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "partner_withdraw_surplus",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ProtocolWithdrawSurplus(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "protocol_withdraw_surplus",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Swap(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "swap",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::TransferPoolCreator(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "transfer_pool_creator",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::WithdrawLeftover(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "withdraw_leftover",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::WithdrawMigrationFee(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "withdraw_migration_fee",
                    keys.to_json(),
                    data.to_json()
                )
            }
        }
    }
}
/// Helper function to check minimum accounts requirement
fn check_min_accounts_req(
    accounts: &[Pubkey],
    required_len: usize,
    instruction_name: &str,
) -> Result<(), std::io::Error> {
    if accounts.len() < required_len {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Insufficient accounts for instruction {}", instruction_name),
        ));
    }
    Ok(())
}
/// Parse instruction data based on 8-byte discriminator (Anchor contracts)
pub fn parse_instruction(
    data: &[u8],
    accounts: &[Pubkey],
) -> Result<MeteoraDbcInstruction, std::io::Error> {
    if data.len() < 8 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data too short for discriminator",
        ));
    }
    let discriminator: [u8; 8] = data[0..8].try_into().map_err(|_| {
        std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Failed to read discriminator",
        )
    })?;
    match discriminator {
        CLAIM_CREATOR_TRADING_FEE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CLAIM_CREATOR_TRADING_FEE_IX_ACCOUNTS_LEN,
                "ClaimCreatorTradingFee",
            )?;
            let ix_accounts = ClaimCreatorTradingFeeKeys::from(
                &accounts[..CLAIM_CREATOR_TRADING_FEE_IX_ACCOUNTS_LEN],
            );
            let args = ClaimCreatorTradingFeeIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::ClaimCreatorTradingFee(
                ix_accounts,
                args,
            ))
        }
        CLAIM_PROTOCOL_FEE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CLAIM_PROTOCOL_FEE_IX_ACCOUNTS_LEN,
                "ClaimProtocolFee",
            )?;
            let ix_accounts =
                ClaimProtocolFeeKeys::from(&accounts[..CLAIM_PROTOCOL_FEE_IX_ACCOUNTS_LEN]);
            let args = ClaimProtocolFeeIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::ClaimProtocolFee(ix_accounts, args))
        }
        CLAIM_TRADING_FEE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CLAIM_TRADING_FEE_IX_ACCOUNTS_LEN,
                "ClaimTradingFee",
            )?;
            let ix_accounts =
                ClaimTradingFeeKeys::from(&accounts[..CLAIM_TRADING_FEE_IX_ACCOUNTS_LEN]);
            let args = ClaimTradingFeeIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::ClaimTradingFee(ix_accounts, args))
        }
        CLOSE_CLAIM_FEE_OPERATOR_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CLOSE_CLAIM_FEE_OPERATOR_IX_ACCOUNTS_LEN,
                "CloseClaimFeeOperator",
            )?;
            let ix_accounts = CloseClaimFeeOperatorKeys::from(
                &accounts[..CLOSE_CLAIM_FEE_OPERATOR_IX_ACCOUNTS_LEN],
            );
            let args = CloseClaimFeeOperatorIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::CloseClaimFeeOperator(
                ix_accounts,
                args,
            ))
        }
        CREATE_CLAIM_FEE_OPERATOR_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CREATE_CLAIM_FEE_OPERATOR_IX_ACCOUNTS_LEN,
                "CreateClaimFeeOperator",
            )?;
            let ix_accounts = CreateClaimFeeOperatorKeys::from(
                &accounts[..CREATE_CLAIM_FEE_OPERATOR_IX_ACCOUNTS_LEN],
            );
            let args = CreateClaimFeeOperatorIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::CreateClaimFeeOperator(
                ix_accounts,
                args,
            ))
        }
        CREATE_CONFIG_IX_DISCM => {
            check_min_accounts_req(accounts, CREATE_CONFIG_IX_ACCOUNTS_LEN, "CreateConfig")?;
            let ix_accounts = CreateConfigKeys::from(&accounts[..CREATE_CONFIG_IX_ACCOUNTS_LEN]);
            let args = CreateConfigIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::CreateConfig(ix_accounts, args))
        }
        CREATE_LOCKER_IX_DISCM => {
            check_min_accounts_req(accounts, CREATE_LOCKER_IX_ACCOUNTS_LEN, "CreateLocker")?;
            let ix_accounts = CreateLockerKeys::from(&accounts[..CREATE_LOCKER_IX_ACCOUNTS_LEN]);
            let args = CreateLockerIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::CreateLocker(ix_accounts, args))
        }
        CREATE_PARTNER_METADATA_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CREATE_PARTNER_METADATA_IX_ACCOUNTS_LEN,
                "CreatePartnerMetadata",
            )?;
            let ix_accounts = CreatePartnerMetadataKeys::from(
                &accounts[..CREATE_PARTNER_METADATA_IX_ACCOUNTS_LEN],
            );
            let args = CreatePartnerMetadataIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::CreatePartnerMetadata(
                ix_accounts,
                args,
            ))
        }
        CREATE_VIRTUAL_POOL_METADATA_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CREATE_VIRTUAL_POOL_METADATA_IX_ACCOUNTS_LEN,
                "CreateVirtualPoolMetadata",
            )?;
            let ix_accounts = CreateVirtualPoolMetadataKeys::from(
                &accounts[..CREATE_VIRTUAL_POOL_METADATA_IX_ACCOUNTS_LEN],
            );
            let args = CreateVirtualPoolMetadataIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::CreateVirtualPoolMetadata(
                ix_accounts,
                args,
            ))
        }
        CREATOR_WITHDRAW_SURPLUS_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CREATOR_WITHDRAW_SURPLUS_IX_ACCOUNTS_LEN,
                "CreatorWithdrawSurplus",
            )?;
            let ix_accounts = CreatorWithdrawSurplusKeys::from(
                &accounts[..CREATOR_WITHDRAW_SURPLUS_IX_ACCOUNTS_LEN],
            );
            let args = CreatorWithdrawSurplusIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::CreatorWithdrawSurplus(
                ix_accounts,
                args,
            ))
        }
        INITIALIZE_VIRTUAL_POOL_WITH_SPL_TOKEN_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                INITIALIZE_VIRTUAL_POOL_WITH_SPL_TOKEN_IX_ACCOUNTS_LEN,
                "InitializeVirtualPoolWithSplToken",
            )?;
            let ix_accounts = InitializeVirtualPoolWithSplTokenKeys::from(
                &accounts[..INITIALIZE_VIRTUAL_POOL_WITH_SPL_TOKEN_IX_ACCOUNTS_LEN],
            );
            let args = InitializeVirtualPoolWithSplTokenIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::InitializeVirtualPoolWithSplToken(
                ix_accounts,
                args,
            ))
        }
        INITIALIZE_VIRTUAL_POOL_WITH_TOKEN_2022_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                INITIALIZE_VIRTUAL_POOL_WITH_TOKEN_2022_IX_ACCOUNTS_LEN,
                "InitializeVirtualPoolWithToken2022",
            )?;
            let ix_accounts = InitializeVirtualPoolWithToken2022Keys::from(
                &accounts[..INITIALIZE_VIRTUAL_POOL_WITH_TOKEN_2022_IX_ACCOUNTS_LEN],
            );
            let args = InitializeVirtualPoolWithToken2022IxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::InitializeVirtualPoolWithToken2022(
                ix_accounts,
                args,
            ))
        }
        MIGRATE_METEORA_DAMM_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                MIGRATE_METEORA_DAMM_IX_ACCOUNTS_LEN,
                "MigrateMeteoraDamm",
            )?;
            let ix_accounts =
                MigrateMeteoraDammKeys::from(&accounts[..MIGRATE_METEORA_DAMM_IX_ACCOUNTS_LEN]);
            let args = MigrateMeteoraDammIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::MigrateMeteoraDamm(ix_accounts, args))
        }
        MIGRATE_METEORA_DAMM_CLAIM_LP_TOKEN_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                MIGRATE_METEORA_DAMM_CLAIM_LP_TOKEN_IX_ACCOUNTS_LEN,
                "MigrateMeteoraDammClaimLpToken",
            )?;
            let ix_accounts = MigrateMeteoraDammClaimLpTokenKeys::from(
                &accounts[..MIGRATE_METEORA_DAMM_CLAIM_LP_TOKEN_IX_ACCOUNTS_LEN],
            );
            let args = MigrateMeteoraDammClaimLpTokenIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::MigrateMeteoraDammClaimLpToken(
                ix_accounts,
                args,
            ))
        }
        MIGRATE_METEORA_DAMM_LOCK_LP_TOKEN_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                MIGRATE_METEORA_DAMM_LOCK_LP_TOKEN_IX_ACCOUNTS_LEN,
                "MigrateMeteoraDammLockLpToken",
            )?;
            let ix_accounts = MigrateMeteoraDammLockLpTokenKeys::from(
                &accounts[..MIGRATE_METEORA_DAMM_LOCK_LP_TOKEN_IX_ACCOUNTS_LEN],
            );
            let args = MigrateMeteoraDammLockLpTokenIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::MigrateMeteoraDammLockLpToken(
                ix_accounts,
                args,
            ))
        }
        MIGRATION_DAMM_V_2_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                MIGRATION_DAMM_V_2_IX_ACCOUNTS_LEN,
                "MigrationDammV2",
            )?;
            let ix_accounts =
                MigrationDammV2Keys::from(&accounts[..MIGRATION_DAMM_V_2_IX_ACCOUNTS_LEN]);
            let args = MigrationDammV2IxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::MigrationDammV2(ix_accounts, args))
        }
        MIGRATION_DAMM_V_2_CREATE_METADATA_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                MIGRATION_DAMM_V_2_CREATE_METADATA_IX_ACCOUNTS_LEN,
                "MigrationDammV2CreateMetadata",
            )?;
            let ix_accounts = MigrationDammV2CreateMetadataKeys::from(
                &accounts[..MIGRATION_DAMM_V_2_CREATE_METADATA_IX_ACCOUNTS_LEN],
            );
            let args = MigrationDammV2CreateMetadataIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::MigrationDammV2CreateMetadata(
                ix_accounts,
                args,
            ))
        }
        MIGRATION_METEORA_DAMM_CREATE_METADATA_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                MIGRATION_METEORA_DAMM_CREATE_METADATA_IX_ACCOUNTS_LEN,
                "MigrationMeteoraDammCreateMetadata",
            )?;
            let ix_accounts = MigrationMeteoraDammCreateMetadataKeys::from(
                &accounts[..MIGRATION_METEORA_DAMM_CREATE_METADATA_IX_ACCOUNTS_LEN],
            );
            let args = MigrationMeteoraDammCreateMetadataIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::MigrationMeteoraDammCreateMetadata(
                ix_accounts,
                args,
            ))
        }
        PARTNER_WITHDRAW_SURPLUS_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                PARTNER_WITHDRAW_SURPLUS_IX_ACCOUNTS_LEN,
                "PartnerWithdrawSurplus",
            )?;
            let ix_accounts = PartnerWithdrawSurplusKeys::from(
                &accounts[..PARTNER_WITHDRAW_SURPLUS_IX_ACCOUNTS_LEN],
            );
            let args = PartnerWithdrawSurplusIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::PartnerWithdrawSurplus(
                ix_accounts,
                args,
            ))
        }
        PROTOCOL_WITHDRAW_SURPLUS_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                PROTOCOL_WITHDRAW_SURPLUS_IX_ACCOUNTS_LEN,
                "ProtocolWithdrawSurplus",
            )?;
            let ix_accounts = ProtocolWithdrawSurplusKeys::from(
                &accounts[..PROTOCOL_WITHDRAW_SURPLUS_IX_ACCOUNTS_LEN],
            );
            let args = ProtocolWithdrawSurplusIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::ProtocolWithdrawSurplus(
                ix_accounts,
                args,
            ))
        }
        SWAP_IX_DISCM => {
            check_min_accounts_req(accounts, SWAP_IX_ACCOUNTS_LEN, "Swap")?;
            let ix_accounts = SwapKeys::from(&accounts[..SWAP_IX_ACCOUNTS_LEN]);
            let args = SwapIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::Swap(ix_accounts, args))
        }
        TRANSFER_POOL_CREATOR_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                TRANSFER_POOL_CREATOR_IX_ACCOUNTS_LEN,
                "TransferPoolCreator",
            )?;
            let ix_accounts =
                TransferPoolCreatorKeys::from(&accounts[..TRANSFER_POOL_CREATOR_IX_ACCOUNTS_LEN]);
            let args = TransferPoolCreatorIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::TransferPoolCreator(
                ix_accounts,
                args,
            ))
        }
        WITHDRAW_LEFTOVER_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                WITHDRAW_LEFTOVER_IX_ACCOUNTS_LEN,
                "WithdrawLeftover",
            )?;
            let ix_accounts =
                WithdrawLeftoverKeys::from(&accounts[..WITHDRAW_LEFTOVER_IX_ACCOUNTS_LEN]);
            let args = WithdrawLeftoverIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::WithdrawLeftover(ix_accounts, args))
        }
        WITHDRAW_MIGRATION_FEE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                WITHDRAW_MIGRATION_FEE_IX_ACCOUNTS_LEN,
                "WithdrawMigrationFee",
            )?;
            let ix_accounts =
                WithdrawMigrationFeeKeys::from(&accounts[..WITHDRAW_MIGRATION_FEE_IX_ACCOUNTS_LEN]);
            let args = WithdrawMigrationFeeIxData::from_bytes(&data[..])?;
            Ok(MeteoraDbcInstruction::WithdrawMigrationFee(
                ix_accounts,
                args,
            ))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {:?}", discriminator),
        )),
    }
}
