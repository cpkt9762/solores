//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-15
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

//! Instructions parser for non-Anchor contracts with 1-byte discriminators
use crate::instructions::*;
use solana_pubkey::Pubkey;
/// Program instruction types for non-Anchor contracts
#[derive(Clone, Debug, PartialEq)]
pub enum ProgramInstruction {
    Initialize(InitializeKeys, InitializeIxData),
    Initialize2(Initialize2Keys, Initialize2IxData),
    MonitorStep(MonitorStepKeys, MonitorStepIxData),
    Deposit(DepositKeys, DepositIxData),
    Withdraw(WithdrawKeys, WithdrawIxData),
    MigrateToOpenBook(MigrateToOpenBookKeys, MigrateToOpenBookIxData),
    SetParams(SetParamsKeys, SetParamsIxData),
    WithdrawPnl(WithdrawPnlKeys, WithdrawPnlIxData),
    WithdrawSrm(WithdrawSrmKeys, WithdrawSrmIxData),
    SwapBaseIn(SwapBaseInKeys, SwapBaseInIxData),
    PreInitialize(PreInitializeKeys, PreInitializeIxData),
    SwapBaseOut(SwapBaseOutKeys, SwapBaseOutIxData),
    SimulateInfo(SimulateInfoKeys, SimulateInfoIxData),
    AdminCancelOrders(AdminCancelOrdersKeys, AdminCancelOrdersIxData),
    CreateConfigAccount(CreateConfigAccountKeys, CreateConfigAccountIxData),
    UpdateConfigAccount(UpdateConfigAccountKeys, UpdateConfigAccountIxData),
}
impl ProgramInstruction {
    /// Manual JSON serialization
    #[cfg(feature = "serde")]
    pub fn to_json(&self) -> String {
        match self {
            Self::Initialize(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initialize",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Initialize2(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initialize2",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MonitorStep(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "monitorStep",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Deposit(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "deposit",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Withdraw(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "withdraw",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::MigrateToOpenBook(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "migrateToOpenBook",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SetParams(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "setParams",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::WithdrawPnl(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "withdrawPnl",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::WithdrawSrm(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "withdrawSrm",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SwapBaseIn(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "swapBaseIn",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::PreInitialize(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "preInitialize",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SwapBaseOut(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "swapBaseOut",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SimulateInfo(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "simulateInfo",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::AdminCancelOrders(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "adminCancelOrders",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CreateConfigAccount(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "createConfigAccount",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::UpdateConfigAccount(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "updateConfigAccount",
                    keys.to_json(),
                    data.to_json()
                )
            }
        }
    }
}
/// Parse instruction data using 1-byte discriminator for non-Anchor contracts
pub fn parse_instruction(
    data: &[u8],
    accounts: &[Pubkey],
) -> Result<ProgramInstruction, std::io::Error> {
    if data.is_empty() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Empty instruction data",
        ));
    }
    match data[0] {
        INITIALIZE_IX_DISCM => {
            if accounts.len() < INITIALIZE_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(Initialize)
                    ),
                ));
            }
            let keys = InitializeKeys::from(&accounts[..INITIALIZE_IX_ACCOUNTS_LEN]);
            let args = InitializeIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::Initialize(keys, args))
        }
        INITIALIZE2_IX_DISCM => {
            if accounts.len() < INITIALIZE2_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(Initialize2)
                    ),
                ));
            }
            let keys = Initialize2Keys::from(&accounts[..INITIALIZE2_IX_ACCOUNTS_LEN]);
            let args = Initialize2IxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::Initialize2(keys, args))
        }
        MONITOR_STEP_IX_DISCM => {
            if accounts.len() < MONITOR_STEP_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(MonitorStep)
                    ),
                ));
            }
            let keys = MonitorStepKeys::from(&accounts[..MONITOR_STEP_IX_ACCOUNTS_LEN]);
            let args = MonitorStepIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::MonitorStep(keys, args))
        }
        DEPOSIT_IX_DISCM => {
            if accounts.len() < DEPOSIT_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(Deposit)
                    ),
                ));
            }
            let keys = DepositKeys::from(&accounts[..DEPOSIT_IX_ACCOUNTS_LEN]);
            let args = DepositIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::Deposit(keys, args))
        }
        WITHDRAW_IX_DISCM => {
            if accounts.len() < WITHDRAW_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(Withdraw)
                    ),
                ));
            }
            let keys = WithdrawKeys::from(&accounts[..WITHDRAW_IX_ACCOUNTS_LEN]);
            let args = WithdrawIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::Withdraw(keys, args))
        }
        MIGRATE_TO_OPEN_BOOK_IX_DISCM => {
            if accounts.len() < MIGRATE_TO_OPEN_BOOK_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(MigrateToOpenBook)
                    ),
                ));
            }
            let keys =
                MigrateToOpenBookKeys::from(&accounts[..MIGRATE_TO_OPEN_BOOK_IX_ACCOUNTS_LEN]);
            let args = MigrateToOpenBookIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::MigrateToOpenBook(keys, args))
        }
        SET_PARAMS_IX_DISCM => {
            if accounts.len() < SET_PARAMS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(SetParams)
                    ),
                ));
            }
            let keys = SetParamsKeys::from(&accounts[..SET_PARAMS_IX_ACCOUNTS_LEN]);
            let args = SetParamsIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::SetParams(keys, args))
        }
        WITHDRAW_PNL_IX_DISCM => {
            if accounts.len() < WITHDRAW_PNL_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(WithdrawPnl)
                    ),
                ));
            }
            let keys = WithdrawPnlKeys::from(&accounts[..WITHDRAW_PNL_IX_ACCOUNTS_LEN]);
            let args = WithdrawPnlIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::WithdrawPnl(keys, args))
        }
        WITHDRAW_SRM_IX_DISCM => {
            if accounts.len() < WITHDRAW_SRM_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(WithdrawSrm)
                    ),
                ));
            }
            let keys = WithdrawSrmKeys::from(&accounts[..WITHDRAW_SRM_IX_ACCOUNTS_LEN]);
            let args = WithdrawSrmIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::WithdrawSrm(keys, args))
        }
        SWAP_BASE_IN_IX_DISCM => {
            if accounts.len() != SWAP_BASE_IN_IX_ACCOUNTS_LEN && accounts.len() != SWAP_BASE_IN_IX_ACCOUNTS_LEN - 1 {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!("Invalid account count for instruction SwapBaseIn: expected 17 or 18, got {}", accounts.len()),
                ));
            }
            let keys = SwapBaseInKeys::from(accounts);
            let args = SwapBaseInIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::SwapBaseIn(keys, args))
        }
        PRE_INITIALIZE_IX_DISCM => {
            if accounts.len() < PRE_INITIALIZE_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(PreInitialize)
                    ),
                ));
            }
            let keys = PreInitializeKeys::from(&accounts[..PRE_INITIALIZE_IX_ACCOUNTS_LEN]);
            let args = PreInitializeIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::PreInitialize(keys, args))
        }
        SWAP_BASE_OUT_IX_DISCM => {
            if accounts.len() != SWAP_BASE_OUT_IX_ACCOUNTS_LEN && accounts.len() != SWAP_BASE_OUT_IX_ACCOUNTS_LEN - 1 {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!("Invalid account count for instruction SwapBaseOut: expected 17 or 18, got {}", accounts.len()),
                ));
            }
            let keys = SwapBaseOutKeys::from(accounts);
            let args = SwapBaseOutIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::SwapBaseOut(keys, args))
        }
        SIMULATE_INFO_IX_DISCM => {
            if accounts.len() < SIMULATE_INFO_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(SimulateInfo)
                    ),
                ));
            }
            let keys = SimulateInfoKeys::from(&accounts[..SIMULATE_INFO_IX_ACCOUNTS_LEN]);
            let args = SimulateInfoIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::SimulateInfo(keys, args))
        }
        ADMIN_CANCEL_ORDERS_IX_DISCM => {
            if accounts.len() < ADMIN_CANCEL_ORDERS_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(AdminCancelOrders)
                    ),
                ));
            }
            let keys =
                AdminCancelOrdersKeys::from(&accounts[..ADMIN_CANCEL_ORDERS_IX_ACCOUNTS_LEN]);
            let args = AdminCancelOrdersIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::AdminCancelOrders(keys, args))
        }
        CREATE_CONFIG_ACCOUNT_IX_DISCM => {
            if accounts.len() < CREATE_CONFIG_ACCOUNT_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(CreateConfigAccount)
                    ),
                ));
            }
            let keys =
                CreateConfigAccountKeys::from(&accounts[..CREATE_CONFIG_ACCOUNT_IX_ACCOUNTS_LEN]);
            let args = CreateConfigAccountIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::CreateConfigAccount(keys, args))
        }
        UPDATE_CONFIG_ACCOUNT_IX_DISCM => {
            if accounts.len() < UPDATE_CONFIG_ACCOUNT_IX_ACCOUNTS_LEN {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::InvalidData,
                    format!(
                        "Insufficient accounts for instruction {}",
                        stringify!(UpdateConfigAccount)
                    ),
                ));
            }
            let keys =
                UpdateConfigAccountKeys::from(&accounts[..UPDATE_CONFIG_ACCOUNT_IX_ACCOUNTS_LEN]);
            let args = UpdateConfigAccountIxData::from_bytes(&data[..])?;
            Ok(ProgramInstruction::UpdateConfigAccount(keys, args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {}", data[0]),
        )),
    }
}
