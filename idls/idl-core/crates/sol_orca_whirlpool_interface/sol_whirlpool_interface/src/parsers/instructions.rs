//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-15
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

//! Instructions parser for Anchor contracts with 8-byte discriminators
use crate::instructions::*;
#[allow(unused_imports)]
use solana_pubkey::Pubkey;
/// Program instruction types for Anchor contract
#[derive(Clone, Debug, PartialEq)]
pub enum WhirlpoolInstruction {
    InitializeConfig(InitializeConfigKeys, InitializeConfigIxData),
    InitializePool(InitializePoolKeys, InitializePoolIxData),
    InitializeTickArray(InitializeTickArrayKeys, InitializeTickArrayIxData),
    InitializeFeeTier(InitializeFeeTierKeys, InitializeFeeTierIxData),
    InitializeReward(InitializeRewardKeys, InitializeRewardIxData),
    SetRewardEmissions(SetRewardEmissionsKeys, SetRewardEmissionsIxData),
    OpenPosition(OpenPositionKeys, OpenPositionIxData),
    OpenPositionWithMetadata(OpenPositionWithMetadataKeys, OpenPositionWithMetadataIxData),
    IncreaseLiquidity(IncreaseLiquidityKeys, IncreaseLiquidityIxData),
    DecreaseLiquidity(DecreaseLiquidityKeys, DecreaseLiquidityIxData),
    UpdateFeesAndRewards(UpdateFeesAndRewardsKeys, UpdateFeesAndRewardsIxData),
    CollectFees(CollectFeesKeys, CollectFeesIxData),
    CollectReward(CollectRewardKeys, CollectRewardIxData),
    CollectProtocolFees(CollectProtocolFeesKeys, CollectProtocolFeesIxData),
    Swap(SwapKeys, SwapIxData),
    ClosePosition(ClosePositionKeys, ClosePositionIxData),
    SetDefaultFeeRate(SetDefaultFeeRateKeys, SetDefaultFeeRateIxData),
    SetDefaultProtocolFeeRate(
        SetDefaultProtocolFeeRateKeys,
        SetDefaultProtocolFeeRateIxData,
    ),
    SetFeeRate(SetFeeRateKeys, SetFeeRateIxData),
    SetProtocolFeeRate(SetProtocolFeeRateKeys, SetProtocolFeeRateIxData),
    SetFeeAuthority(SetFeeAuthorityKeys, SetFeeAuthorityIxData),
    SetCollectProtocolFeesAuthority(
        SetCollectProtocolFeesAuthorityKeys,
        SetCollectProtocolFeesAuthorityIxData,
    ),
    SetRewardAuthority(SetRewardAuthorityKeys, SetRewardAuthorityIxData),
    SetRewardAuthorityBySuperAuthority(
        SetRewardAuthorityBySuperAuthorityKeys,
        SetRewardAuthorityBySuperAuthorityIxData,
    ),
    SetRewardEmissionsSuperAuthority(
        SetRewardEmissionsSuperAuthorityKeys,
        SetRewardEmissionsSuperAuthorityIxData,
    ),
    TwoHopSwap(TwoHopSwapKeys, TwoHopSwapIxData),
    InitializePositionBundle(InitializePositionBundleKeys, InitializePositionBundleIxData),
    InitializePositionBundleWithMetadata(
        InitializePositionBundleWithMetadataKeys,
        InitializePositionBundleWithMetadataIxData,
    ),
    DeletePositionBundle(DeletePositionBundleKeys, DeletePositionBundleIxData),
    OpenBundledPosition(OpenBundledPositionKeys, OpenBundledPositionIxData),
    CloseBundledPosition(CloseBundledPositionKeys, CloseBundledPositionIxData),
    CollectFeesV2(CollectFeesV2Keys, CollectFeesV2IxData),
    CollectProtocolFeesV2(CollectProtocolFeesV2Keys, CollectProtocolFeesV2IxData),
    CollectRewardV2(CollectRewardV2Keys, CollectRewardV2IxData),
    DecreaseLiquidityV2(DecreaseLiquidityV2Keys, DecreaseLiquidityV2IxData),
    IncreaseLiquidityV2(IncreaseLiquidityV2Keys, IncreaseLiquidityV2IxData),
    InitializePoolV2(InitializePoolV2Keys, InitializePoolV2IxData),
    InitializeRewardV2(InitializeRewardV2Keys, InitializeRewardV2IxData),
    SetRewardEmissionsV2(SetRewardEmissionsV2Keys, SetRewardEmissionsV2IxData),
    SwapV2(SwapV2Keys, SwapV2IxData),
    TwoHopSwapV2(TwoHopSwapV2Keys, TwoHopSwapV2IxData),
    InitializeConfigExtension(
        InitializeConfigExtensionKeys,
        InitializeConfigExtensionIxData,
    ),
    SetConfigExtensionAuthority(
        SetConfigExtensionAuthorityKeys,
        SetConfigExtensionAuthorityIxData,
    ),
    SetTokenBadgeAuthority(SetTokenBadgeAuthorityKeys, SetTokenBadgeAuthorityIxData),
    InitializeTokenBadge(InitializeTokenBadgeKeys, InitializeTokenBadgeIxData),
    DeleteTokenBadge(DeleteTokenBadgeKeys, DeleteTokenBadgeIxData),
}
impl WhirlpoolInstruction {
    /// Manual JSON serialization
    #[cfg(feature = "serde")]
    pub fn to_json(&self) -> String {
        match self {
            Self::InitializeConfig(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initializeConfig",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::InitializePool(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initializePool",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::InitializeTickArray(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initializeTickArray",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::InitializeFeeTier(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initializeFeeTier",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::InitializeReward(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initializeReward",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SetRewardEmissions(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "setRewardEmissions",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::OpenPosition(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "openPosition",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::OpenPositionWithMetadata(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "openPositionWithMetadata",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::IncreaseLiquidity(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "increaseLiquidity",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::DecreaseLiquidity(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "decreaseLiquidity",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::UpdateFeesAndRewards(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "updateFeesAndRewards",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CollectFees(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "collectFees",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CollectReward(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "collectReward",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CollectProtocolFees(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "collectProtocolFees",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Swap(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "swap",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ClosePosition(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "closePosition",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SetDefaultFeeRate(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "setDefaultFeeRate",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SetDefaultProtocolFeeRate(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "setDefaultProtocolFeeRate",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SetFeeRate(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "setFeeRate",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SetProtocolFeeRate(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "setProtocolFeeRate",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SetFeeAuthority(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "setFeeAuthority",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SetCollectProtocolFeesAuthority(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "setCollectProtocolFeesAuthority",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SetRewardAuthority(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "setRewardAuthority",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SetRewardAuthorityBySuperAuthority(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "setRewardAuthorityBySuperAuthority",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SetRewardEmissionsSuperAuthority(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "setRewardEmissionsSuperAuthority",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::TwoHopSwap(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "twoHopSwap",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::InitializePositionBundle(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initializePositionBundle",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::InitializePositionBundleWithMetadata(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initializePositionBundleWithMetadata",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::DeletePositionBundle(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "deletePositionBundle",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::OpenBundledPosition(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "openBundledPosition",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CloseBundledPosition(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "closeBundledPosition",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CollectFeesV2(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "collectFeesV2",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CollectProtocolFeesV2(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "collectProtocolFeesV2",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CollectRewardV2(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "collectRewardV2",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::DecreaseLiquidityV2(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "decreaseLiquidityV2",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::IncreaseLiquidityV2(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "increaseLiquidityV2",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::InitializePoolV2(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initializePoolV2",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::InitializeRewardV2(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initializeRewardV2",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SetRewardEmissionsV2(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "setRewardEmissionsV2",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SwapV2(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "swapV2",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::TwoHopSwapV2(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "twoHopSwapV2",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::InitializeConfigExtension(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initializeConfigExtension",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SetConfigExtensionAuthority(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "setConfigExtensionAuthority",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SetTokenBadgeAuthority(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "setTokenBadgeAuthority",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::InitializeTokenBadge(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initializeTokenBadge",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::DeleteTokenBadge(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "deleteTokenBadge",
                    keys.to_json(),
                    data.to_json()
                )
            }
        }
    }
}
/// Helper function to check minimum accounts requirement
fn check_min_accounts_req(
    accounts: &[Pubkey],
    required_len: usize,
    instruction_name: &str,
) -> Result<(), std::io::Error> {
    if accounts.len() < required_len {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Insufficient accounts for instruction {}", instruction_name),
        ));
    }
    Ok(())
}
/// Parse instruction data based on 8-byte discriminator (Anchor contracts)
pub fn parse_instruction(
    data: &[u8],
    accounts: &[Pubkey],
) -> Result<WhirlpoolInstruction, std::io::Error> {
    if data.len() < 8 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data too short for discriminator",
        ));
    }
    let discriminator: [u8; 8] = data[0..8].try_into().map_err(|_| {
        std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Failed to read discriminator",
        )
    })?;
    match discriminator {
        INITIALIZE_CONFIG_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                INITIALIZE_CONFIG_IX_ACCOUNTS_LEN,
                "InitializeConfig",
            )?;
            let ix_accounts =
                InitializeConfigKeys::from(&accounts[..INITIALIZE_CONFIG_IX_ACCOUNTS_LEN]);
            let args = InitializeConfigIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::InitializeConfig(ix_accounts, args))
        }
        INITIALIZE_POOL_IX_DISCM => {
            check_min_accounts_req(accounts, INITIALIZE_POOL_IX_ACCOUNTS_LEN, "InitializePool")?;
            let ix_accounts =
                InitializePoolKeys::from(&accounts[..INITIALIZE_POOL_IX_ACCOUNTS_LEN]);
            let args = InitializePoolIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::InitializePool(ix_accounts, args))
        }
        INITIALIZE_TICK_ARRAY_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                INITIALIZE_TICK_ARRAY_IX_ACCOUNTS_LEN,
                "InitializeTickArray",
            )?;
            let ix_accounts =
                InitializeTickArrayKeys::from(&accounts[..INITIALIZE_TICK_ARRAY_IX_ACCOUNTS_LEN]);
            let args = InitializeTickArrayIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::InitializeTickArray(ix_accounts, args))
        }
        INITIALIZE_FEE_TIER_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                INITIALIZE_FEE_TIER_IX_ACCOUNTS_LEN,
                "InitializeFeeTier",
            )?;
            let ix_accounts =
                InitializeFeeTierKeys::from(&accounts[..INITIALIZE_FEE_TIER_IX_ACCOUNTS_LEN]);
            let args = InitializeFeeTierIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::InitializeFeeTier(ix_accounts, args))
        }
        INITIALIZE_REWARD_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                INITIALIZE_REWARD_IX_ACCOUNTS_LEN,
                "InitializeReward",
            )?;
            let ix_accounts =
                InitializeRewardKeys::from(&accounts[..INITIALIZE_REWARD_IX_ACCOUNTS_LEN]);
            let args = InitializeRewardIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::InitializeReward(ix_accounts, args))
        }
        SET_REWARD_EMISSIONS_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                SET_REWARD_EMISSIONS_IX_ACCOUNTS_LEN,
                "SetRewardEmissions",
            )?;
            let ix_accounts =
                SetRewardEmissionsKeys::from(&accounts[..SET_REWARD_EMISSIONS_IX_ACCOUNTS_LEN]);
            let args = SetRewardEmissionsIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::SetRewardEmissions(ix_accounts, args))
        }
        OPEN_POSITION_IX_DISCM => {
            check_min_accounts_req(accounts, OPEN_POSITION_IX_ACCOUNTS_LEN, "OpenPosition")?;
            let ix_accounts = OpenPositionKeys::from(&accounts[..OPEN_POSITION_IX_ACCOUNTS_LEN]);
            let args = OpenPositionIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::OpenPosition(ix_accounts, args))
        }
        OPEN_POSITION_WITH_METADATA_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                OPEN_POSITION_WITH_METADATA_IX_ACCOUNTS_LEN,
                "OpenPositionWithMetadata",
            )?;
            let ix_accounts = OpenPositionWithMetadataKeys::from(
                &accounts[..OPEN_POSITION_WITH_METADATA_IX_ACCOUNTS_LEN],
            );
            let args = OpenPositionWithMetadataIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::OpenPositionWithMetadata(
                ix_accounts,
                args,
            ))
        }
        INCREASE_LIQUIDITY_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                INCREASE_LIQUIDITY_IX_ACCOUNTS_LEN,
                "IncreaseLiquidity",
            )?;
            let ix_accounts =
                IncreaseLiquidityKeys::from(&accounts[..INCREASE_LIQUIDITY_IX_ACCOUNTS_LEN]);
            let args = IncreaseLiquidityIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::IncreaseLiquidity(ix_accounts, args))
        }
        DECREASE_LIQUIDITY_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                DECREASE_LIQUIDITY_IX_ACCOUNTS_LEN,
                "DecreaseLiquidity",
            )?;
            let ix_accounts =
                DecreaseLiquidityKeys::from(&accounts[..DECREASE_LIQUIDITY_IX_ACCOUNTS_LEN]);
            let args = DecreaseLiquidityIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::DecreaseLiquidity(ix_accounts, args))
        }
        UPDATE_FEES_AND_REWARDS_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                UPDATE_FEES_AND_REWARDS_IX_ACCOUNTS_LEN,
                "UpdateFeesAndRewards",
            )?;
            let ix_accounts = UpdateFeesAndRewardsKeys::from(
                &accounts[..UPDATE_FEES_AND_REWARDS_IX_ACCOUNTS_LEN],
            );
            let args = UpdateFeesAndRewardsIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::UpdateFeesAndRewards(
                ix_accounts,
                args,
            ))
        }
        COLLECT_FEES_IX_DISCM => {
            check_min_accounts_req(accounts, COLLECT_FEES_IX_ACCOUNTS_LEN, "CollectFees")?;
            let ix_accounts = CollectFeesKeys::from(&accounts[..COLLECT_FEES_IX_ACCOUNTS_LEN]);
            let args = CollectFeesIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::CollectFees(ix_accounts, args))
        }
        COLLECT_REWARD_IX_DISCM => {
            check_min_accounts_req(accounts, COLLECT_REWARD_IX_ACCOUNTS_LEN, "CollectReward")?;
            let ix_accounts = CollectRewardKeys::from(&accounts[..COLLECT_REWARD_IX_ACCOUNTS_LEN]);
            let args = CollectRewardIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::CollectReward(ix_accounts, args))
        }
        COLLECT_PROTOCOL_FEES_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                COLLECT_PROTOCOL_FEES_IX_ACCOUNTS_LEN,
                "CollectProtocolFees",
            )?;
            let ix_accounts =
                CollectProtocolFeesKeys::from(&accounts[..COLLECT_PROTOCOL_FEES_IX_ACCOUNTS_LEN]);
            let args = CollectProtocolFeesIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::CollectProtocolFees(ix_accounts, args))
        }
        SWAP_IX_DISCM => {
            check_min_accounts_req(accounts, SWAP_IX_ACCOUNTS_LEN, "Swap")?;
            let ix_accounts = SwapKeys::from(&accounts[..SWAP_IX_ACCOUNTS_LEN]);
            let args = SwapIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::Swap(ix_accounts, args))
        }
        CLOSE_POSITION_IX_DISCM => {
            check_min_accounts_req(accounts, CLOSE_POSITION_IX_ACCOUNTS_LEN, "ClosePosition")?;
            let ix_accounts = ClosePositionKeys::from(&accounts[..CLOSE_POSITION_IX_ACCOUNTS_LEN]);
            let args = ClosePositionIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::ClosePosition(ix_accounts, args))
        }
        SET_DEFAULT_FEE_RATE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                SET_DEFAULT_FEE_RATE_IX_ACCOUNTS_LEN,
                "SetDefaultFeeRate",
            )?;
            let ix_accounts =
                SetDefaultFeeRateKeys::from(&accounts[..SET_DEFAULT_FEE_RATE_IX_ACCOUNTS_LEN]);
            let args = SetDefaultFeeRateIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::SetDefaultFeeRate(ix_accounts, args))
        }
        SET_DEFAULT_PROTOCOL_FEE_RATE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                SET_DEFAULT_PROTOCOL_FEE_RATE_IX_ACCOUNTS_LEN,
                "SetDefaultProtocolFeeRate",
            )?;
            let ix_accounts = SetDefaultProtocolFeeRateKeys::from(
                &accounts[..SET_DEFAULT_PROTOCOL_FEE_RATE_IX_ACCOUNTS_LEN],
            );
            let args = SetDefaultProtocolFeeRateIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::SetDefaultProtocolFeeRate(
                ix_accounts,
                args,
            ))
        }
        SET_FEE_RATE_IX_DISCM => {
            check_min_accounts_req(accounts, SET_FEE_RATE_IX_ACCOUNTS_LEN, "SetFeeRate")?;
            let ix_accounts = SetFeeRateKeys::from(&accounts[..SET_FEE_RATE_IX_ACCOUNTS_LEN]);
            let args = SetFeeRateIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::SetFeeRate(ix_accounts, args))
        }
        SET_PROTOCOL_FEE_RATE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                SET_PROTOCOL_FEE_RATE_IX_ACCOUNTS_LEN,
                "SetProtocolFeeRate",
            )?;
            let ix_accounts =
                SetProtocolFeeRateKeys::from(&accounts[..SET_PROTOCOL_FEE_RATE_IX_ACCOUNTS_LEN]);
            let args = SetProtocolFeeRateIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::SetProtocolFeeRate(ix_accounts, args))
        }
        SET_FEE_AUTHORITY_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                SET_FEE_AUTHORITY_IX_ACCOUNTS_LEN,
                "SetFeeAuthority",
            )?;
            let ix_accounts =
                SetFeeAuthorityKeys::from(&accounts[..SET_FEE_AUTHORITY_IX_ACCOUNTS_LEN]);
            let args = SetFeeAuthorityIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::SetFeeAuthority(ix_accounts, args))
        }
        SET_COLLECT_PROTOCOL_FEES_AUTHORITY_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                SET_COLLECT_PROTOCOL_FEES_AUTHORITY_IX_ACCOUNTS_LEN,
                "SetCollectProtocolFeesAuthority",
            )?;
            let ix_accounts = SetCollectProtocolFeesAuthorityKeys::from(
                &accounts[..SET_COLLECT_PROTOCOL_FEES_AUTHORITY_IX_ACCOUNTS_LEN],
            );
            let args = SetCollectProtocolFeesAuthorityIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::SetCollectProtocolFeesAuthority(
                ix_accounts,
                args,
            ))
        }
        SET_REWARD_AUTHORITY_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                SET_REWARD_AUTHORITY_IX_ACCOUNTS_LEN,
                "SetRewardAuthority",
            )?;
            let ix_accounts =
                SetRewardAuthorityKeys::from(&accounts[..SET_REWARD_AUTHORITY_IX_ACCOUNTS_LEN]);
            let args = SetRewardAuthorityIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::SetRewardAuthority(ix_accounts, args))
        }
        SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_IX_ACCOUNTS_LEN,
                "SetRewardAuthorityBySuperAuthority",
            )?;
            let ix_accounts = SetRewardAuthorityBySuperAuthorityKeys::from(
                &accounts[..SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_IX_ACCOUNTS_LEN],
            );
            let args = SetRewardAuthorityBySuperAuthorityIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::SetRewardAuthorityBySuperAuthority(
                ix_accounts,
                args,
            ))
        }
        SET_REWARD_EMISSIONS_SUPER_AUTHORITY_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                SET_REWARD_EMISSIONS_SUPER_AUTHORITY_IX_ACCOUNTS_LEN,
                "SetRewardEmissionsSuperAuthority",
            )?;
            let ix_accounts = SetRewardEmissionsSuperAuthorityKeys::from(
                &accounts[..SET_REWARD_EMISSIONS_SUPER_AUTHORITY_IX_ACCOUNTS_LEN],
            );
            let args = SetRewardEmissionsSuperAuthorityIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::SetRewardEmissionsSuperAuthority(
                ix_accounts,
                args,
            ))
        }
        TWO_HOP_SWAP_IX_DISCM => {
            check_min_accounts_req(accounts, TWO_HOP_SWAP_IX_ACCOUNTS_LEN, "TwoHopSwap")?;
            let ix_accounts = TwoHopSwapKeys::from(&accounts[..TWO_HOP_SWAP_IX_ACCOUNTS_LEN]);
            let args = TwoHopSwapIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::TwoHopSwap(ix_accounts, args))
        }
        INITIALIZE_POSITION_BUNDLE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                INITIALIZE_POSITION_BUNDLE_IX_ACCOUNTS_LEN,
                "InitializePositionBundle",
            )?;
            let ix_accounts = InitializePositionBundleKeys::from(
                &accounts[..INITIALIZE_POSITION_BUNDLE_IX_ACCOUNTS_LEN],
            );
            let args = InitializePositionBundleIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::InitializePositionBundle(
                ix_accounts,
                args,
            ))
        }
        INITIALIZE_POSITION_BUNDLE_WITH_METADATA_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                INITIALIZE_POSITION_BUNDLE_WITH_METADATA_IX_ACCOUNTS_LEN,
                "InitializePositionBundleWithMetadata",
            )?;
            let ix_accounts = InitializePositionBundleWithMetadataKeys::from(
                &accounts[..INITIALIZE_POSITION_BUNDLE_WITH_METADATA_IX_ACCOUNTS_LEN],
            );
            let args = InitializePositionBundleWithMetadataIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::InitializePositionBundleWithMetadata(
                ix_accounts,
                args,
            ))
        }
        DELETE_POSITION_BUNDLE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                DELETE_POSITION_BUNDLE_IX_ACCOUNTS_LEN,
                "DeletePositionBundle",
            )?;
            let ix_accounts =
                DeletePositionBundleKeys::from(&accounts[..DELETE_POSITION_BUNDLE_IX_ACCOUNTS_LEN]);
            let args = DeletePositionBundleIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::DeletePositionBundle(
                ix_accounts,
                args,
            ))
        }
        OPEN_BUNDLED_POSITION_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                OPEN_BUNDLED_POSITION_IX_ACCOUNTS_LEN,
                "OpenBundledPosition",
            )?;
            let ix_accounts =
                OpenBundledPositionKeys::from(&accounts[..OPEN_BUNDLED_POSITION_IX_ACCOUNTS_LEN]);
            let args = OpenBundledPositionIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::OpenBundledPosition(ix_accounts, args))
        }
        CLOSE_BUNDLED_POSITION_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CLOSE_BUNDLED_POSITION_IX_ACCOUNTS_LEN,
                "CloseBundledPosition",
            )?;
            let ix_accounts =
                CloseBundledPositionKeys::from(&accounts[..CLOSE_BUNDLED_POSITION_IX_ACCOUNTS_LEN]);
            let args = CloseBundledPositionIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::CloseBundledPosition(
                ix_accounts,
                args,
            ))
        }
        COLLECT_FEES_V_2_IX_DISCM => {
            check_min_accounts_req(accounts, COLLECT_FEES_V_2_IX_ACCOUNTS_LEN, "CollectFeesV2")?;
            let ix_accounts =
                CollectFeesV2Keys::from(&accounts[..COLLECT_FEES_V_2_IX_ACCOUNTS_LEN]);
            let args = CollectFeesV2IxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::CollectFeesV2(ix_accounts, args))
        }
        COLLECT_PROTOCOL_FEES_V_2_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                COLLECT_PROTOCOL_FEES_V_2_IX_ACCOUNTS_LEN,
                "CollectProtocolFeesV2",
            )?;
            let ix_accounts = CollectProtocolFeesV2Keys::from(
                &accounts[..COLLECT_PROTOCOL_FEES_V_2_IX_ACCOUNTS_LEN],
            );
            let args = CollectProtocolFeesV2IxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::CollectProtocolFeesV2(
                ix_accounts,
                args,
            ))
        }
        COLLECT_REWARD_V_2_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                COLLECT_REWARD_V_2_IX_ACCOUNTS_LEN,
                "CollectRewardV2",
            )?;
            let ix_accounts =
                CollectRewardV2Keys::from(&accounts[..COLLECT_REWARD_V_2_IX_ACCOUNTS_LEN]);
            let args = CollectRewardV2IxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::CollectRewardV2(ix_accounts, args))
        }
        DECREASE_LIQUIDITY_V_2_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                DECREASE_LIQUIDITY_V_2_IX_ACCOUNTS_LEN,
                "DecreaseLiquidityV2",
            )?;
            let ix_accounts =
                DecreaseLiquidityV2Keys::from(&accounts[..DECREASE_LIQUIDITY_V_2_IX_ACCOUNTS_LEN]);
            let args = DecreaseLiquidityV2IxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::DecreaseLiquidityV2(ix_accounts, args))
        }
        INCREASE_LIQUIDITY_V_2_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                INCREASE_LIQUIDITY_V_2_IX_ACCOUNTS_LEN,
                "IncreaseLiquidityV2",
            )?;
            let ix_accounts =
                IncreaseLiquidityV2Keys::from(&accounts[..INCREASE_LIQUIDITY_V_2_IX_ACCOUNTS_LEN]);
            let args = IncreaseLiquidityV2IxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::IncreaseLiquidityV2(ix_accounts, args))
        }
        INITIALIZE_POOL_V_2_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                INITIALIZE_POOL_V_2_IX_ACCOUNTS_LEN,
                "InitializePoolV2",
            )?;
            let ix_accounts =
                InitializePoolV2Keys::from(&accounts[..INITIALIZE_POOL_V_2_IX_ACCOUNTS_LEN]);
            let args = InitializePoolV2IxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::InitializePoolV2(ix_accounts, args))
        }
        INITIALIZE_REWARD_V_2_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                INITIALIZE_REWARD_V_2_IX_ACCOUNTS_LEN,
                "InitializeRewardV2",
            )?;
            let ix_accounts =
                InitializeRewardV2Keys::from(&accounts[..INITIALIZE_REWARD_V_2_IX_ACCOUNTS_LEN]);
            let args = InitializeRewardV2IxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::InitializeRewardV2(ix_accounts, args))
        }
        SET_REWARD_EMISSIONS_V_2_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                SET_REWARD_EMISSIONS_V_2_IX_ACCOUNTS_LEN,
                "SetRewardEmissionsV2",
            )?;
            let ix_accounts = SetRewardEmissionsV2Keys::from(
                &accounts[..SET_REWARD_EMISSIONS_V_2_IX_ACCOUNTS_LEN],
            );
            let args = SetRewardEmissionsV2IxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::SetRewardEmissionsV2(
                ix_accounts,
                args,
            ))
        }
        SWAP_V_2_IX_DISCM => {
            check_min_accounts_req(accounts, SWAP_V_2_IX_ACCOUNTS_LEN, "SwapV2")?;
            let ix_accounts = SwapV2Keys::from(&accounts[..SWAP_V_2_IX_ACCOUNTS_LEN]);
            let args = SwapV2IxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::SwapV2(ix_accounts, args))
        }
        TWO_HOP_SWAP_V_2_IX_DISCM => {
            check_min_accounts_req(accounts, TWO_HOP_SWAP_V_2_IX_ACCOUNTS_LEN, "TwoHopSwapV2")?;
            let ix_accounts = TwoHopSwapV2Keys::from(&accounts[..TWO_HOP_SWAP_V_2_IX_ACCOUNTS_LEN]);
            let args = TwoHopSwapV2IxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::TwoHopSwapV2(ix_accounts, args))
        }
        INITIALIZE_CONFIG_EXTENSION_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                INITIALIZE_CONFIG_EXTENSION_IX_ACCOUNTS_LEN,
                "InitializeConfigExtension",
            )?;
            let ix_accounts = InitializeConfigExtensionKeys::from(
                &accounts[..INITIALIZE_CONFIG_EXTENSION_IX_ACCOUNTS_LEN],
            );
            let args = InitializeConfigExtensionIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::InitializeConfigExtension(
                ix_accounts,
                args,
            ))
        }
        SET_CONFIG_EXTENSION_AUTHORITY_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                SET_CONFIG_EXTENSION_AUTHORITY_IX_ACCOUNTS_LEN,
                "SetConfigExtensionAuthority",
            )?;
            let ix_accounts = SetConfigExtensionAuthorityKeys::from(
                &accounts[..SET_CONFIG_EXTENSION_AUTHORITY_IX_ACCOUNTS_LEN],
            );
            let args = SetConfigExtensionAuthorityIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::SetConfigExtensionAuthority(
                ix_accounts,
                args,
            ))
        }
        SET_TOKEN_BADGE_AUTHORITY_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                SET_TOKEN_BADGE_AUTHORITY_IX_ACCOUNTS_LEN,
                "SetTokenBadgeAuthority",
            )?;
            let ix_accounts = SetTokenBadgeAuthorityKeys::from(
                &accounts[..SET_TOKEN_BADGE_AUTHORITY_IX_ACCOUNTS_LEN],
            );
            let args = SetTokenBadgeAuthorityIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::SetTokenBadgeAuthority(
                ix_accounts,
                args,
            ))
        }
        INITIALIZE_TOKEN_BADGE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                INITIALIZE_TOKEN_BADGE_IX_ACCOUNTS_LEN,
                "InitializeTokenBadge",
            )?;
            let ix_accounts =
                InitializeTokenBadgeKeys::from(&accounts[..INITIALIZE_TOKEN_BADGE_IX_ACCOUNTS_LEN]);
            let args = InitializeTokenBadgeIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::InitializeTokenBadge(
                ix_accounts,
                args,
            ))
        }
        DELETE_TOKEN_BADGE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                DELETE_TOKEN_BADGE_IX_ACCOUNTS_LEN,
                "DeleteTokenBadge",
            )?;
            let ix_accounts =
                DeleteTokenBadgeKeys::from(&accounts[..DELETE_TOKEN_BADGE_IX_ACCOUNTS_LEN]);
            let args = DeleteTokenBadgeIxData::from_bytes(&data[..])?;
            Ok(WhirlpoolInstruction::DeleteTokenBadge(ix_accounts, args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {:?}", discriminator),
        )),
    }
}
