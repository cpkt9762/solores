//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-15
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

//! Account parser for Anchor contracts with 8-byte discriminators
use crate::accounts::*;
#[allow(unused_imports)]
use solana_pubkey::Pubkey;
/// Account parsing error types
#[derive(Clone, Debug, PartialEq)]
pub enum AccountParseError {
    /// Discriminator does not match any known account type - can try next account
    DiscriminatorMismatch { expected: [u8; 8], found: [u8; 8] },
    /// Data is too short to contain discriminator - should not try other accounts
    DataTooShort { expected: usize, found: usize },
    /// Data length is incorrect for this account type - should not try other accounts
    IncorrectLength { expected: usize, found: usize },
    /// Failed to deserialize account data - should not try other accounts
    DeserializationFailed(String),
}
impl std::fmt::Display for AccountParseError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AccountParseError::DiscriminatorMismatch { expected, found } => {
                write!(
                    f,
                    "Discriminator mismatch. Expected: {:?}, found: {:?}",
                    expected, found
                )
            }
            AccountParseError::DataTooShort { expected, found } => {
                write!(
                    f,
                    "Account data too short. Expected at least {} bytes, got: {}",
                    expected, found
                )
            }
            AccountParseError::IncorrectLength { expected, found } => {
                write!(
                    f,
                    "Account data length mismatch. Expected: {}, got: {}",
                    expected, found
                )
            }
            AccountParseError::DeserializationFailed(msg) => {
                write!(f, "Failed to deserialize account data: {}", msg)
            }
        }
    }
}
impl std::error::Error for AccountParseError {}
impl From<AccountParseError> for std::io::Error {
    fn from(err: AccountParseError) -> std::io::Error {
        std::io::Error::new(std::io::ErrorKind::InvalidData, err.to_string())
    }
}
/// Program account types
#[derive(Clone, Debug, PartialEq)]
pub enum WhirlpoolAccount {
    WhirlpoolsConfigExtension(WhirlpoolsConfigExtension),
    WhirlpoolsConfig(WhirlpoolsConfig),
    FeeTier(FeeTier),
    PositionBundle(PositionBundle),
    Position(Position),
    TickArray(TickArray),
    TokenBadge(TokenBadge),
    Whirlpool(Whirlpool),
}
/// Try to parse account data into one of the known account types
pub fn try_unpack_account(data: &[u8]) -> Result<WhirlpoolAccount, std::io::Error> {
    match WhirlpoolsConfigExtension::from_bytes(data) {
        Ok(account) => return Ok(WhirlpoolAccount::WhirlpoolsConfigExtension(account)),
        Err(AccountParseError::DiscriminatorMismatch { .. }) => {}
        Err(e) => {
            return Err(e.into());
        }
    }
    match WhirlpoolsConfig::from_bytes(data) {
        Ok(account) => return Ok(WhirlpoolAccount::WhirlpoolsConfig(account)),
        Err(AccountParseError::DiscriminatorMismatch { .. }) => {}
        Err(e) => {
            return Err(e.into());
        }
    }
    match FeeTier::from_bytes(data) {
        Ok(account) => return Ok(WhirlpoolAccount::FeeTier(account)),
        Err(AccountParseError::DiscriminatorMismatch { .. }) => {}
        Err(e) => {
            return Err(e.into());
        }
    }
    match PositionBundle::from_bytes(data) {
        Ok(account) => return Ok(WhirlpoolAccount::PositionBundle(account)),
        Err(AccountParseError::DiscriminatorMismatch { .. }) => {}
        Err(e) => {
            return Err(e.into());
        }
    }
    match Position::from_bytes(data) {
        Ok(account) => return Ok(WhirlpoolAccount::Position(account)),
        Err(AccountParseError::DiscriminatorMismatch { .. }) => {}
        Err(e) => {
            return Err(e.into());
        }
    }
    match TickArray::from_bytes(data) {
        Ok(account) => return Ok(WhirlpoolAccount::TickArray(account)),
        Err(AccountParseError::DiscriminatorMismatch { .. }) => {}
        Err(e) => {
            return Err(e.into());
        }
    }
    match TokenBadge::from_bytes(data) {
        Ok(account) => return Ok(WhirlpoolAccount::TokenBadge(account)),
        Err(AccountParseError::DiscriminatorMismatch { .. }) => {}
        Err(e) => {
            return Err(e.into());
        }
    }
    match Whirlpool::from_bytes(data) {
        Ok(account) => return Ok(WhirlpoolAccount::Whirlpool(account)),
        Err(AccountParseError::DiscriminatorMismatch { .. }) => {}
        Err(e) => {
            return Err(e.into());
        }
    }
    Err(std::io::Error::new(
        std::io::ErrorKind::InvalidData,
        "Unable to parse account data into any known account type",
    ))
}
