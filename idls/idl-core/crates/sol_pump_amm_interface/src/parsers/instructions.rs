//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-16
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

//! Instructions parser for Anchor contracts with 8-byte discriminators
use crate::instructions::*;
#[allow(unused_imports)]
use solana_pubkey::Pubkey;
/// Program instruction types for Anchor contract
#[derive(Clone, Debug, PartialEq)]
pub enum PumpAmmInstruction {
    Buy(BuyKeys, BuyIxData),
    CollectCoinCreatorFee(CollectCoinCreatorFeeKeys, CollectCoinCreatorFeeIxData),
    CreateConfig(CreateConfigKeys, CreateConfigIxData),
    CreatePool(CreatePoolKeys, CreatePoolIxData),
    Deposit(DepositKeys, DepositIxData),
    Disable(DisableKeys, DisableIxData),
    ExtendAccount(ExtendAccountKeys, ExtendAccountIxData),
    Sell(SellKeys, SellIxData),
    ///Sets Pool::coin_creator from Metaplex metadata creator or BondingCurve::creator
    SetCoinCreator(SetCoinCreatorKeys, SetCoinCreatorIxData),
    UpdateAdmin(UpdateAdminKeys, UpdateAdminIxData),
    UpdateFeeConfig(UpdateFeeConfigKeys, UpdateFeeConfigIxData),
    Withdraw(WithdrawKeys, WithdrawIxData),
}
impl PumpAmmInstruction {
    /// Manual JSON serialization
    #[cfg(feature = "serde")]
    pub fn to_json(&self) -> String {
        match self {
            Self::Buy(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "buy",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CollectCoinCreatorFee(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "collect_coin_creator_fee",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CreateConfig(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "create_config",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CreatePool(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "create_pool",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Deposit(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "deposit",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Disable(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "disable",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::ExtendAccount(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "extend_account",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Sell(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "sell",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SetCoinCreator(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "set_coin_creator",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::UpdateAdmin(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "update_admin",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::UpdateFeeConfig(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "update_fee_config",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Withdraw(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "withdraw",
                    keys.to_json(),
                    data.to_json()
                )
            }
        }
    }
}
/// Helper function to check minimum accounts requirement
fn check_min_accounts_req(
    accounts: &[Pubkey],
    required_len: usize,
    instruction_name: &str,
) -> Result<(), std::io::Error> {
    if accounts.len() < required_len {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Insufficient accounts for instruction {}", instruction_name),
        ));
    }
    Ok(())
}
/// Parse instruction data based on 8-byte discriminator (Anchor contracts)
pub fn parse_instruction(
    data: &[u8],
    accounts: &[Pubkey],
) -> Result<PumpAmmInstruction, std::io::Error> {
    if data.len() < 8 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data too short for discriminator",
        ));
    }
    let discriminator: [u8; 8] = data[0..8].try_into().map_err(|_| {
        std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Failed to read discriminator",
        )
    })?;
    match discriminator {
        BUY_IX_DISCM => {
            check_min_accounts_req(accounts, BUY_IX_ACCOUNTS_LEN, "Buy")?;
            let ix_accounts = BuyKeys::from(&accounts[..BUY_IX_ACCOUNTS_LEN]);
            let args = BuyIxData::from_bytes(&data[..])?;
            Ok(PumpAmmInstruction::Buy(ix_accounts, args))
        }
        COLLECT_COIN_CREATOR_FEE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                COLLECT_COIN_CREATOR_FEE_IX_ACCOUNTS_LEN,
                "CollectCoinCreatorFee",
            )?;
            let ix_accounts = CollectCoinCreatorFeeKeys::from(
                &accounts[..COLLECT_COIN_CREATOR_FEE_IX_ACCOUNTS_LEN],
            );
            let args = CollectCoinCreatorFeeIxData::from_bytes(&data[..])?;
            Ok(PumpAmmInstruction::CollectCoinCreatorFee(ix_accounts, args))
        }
        CREATE_CONFIG_IX_DISCM => {
            check_min_accounts_req(accounts, CREATE_CONFIG_IX_ACCOUNTS_LEN, "CreateConfig")?;
            let ix_accounts = CreateConfigKeys::from(&accounts[..CREATE_CONFIG_IX_ACCOUNTS_LEN]);
            let args = CreateConfigIxData::from_bytes(&data[..])?;
            Ok(PumpAmmInstruction::CreateConfig(ix_accounts, args))
        }
        CREATE_POOL_IX_DISCM => {
            check_min_accounts_req(accounts, CREATE_POOL_IX_ACCOUNTS_LEN, "CreatePool")?;
            let ix_accounts = CreatePoolKeys::from(&accounts[..CREATE_POOL_IX_ACCOUNTS_LEN]);
            let args = CreatePoolIxData::from_bytes(&data[..])?;
            Ok(PumpAmmInstruction::CreatePool(ix_accounts, args))
        }
        DEPOSIT_IX_DISCM => {
            check_min_accounts_req(accounts, DEPOSIT_IX_ACCOUNTS_LEN, "Deposit")?;
            let ix_accounts = DepositKeys::from(&accounts[..DEPOSIT_IX_ACCOUNTS_LEN]);
            let args = DepositIxData::from_bytes(&data[..])?;
            Ok(PumpAmmInstruction::Deposit(ix_accounts, args))
        }
        DISABLE_IX_DISCM => {
            check_min_accounts_req(accounts, DISABLE_IX_ACCOUNTS_LEN, "Disable")?;
            let ix_accounts = DisableKeys::from(&accounts[..DISABLE_IX_ACCOUNTS_LEN]);
            let args = DisableIxData::from_bytes(&data[..])?;
            Ok(PumpAmmInstruction::Disable(ix_accounts, args))
        }
        EXTEND_ACCOUNT_IX_DISCM => {
            check_min_accounts_req(accounts, EXTEND_ACCOUNT_IX_ACCOUNTS_LEN, "ExtendAccount")?;
            let ix_accounts = ExtendAccountKeys::from(&accounts[..EXTEND_ACCOUNT_IX_ACCOUNTS_LEN]);
            let args = ExtendAccountIxData::from_bytes(&data[..])?;
            Ok(PumpAmmInstruction::ExtendAccount(ix_accounts, args))
        }
        SELL_IX_DISCM => {
            check_min_accounts_req(accounts, SELL_IX_ACCOUNTS_LEN, "Sell")?;
            let ix_accounts = SellKeys::from(&accounts[..SELL_IX_ACCOUNTS_LEN]);
            let args = SellIxData::from_bytes(&data[..])?;
            Ok(PumpAmmInstruction::Sell(ix_accounts, args))
        }
        SET_COIN_CREATOR_IX_DISCM => {
            check_min_accounts_req(accounts, SET_COIN_CREATOR_IX_ACCOUNTS_LEN, "SetCoinCreator")?;
            let ix_accounts =
                SetCoinCreatorKeys::from(&accounts[..SET_COIN_CREATOR_IX_ACCOUNTS_LEN]);
            let args = SetCoinCreatorIxData::from_bytes(&data[..])?;
            Ok(PumpAmmInstruction::SetCoinCreator(ix_accounts, args))
        }
        UPDATE_ADMIN_IX_DISCM => {
            check_min_accounts_req(accounts, UPDATE_ADMIN_IX_ACCOUNTS_LEN, "UpdateAdmin")?;
            let ix_accounts = UpdateAdminKeys::from(&accounts[..UPDATE_ADMIN_IX_ACCOUNTS_LEN]);
            let args = UpdateAdminIxData::from_bytes(&data[..])?;
            Ok(PumpAmmInstruction::UpdateAdmin(ix_accounts, args))
        }
        UPDATE_FEE_CONFIG_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                UPDATE_FEE_CONFIG_IX_ACCOUNTS_LEN,
                "UpdateFeeConfig",
            )?;
            let ix_accounts =
                UpdateFeeConfigKeys::from(&accounts[..UPDATE_FEE_CONFIG_IX_ACCOUNTS_LEN]);
            let args = UpdateFeeConfigIxData::from_bytes(&data[..])?;
            Ok(PumpAmmInstruction::UpdateFeeConfig(ix_accounts, args))
        }
        WITHDRAW_IX_DISCM => {
            check_min_accounts_req(accounts, WITHDRAW_IX_ACCOUNTS_LEN, "Withdraw")?;
            let ix_accounts = WithdrawKeys::from(&accounts[..WITHDRAW_IX_ACCOUNTS_LEN]);
            let args = WithdrawIxData::from_bytes(&data[..])?;
            Ok(PumpAmmInstruction::Withdraw(ix_accounts, args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {:?}", discriminator),
        )),
    }
}
