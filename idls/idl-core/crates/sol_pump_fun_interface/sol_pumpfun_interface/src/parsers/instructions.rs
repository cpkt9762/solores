//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-15
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

//! Instructions parser for Anchor contracts with 8-byte discriminators
use crate::instructions::*;
#[allow(unused_imports)]
use solana_pubkey::Pubkey;
/// Program instruction types for Anchor contract
#[derive(Clone, Debug, PartialEq)]
pub enum PumpfunInstruction {
    ///Creates the global state.
    Initialize(InitializeKeys, InitializeIxData),
    ///Sets the global state parameters.
    SetParams(SetParamsKeys, SetParamsIxData),
    ///Creates a new coin and bonding curve.
    Create(CreateKeys, CreateIxData),
    ///Buys tokens from a bonding curve.
    Buy(BuyKeys, BuyIxData),
    ///Sells tokens into a bonding curve.
    Sell(SellKeys, SellIxData),
    ///Allows the admin to withdraw liquidity for a migration once the bonding curve completes
    Withdraw(WithdrawKeys, WithdrawIxData),
}
impl PumpfunInstruction {
    /// Manual JSON serialization
    #[cfg(feature = "serde")]
    pub fn to_json(&self) -> String {
        match self {
            Self::Initialize(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initialize",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SetParams(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "setParams",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Create(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "create",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Buy(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "buy",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Sell(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "sell",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Withdraw(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "withdraw",
                    keys.to_json(),
                    data.to_json()
                )
            }
        }
    }
}
/// Helper function to check minimum accounts requirement
fn check_min_accounts_req(
    accounts: &[Pubkey],
    required_len: usize,
    instruction_name: &str,
) -> Result<(), std::io::Error> {
    if accounts.len() < required_len {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Insufficient accounts for instruction {}", instruction_name),
        ));
    }
    Ok(())
}
/// Parse instruction data based on 8-byte discriminator (Anchor contracts)
pub fn parse_instruction(
    data: &[u8],
    accounts: &[Pubkey],
) -> Result<PumpfunInstruction, std::io::Error> {
    if data.len() < 8 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data too short for discriminator",
        ));
    }
    let discriminator: [u8; 8] = data[0..8].try_into().map_err(|_| {
        std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Failed to read discriminator",
        )
    })?;
    match discriminator {
        INITIALIZE_IX_DISCM => {
            check_min_accounts_req(accounts, INITIALIZE_IX_ACCOUNTS_LEN, "Initialize")?;
            let ix_accounts = InitializeKeys::from(&accounts[..INITIALIZE_IX_ACCOUNTS_LEN]);
            let args = InitializeIxData::from_bytes(&data[..])?;
            Ok(PumpfunInstruction::Initialize(ix_accounts, args))
        }
        SET_PARAMS_IX_DISCM => {
            check_min_accounts_req(accounts, SET_PARAMS_IX_ACCOUNTS_LEN, "SetParams")?;
            let ix_accounts = SetParamsKeys::from(&accounts[..SET_PARAMS_IX_ACCOUNTS_LEN]);
            let args = SetParamsIxData::from_bytes(&data[..])?;
            Ok(PumpfunInstruction::SetParams(ix_accounts, args))
        }
        CREATE_IX_DISCM => {
            check_min_accounts_req(accounts, CREATE_IX_ACCOUNTS_LEN, "Create")?;
            let ix_accounts = CreateKeys::from(&accounts[..CREATE_IX_ACCOUNTS_LEN]);
            let args = CreateIxData::from_bytes(&data[..])?;
            Ok(PumpfunInstruction::Create(ix_accounts, args))
        }
        BUY_IX_DISCM => {
            check_min_accounts_req(accounts, BUY_IX_ACCOUNTS_LEN, "Buy")?;
            let ix_accounts = BuyKeys::from(&accounts[..BUY_IX_ACCOUNTS_LEN]);
            let args = BuyIxData::from_bytes(&data[..])?;
            Ok(PumpfunInstruction::Buy(ix_accounts, args))
        }
        SELL_IX_DISCM => {
            check_min_accounts_req(accounts, SELL_IX_ACCOUNTS_LEN, "Sell")?;
            let ix_accounts = SellKeys::from(&accounts[..SELL_IX_ACCOUNTS_LEN]);
            let args = SellIxData::from_bytes(&data[..])?;
            Ok(PumpfunInstruction::Sell(ix_accounts, args))
        }
        WITHDRAW_IX_DISCM => {
            check_min_accounts_req(accounts, WITHDRAW_IX_ACCOUNTS_LEN, "Withdraw")?;
            let ix_accounts = WithdrawKeys::from(&accounts[..WITHDRAW_IX_ACCOUNTS_LEN]);
            let args = WithdrawIxData::from_bytes(&data[..])?;
            Ok(PumpfunInstruction::Withdraw(ix_accounts, args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {:?}", discriminator),
        )),
    }
}
