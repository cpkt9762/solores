//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-16
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

//! Instructions parser for Anchor contracts with 8-byte discriminators
use crate::instructions::*;
#[allow(unused_imports)]
use solana_pubkey::Pubkey;
/// Program instruction types for Anchor contract
#[derive(Clone, Debug, PartialEq)]
pub enum BoopInstruction {
    AddOperators(AddOperatorsKeys, AddOperatorsIxData),
    BuyToken(BuyTokenKeys, BuyTokenIxData),
    CancelAuthorityTransfer(CancelAuthorityTransferKeys, CancelAuthorityTransferIxData),
    CloseBondingCurveVault(CloseBondingCurveVaultKeys, CloseBondingCurveVaultIxData),
    CollectMeteoraTradingFees(
        CollectMeteoraTradingFeesKeys,
        CollectMeteoraTradingFeesIxData,
    ),
    CollectTradingFees(CollectTradingFeesKeys, CollectTradingFeesIxData),
    CompleteAuthorityTransfer(
        CompleteAuthorityTransferKeys,
        CompleteAuthorityTransferIxData,
    ),
    CreateMeteoraPool(CreateMeteoraPoolKeys, CreateMeteoraPoolIxData),
    CreateRaydiumPool(CreateRaydiumPoolKeys, CreateRaydiumPoolIxData),
    CreateRaydiumRandomPool(CreateRaydiumRandomPoolKeys, CreateRaydiumRandomPoolIxData),
    CreateToken(CreateTokenKeys, CreateTokenIxData),
    CreateTokenFallback(CreateTokenFallbackKeys, CreateTokenFallbackIxData),
    DeployBondingCurve(DeployBondingCurveKeys, DeployBondingCurveIxData),
    DeployBondingCurveFallback(
        DeployBondingCurveFallbackKeys,
        DeployBondingCurveFallbackIxData,
    ),
    DepositIntoRaydium(DepositIntoRaydiumKeys, DepositIntoRaydiumIxData),
    Graduate(GraduateKeys, GraduateIxData),
    Initialize(InitializeKeys, InitializeIxData),
    InitiateAuthorityTransfer(
        InitiateAuthorityTransferKeys,
        InitiateAuthorityTransferIxData,
    ),
    LockRaydiumLiquidity(LockRaydiumLiquidityKeys, LockRaydiumLiquidityIxData),
    RemoveOperators(RemoveOperatorsKeys, RemoveOperatorsIxData),
    SellToken(SellTokenKeys, SellTokenIxData),
    SplitTradingFees(SplitTradingFeesKeys, SplitTradingFeesIxData),
    SwapSolForTokensOnRaydium(
        SwapSolForTokensOnRaydiumKeys,
        SwapSolForTokensOnRaydiumIxData,
    ),
    SwapTokensForSolOnRaydium(
        SwapTokensForSolOnRaydiumKeys,
        SwapTokensForSolOnRaydiumIxData,
    ),
    TogglePaused(TogglePausedKeys, TogglePausedIxData),
    UpdateConfig(UpdateConfigKeys, UpdateConfigIxData),
}
impl BoopInstruction {
    /// Manual JSON serialization
    #[cfg(feature = "serde")]
    pub fn to_json(&self) -> String {
        match self {
            Self::AddOperators(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "add_operators",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::BuyToken(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "buy_token",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CancelAuthorityTransfer(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "cancel_authority_transfer",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CloseBondingCurveVault(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "close_bonding_curve_vault",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CollectMeteoraTradingFees(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "collect_meteora_trading_fees",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CollectTradingFees(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "collect_trading_fees",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CompleteAuthorityTransfer(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "complete_authority_transfer",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CreateMeteoraPool(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "create_meteora_pool",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CreateRaydiumPool(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "create_raydium_pool",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CreateRaydiumRandomPool(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "create_raydium_random_pool",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CreateToken(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "create_token",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::CreateTokenFallback(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "create_token_fallback",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::DeployBondingCurve(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "deploy_bonding_curve",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::DeployBondingCurveFallback(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "deploy_bonding_curve_fallback",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::DepositIntoRaydium(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "deposit_into_raydium",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Graduate(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "graduate",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::Initialize(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initialize",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::InitiateAuthorityTransfer(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "initiate_authority_transfer",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::LockRaydiumLiquidity(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "lock_raydium_liquidity",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::RemoveOperators(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "remove_operators",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SellToken(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "sell_token",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SplitTradingFees(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "split_trading_fees",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SwapSolForTokensOnRaydium(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "swap_sol_for_tokens_on_raydium",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::SwapTokensForSolOnRaydium(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "swap_tokens_for_sol_on_raydium",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::TogglePaused(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "toggle_paused",
                    keys.to_json(),
                    data.to_json()
                )
            }
            Self::UpdateConfig(keys, data) => {
                format!(
                    "{{\"instruction\":\"{}\",\"keys\":{},\"data\":{}}}",
                    "update_config",
                    keys.to_json(),
                    data.to_json()
                )
            }
        }
    }
}
/// Helper function to check minimum accounts requirement
fn check_min_accounts_req(
    accounts: &[Pubkey],
    required_len: usize,
    instruction_name: &str,
) -> Result<(), std::io::Error> {
    if accounts.len() < required_len {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Insufficient accounts for instruction {}", instruction_name),
        ));
    }
    Ok(())
}
/// Parse instruction data based on 8-byte discriminator (Anchor contracts)
pub fn parse_instruction(
    data: &[u8],
    accounts: &[Pubkey],
) -> Result<BoopInstruction, std::io::Error> {
    if data.len() < 8 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data too short for discriminator",
        ));
    }
    let discriminator: [u8; 8] = data[0..8].try_into().map_err(|_| {
        std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Failed to read discriminator",
        )
    })?;
    match discriminator {
        ADD_OPERATORS_IX_DISCM => {
            check_min_accounts_req(accounts, ADD_OPERATORS_IX_ACCOUNTS_LEN, "AddOperators")?;
            let ix_accounts = AddOperatorsKeys::from(&accounts[..ADD_OPERATORS_IX_ACCOUNTS_LEN]);
            let args = AddOperatorsIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::AddOperators(ix_accounts, args))
        }
        BUY_TOKEN_IX_DISCM => {
            check_min_accounts_req(accounts, BUY_TOKEN_IX_ACCOUNTS_LEN, "BuyToken")?;
            let ix_accounts = BuyTokenKeys::from(&accounts[..BUY_TOKEN_IX_ACCOUNTS_LEN]);
            let args = BuyTokenIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::BuyToken(ix_accounts, args))
        }
        CANCEL_AUTHORITY_TRANSFER_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CANCEL_AUTHORITY_TRANSFER_IX_ACCOUNTS_LEN,
                "CancelAuthorityTransfer",
            )?;
            let ix_accounts = CancelAuthorityTransferKeys::from(
                &accounts[..CANCEL_AUTHORITY_TRANSFER_IX_ACCOUNTS_LEN],
            );
            let args = CancelAuthorityTransferIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::CancelAuthorityTransfer(ix_accounts, args))
        }
        CLOSE_BONDING_CURVE_VAULT_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CLOSE_BONDING_CURVE_VAULT_IX_ACCOUNTS_LEN,
                "CloseBondingCurveVault",
            )?;
            let ix_accounts = CloseBondingCurveVaultKeys::from(
                &accounts[..CLOSE_BONDING_CURVE_VAULT_IX_ACCOUNTS_LEN],
            );
            let args = CloseBondingCurveVaultIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::CloseBondingCurveVault(ix_accounts, args))
        }
        COLLECT_METEORA_TRADING_FEES_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                COLLECT_METEORA_TRADING_FEES_IX_ACCOUNTS_LEN,
                "CollectMeteoraTradingFees",
            )?;
            let ix_accounts = CollectMeteoraTradingFeesKeys::from(
                &accounts[..COLLECT_METEORA_TRADING_FEES_IX_ACCOUNTS_LEN],
            );
            let args = CollectMeteoraTradingFeesIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::CollectMeteoraTradingFees(
                ix_accounts,
                args,
            ))
        }
        COLLECT_TRADING_FEES_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                COLLECT_TRADING_FEES_IX_ACCOUNTS_LEN,
                "CollectTradingFees",
            )?;
            let ix_accounts =
                CollectTradingFeesKeys::from(&accounts[..COLLECT_TRADING_FEES_IX_ACCOUNTS_LEN]);
            let args = CollectTradingFeesIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::CollectTradingFees(ix_accounts, args))
        }
        COMPLETE_AUTHORITY_TRANSFER_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                COMPLETE_AUTHORITY_TRANSFER_IX_ACCOUNTS_LEN,
                "CompleteAuthorityTransfer",
            )?;
            let ix_accounts = CompleteAuthorityTransferKeys::from(
                &accounts[..COMPLETE_AUTHORITY_TRANSFER_IX_ACCOUNTS_LEN],
            );
            let args = CompleteAuthorityTransferIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::CompleteAuthorityTransfer(
                ix_accounts,
                args,
            ))
        }
        CREATE_METEORA_POOL_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CREATE_METEORA_POOL_IX_ACCOUNTS_LEN,
                "CreateMeteoraPool",
            )?;
            let ix_accounts =
                CreateMeteoraPoolKeys::from(&accounts[..CREATE_METEORA_POOL_IX_ACCOUNTS_LEN]);
            let args = CreateMeteoraPoolIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::CreateMeteoraPool(ix_accounts, args))
        }
        CREATE_RAYDIUM_POOL_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CREATE_RAYDIUM_POOL_IX_ACCOUNTS_LEN,
                "CreateRaydiumPool",
            )?;
            let ix_accounts =
                CreateRaydiumPoolKeys::from(&accounts[..CREATE_RAYDIUM_POOL_IX_ACCOUNTS_LEN]);
            let args = CreateRaydiumPoolIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::CreateRaydiumPool(ix_accounts, args))
        }
        CREATE_RAYDIUM_RANDOM_POOL_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CREATE_RAYDIUM_RANDOM_POOL_IX_ACCOUNTS_LEN,
                "CreateRaydiumRandomPool",
            )?;
            let ix_accounts = CreateRaydiumRandomPoolKeys::from(
                &accounts[..CREATE_RAYDIUM_RANDOM_POOL_IX_ACCOUNTS_LEN],
            );
            let args = CreateRaydiumRandomPoolIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::CreateRaydiumRandomPool(ix_accounts, args))
        }
        CREATE_TOKEN_IX_DISCM => {
            check_min_accounts_req(accounts, CREATE_TOKEN_IX_ACCOUNTS_LEN, "CreateToken")?;
            let ix_accounts = CreateTokenKeys::from(&accounts[..CREATE_TOKEN_IX_ACCOUNTS_LEN]);
            let args = CreateTokenIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::CreateToken(ix_accounts, args))
        }
        CREATE_TOKEN_FALLBACK_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                CREATE_TOKEN_FALLBACK_IX_ACCOUNTS_LEN,
                "CreateTokenFallback",
            )?;
            let ix_accounts =
                CreateTokenFallbackKeys::from(&accounts[..CREATE_TOKEN_FALLBACK_IX_ACCOUNTS_LEN]);
            let args = CreateTokenFallbackIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::CreateTokenFallback(ix_accounts, args))
        }
        DEPLOY_BONDING_CURVE_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                DEPLOY_BONDING_CURVE_IX_ACCOUNTS_LEN,
                "DeployBondingCurve",
            )?;
            let ix_accounts =
                DeployBondingCurveKeys::from(&accounts[..DEPLOY_BONDING_CURVE_IX_ACCOUNTS_LEN]);
            let args = DeployBondingCurveIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::DeployBondingCurve(ix_accounts, args))
        }
        DEPLOY_BONDING_CURVE_FALLBACK_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                DEPLOY_BONDING_CURVE_FALLBACK_IX_ACCOUNTS_LEN,
                "DeployBondingCurveFallback",
            )?;
            let ix_accounts = DeployBondingCurveFallbackKeys::from(
                &accounts[..DEPLOY_BONDING_CURVE_FALLBACK_IX_ACCOUNTS_LEN],
            );
            let args = DeployBondingCurveFallbackIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::DeployBondingCurveFallback(
                ix_accounts,
                args,
            ))
        }
        DEPOSIT_INTO_RAYDIUM_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                DEPOSIT_INTO_RAYDIUM_IX_ACCOUNTS_LEN,
                "DepositIntoRaydium",
            )?;
            let ix_accounts =
                DepositIntoRaydiumKeys::from(&accounts[..DEPOSIT_INTO_RAYDIUM_IX_ACCOUNTS_LEN]);
            let args = DepositIntoRaydiumIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::DepositIntoRaydium(ix_accounts, args))
        }
        GRADUATE_IX_DISCM => {
            check_min_accounts_req(accounts, GRADUATE_IX_ACCOUNTS_LEN, "Graduate")?;
            let ix_accounts = GraduateKeys::from(&accounts[..GRADUATE_IX_ACCOUNTS_LEN]);
            let args = GraduateIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::Graduate(ix_accounts, args))
        }
        INITIALIZE_IX_DISCM => {
            check_min_accounts_req(accounts, INITIALIZE_IX_ACCOUNTS_LEN, "Initialize")?;
            let ix_accounts = InitializeKeys::from(&accounts[..INITIALIZE_IX_ACCOUNTS_LEN]);
            let args = InitializeIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::Initialize(ix_accounts, args))
        }
        INITIATE_AUTHORITY_TRANSFER_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                INITIATE_AUTHORITY_TRANSFER_IX_ACCOUNTS_LEN,
                "InitiateAuthorityTransfer",
            )?;
            let ix_accounts = InitiateAuthorityTransferKeys::from(
                &accounts[..INITIATE_AUTHORITY_TRANSFER_IX_ACCOUNTS_LEN],
            );
            let args = InitiateAuthorityTransferIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::InitiateAuthorityTransfer(
                ix_accounts,
                args,
            ))
        }
        LOCK_RAYDIUM_LIQUIDITY_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                LOCK_RAYDIUM_LIQUIDITY_IX_ACCOUNTS_LEN,
                "LockRaydiumLiquidity",
            )?;
            let ix_accounts =
                LockRaydiumLiquidityKeys::from(&accounts[..LOCK_RAYDIUM_LIQUIDITY_IX_ACCOUNTS_LEN]);
            let args = LockRaydiumLiquidityIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::LockRaydiumLiquidity(ix_accounts, args))
        }
        REMOVE_OPERATORS_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                REMOVE_OPERATORS_IX_ACCOUNTS_LEN,
                "RemoveOperators",
            )?;
            let ix_accounts =
                RemoveOperatorsKeys::from(&accounts[..REMOVE_OPERATORS_IX_ACCOUNTS_LEN]);
            let args = RemoveOperatorsIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::RemoveOperators(ix_accounts, args))
        }
        SELL_TOKEN_IX_DISCM => {
            check_min_accounts_req(accounts, SELL_TOKEN_IX_ACCOUNTS_LEN, "SellToken")?;
            let ix_accounts = SellTokenKeys::from(&accounts[..SELL_TOKEN_IX_ACCOUNTS_LEN]);
            let args = SellTokenIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::SellToken(ix_accounts, args))
        }
        SPLIT_TRADING_FEES_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                SPLIT_TRADING_FEES_IX_ACCOUNTS_LEN,
                "SplitTradingFees",
            )?;
            let ix_accounts =
                SplitTradingFeesKeys::from(&accounts[..SPLIT_TRADING_FEES_IX_ACCOUNTS_LEN]);
            let args = SplitTradingFeesIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::SplitTradingFees(ix_accounts, args))
        }
        SWAP_SOL_FOR_TOKENS_ON_RAYDIUM_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                SWAP_SOL_FOR_TOKENS_ON_RAYDIUM_IX_ACCOUNTS_LEN,
                "SwapSolForTokensOnRaydium",
            )?;
            let ix_accounts = SwapSolForTokensOnRaydiumKeys::from(
                &accounts[..SWAP_SOL_FOR_TOKENS_ON_RAYDIUM_IX_ACCOUNTS_LEN],
            );
            let args = SwapSolForTokensOnRaydiumIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::SwapSolForTokensOnRaydium(
                ix_accounts,
                args,
            ))
        }
        SWAP_TOKENS_FOR_SOL_ON_RAYDIUM_IX_DISCM => {
            check_min_accounts_req(
                accounts,
                SWAP_TOKENS_FOR_SOL_ON_RAYDIUM_IX_ACCOUNTS_LEN,
                "SwapTokensForSolOnRaydium",
            )?;
            let ix_accounts = SwapTokensForSolOnRaydiumKeys::from(
                &accounts[..SWAP_TOKENS_FOR_SOL_ON_RAYDIUM_IX_ACCOUNTS_LEN],
            );
            let args = SwapTokensForSolOnRaydiumIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::SwapTokensForSolOnRaydium(
                ix_accounts,
                args,
            ))
        }
        TOGGLE_PAUSED_IX_DISCM => {
            check_min_accounts_req(accounts, TOGGLE_PAUSED_IX_ACCOUNTS_LEN, "TogglePaused")?;
            let ix_accounts = TogglePausedKeys::from(&accounts[..TOGGLE_PAUSED_IX_ACCOUNTS_LEN]);
            let args = TogglePausedIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::TogglePaused(ix_accounts, args))
        }
        UPDATE_CONFIG_IX_DISCM => {
            check_min_accounts_req(accounts, UPDATE_CONFIG_IX_ACCOUNTS_LEN, "UpdateConfig")?;
            let ix_accounts = UpdateConfigKeys::from(&accounts[..UPDATE_CONFIG_IX_ACCOUNTS_LEN]);
            let args = UpdateConfigIxData::from_bytes(&data[..])?;
            Ok(BoopInstruction::UpdateConfig(ix_accounts, args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {:?}", discriminator),
        )),
    }
}
