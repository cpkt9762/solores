//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::accounts::*;
/// Program account types
#[derive(Clone, Debug, PartialEq)]
pub enum SquadsAccount {
    ///Stores data required for serial execution of a batch of multisig vault transactions.
    ///Vault transaction is a transaction that's executed on behalf of the multisig vault PDA
    ///and wraps arbitrary Solana instructions, typically calling into other Solana programs.
    ///The transactions themselves are stored in separate PDAs associated with the this account.
    Batch(Batch),
    ///Stores data required for execution of one transaction from a batch.
    VaultBatchTransaction(VaultBatchTransaction),
    ///Stores data required for execution of a multisig configuration transaction.
    ///Config transaction can perform a predefined set of actions on the Multisig PDA, such as adding/removing members,
    ///changing the threshold, etc.
    ConfigTransaction(ConfigTransaction),
    Multisig(Multisig),
    ///Global program configuration account.
    ProgramConfig(ProgramConfig),
    ///Stores the data required for tracking the status of a multisig proposal.
    ///Each `Proposal` has a 1:1 association with a transaction account, e.g. a `VaultTransaction` or a `ConfigTransaction`;
    ///the latter can be executed only after the `Proposal` has been approved and its time lock is released.
    Proposal(Proposal),
    SpendingLimit(SpendingLimit),
    ///Stores data required for tracking the voting and execution status of a vault transaction.
    ///Vault transaction is a transaction that's executed on behalf of the multisig vault PDA
    ///and wraps arbitrary Solana instructions, typically calling into other Solana programs.
    VaultTransaction(VaultTransaction),
}
/// Parse account data based on data length (non-Anchor contracts)
pub fn try_unpack_account(data: &[u8]) -> Result<SquadsAccount, std::io::Error> {
    let data_len = data.len();
    const BATCH_LEN: usize = std::mem::size_of::<Batch>();
    const VAULT_BATCH_TRANSACTION_LEN: usize = std::mem::size_of::<VaultBatchTransaction>();
    const CONFIG_TRANSACTION_LEN: usize = std::mem::size_of::<ConfigTransaction>();
    const MULTISIG_LEN: usize = std::mem::size_of::<Multisig>();
    const PROGRAM_CONFIG_LEN: usize = std::mem::size_of::<ProgramConfig>();
    const PROPOSAL_LEN: usize = std::mem::size_of::<Proposal>();
    const SPENDING_LIMIT_LEN: usize = std::mem::size_of::<SpendingLimit>();
    const VAULT_TRANSACTION_LEN: usize = std::mem::size_of::<VaultTransaction>();
    match data_len {
        BATCH_LEN => Ok(SquadsAccount::Batch(Batch::from_bytes(data)?)),
        VAULT_BATCH_TRANSACTION_LEN => Ok(SquadsAccount::VaultBatchTransaction(
            VaultBatchTransaction::from_bytes(data)?,
        )),
        CONFIG_TRANSACTION_LEN => Ok(SquadsAccount::ConfigTransaction(
            ConfigTransaction::from_bytes(data)?,
        )),
        MULTISIG_LEN => Ok(SquadsAccount::Multisig(Multisig::from_bytes(data)?)),
        PROGRAM_CONFIG_LEN => Ok(SquadsAccount::ProgramConfig(ProgramConfig::from_bytes(
            data,
        )?)),
        PROPOSAL_LEN => Ok(SquadsAccount::Proposal(Proposal::from_bytes(data)?)),
        SPENDING_LIMIT_LEN => Ok(SquadsAccount::SpendingLimit(SpendingLimit::from_bytes(
            data,
        )?)),
        VAULT_TRANSACTION_LEN => Ok(SquadsAccount::VaultTransaction(
            VaultTransaction::from_bytes(data)?,
        )),
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Invalid Account data length: {}", data_len),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    use borsh::{BorshDeserialize, BorshSerialize};
    #[test]
    fn test_batch_consistency() {
        let expected_first_field = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_account = Batch {
            multisig: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(SquadsAccount::Batch(account)) => {
                assert_eq!(
                    account.multisig, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [156u8, 194u8, 70u8, 44u8, 22u8, 88u8, 137u8, 44u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Batch)
                );
            }
        }
    }
    #[test]
    fn test_vault_batch_transaction_consistency() {
        let expected_first_field = 42u8;
        let test_account = VaultBatchTransaction {
            bump: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(SquadsAccount::VaultBatchTransaction(account)) => {
                assert_eq!(
                    account.bump, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [196u8, 121u8, 46u8, 36u8, 12u8, 19u8, 252u8, 7u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(VaultBatchTransaction)
                );
            }
        }
    }
    #[test]
    fn test_config_transaction_consistency() {
        let expected_first_field = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_account = ConfigTransaction {
            multisig: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(SquadsAccount::ConfigTransaction(account)) => {
                assert_eq!(
                    account.multisig, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [94u8, 8u8, 4u8, 35u8, 113u8, 139u8, 139u8, 112u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ConfigTransaction)
                );
            }
        }
    }
    #[test]
    fn test_multisig_consistency() {
        let expected_first_field = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_account = Multisig {
            create_key: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(SquadsAccount::Multisig(account)) => {
                assert_eq!(
                    account.create_key, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [224u8, 116u8, 121u8, 186u8, 68u8, 161u8, 79u8, 236u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Multisig)
                );
            }
        }
    }
    #[test]
    fn test_program_config_consistency() {
        let expected_first_field = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_account = ProgramConfig {
            authority: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(SquadsAccount::ProgramConfig(account)) => {
                assert_eq!(
                    account.authority, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [196u8, 210u8, 90u8, 231u8, 144u8, 149u8, 140u8, 63u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ProgramConfig)
                );
            }
        }
    }
    #[test]
    fn test_proposal_consistency() {
        let expected_first_field = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_account = Proposal {
            multisig: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(SquadsAccount::Proposal(account)) => {
                assert_eq!(
                    account.multisig, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [26u8, 94u8, 189u8, 187u8, 116u8, 136u8, 53u8, 33u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Proposal)
                );
            }
        }
    }
    #[test]
    fn test_spending_limit_consistency() {
        let expected_first_field = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_account = SpendingLimit {
            multisig: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(SquadsAccount::SpendingLimit(account)) => {
                assert_eq!(
                    account.multisig, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [10u8, 201u8, 27u8, 160u8, 218u8, 195u8, 222u8, 152u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SpendingLimit)
                );
            }
        }
    }
    #[test]
    fn test_vault_transaction_consistency() {
        let expected_first_field = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_account = VaultTransaction {
            multisig: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(SquadsAccount::VaultTransaction(account)) => {
                assert_eq!(
                    account.multisig, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [168u8, 250u8, 162u8, 100u8, 81u8, 14u8, 162u8, 207u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(VaultTransaction)
                );
            }
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_account = Batch::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            Batch::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(Batch)
                );
            }
        }
        let test_account = VaultBatchTransaction::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            VaultBatchTransaction::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(VaultBatchTransaction)
                );
            }
        }
        let test_account = ConfigTransaction::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            ConfigTransaction::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(ConfigTransaction)
                );
            }
        }
        let test_account = Multisig::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            Multisig::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(Multisig)
                );
            }
        }
        let test_account = ProgramConfig::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            ProgramConfig::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(ProgramConfig)
                );
            }
        }
        let test_account = Proposal::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            Proposal::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(Proposal)
                );
            }
        }
        let test_account = SpendingLimit::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            SpendingLimit::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(SpendingLimit)
                );
            }
        }
        let test_account = VaultTransaction::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            VaultTransaction::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(VaultTransaction)
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = try_unpack_account(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = try_unpack_account(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
