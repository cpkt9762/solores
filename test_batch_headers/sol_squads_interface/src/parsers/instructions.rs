//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::instructions::*;
pub const PROGRAM_CONFIG_INIT_IX_DISCM: u8 = 0u8;
pub const PROGRAM_CONFIG_SET_AUTHORITY_IX_DISCM: u8 = 1u8;
pub const PROGRAM_CONFIG_SET_MULTISIG_CREATION_FEE_IX_DISCM: u8 = 2u8;
pub const PROGRAM_CONFIG_SET_TREASURY_IX_DISCM: u8 = 3u8;
pub const MULTISIG_CREATE_IX_DISCM: u8 = 4u8;
pub const MULTISIG_CREATE_V2_IX_DISCM: u8 = 5u8;
pub const MULTISIG_ADD_MEMBER_IX_DISCM: u8 = 6u8;
pub const MULTISIG_REMOVE_MEMBER_IX_DISCM: u8 = 7u8;
pub const MULTISIG_SET_TIME_LOCK_IX_DISCM: u8 = 8u8;
pub const MULTISIG_CHANGE_THRESHOLD_IX_DISCM: u8 = 9u8;
pub const MULTISIG_SET_CONFIG_AUTHORITY_IX_DISCM: u8 = 10u8;
pub const MULTISIG_SET_RENT_COLLECTOR_IX_DISCM: u8 = 11u8;
pub const MULTISIG_ADD_SPENDING_LIMIT_IX_DISCM: u8 = 12u8;
pub const MULTISIG_REMOVE_SPENDING_LIMIT_IX_DISCM: u8 = 13u8;
pub const CONFIG_TRANSACTION_CREATE_IX_DISCM: u8 = 14u8;
pub const CONFIG_TRANSACTION_EXECUTE_IX_DISCM: u8 = 15u8;
pub const VAULT_TRANSACTION_CREATE_IX_DISCM: u8 = 16u8;
pub const VAULT_TRANSACTION_EXECUTE_IX_DISCM: u8 = 17u8;
pub const BATCH_CREATE_IX_DISCM: u8 = 18u8;
pub const BATCH_ADD_TRANSACTION_IX_DISCM: u8 = 19u8;
pub const BATCH_EXECUTE_TRANSACTION_IX_DISCM: u8 = 20u8;
pub const PROPOSAL_CREATE_IX_DISCM: u8 = 21u8;
pub const PROPOSAL_ACTIVATE_IX_DISCM: u8 = 22u8;
pub const PROPOSAL_APPROVE_IX_DISCM: u8 = 23u8;
pub const PROPOSAL_REJECT_IX_DISCM: u8 = 24u8;
pub const PROPOSAL_CANCEL_IX_DISCM: u8 = 25u8;
pub const SPENDING_LIMIT_USE_IX_DISCM: u8 = 26u8;
pub const CONFIG_TRANSACTION_ACCOUNTS_CLOSE_IX_DISCM: u8 = 27u8;
pub const VAULT_TRANSACTION_ACCOUNTS_CLOSE_IX_DISCM: u8 = 28u8;
pub const VAULT_BATCH_TRANSACTION_ACCOUNT_CLOSE_IX_DISCM: u8 = 29u8;
pub const BATCH_ACCOUNTS_CLOSE_IX_DISCM: u8 = 30u8;
/// Program instruction types
#[derive(Clone, Debug, PartialEq)]
pub enum SquadsInstruction {
    ///Initialize the program config.
    ProgramConfigInit(ProgramConfigInitIxArgs),
    ///Set the `authority` parameter of the program config.
    ProgramConfigSetAuthority(ProgramConfigSetAuthorityIxArgs),
    ///Set the `multisig_creation_fee` parameter of the program config.
    ProgramConfigSetMultisigCreationFee(ProgramConfigSetMultisigCreationFeeIxArgs),
    ///Set the `treasury` parameter of the program config.
    ProgramConfigSetTreasury(ProgramConfigSetTreasuryIxArgs),
    ///Create a multisig.
    MultisigCreate(MultisigCreateIxArgs),
    ///Create a multisig.
    MultisigCreateV2(MultisigCreateV2IxArgs),
    ///Add a new member to the controlled multisig.
    MultisigAddMember(MultisigAddMemberIxArgs),
    ///Remove a member/key from the controlled multisig.
    MultisigRemoveMember(MultisigRemoveMemberIxArgs),
    ///Set the `time_lock` config parameter for the controlled multisig.
    MultisigSetTimeLock(MultisigSetTimeLockIxArgs),
    ///Set the `threshold` config parameter for the controlled multisig.
    MultisigChangeThreshold(MultisigChangeThresholdIxArgs),
    ///Set the multisig `config_authority`.
    MultisigSetConfigAuthority(MultisigSetConfigAuthorityIxArgs),
    ///Set the multisig `rent_collector`.
    MultisigSetRentCollector(MultisigSetRentCollectorIxArgs),
    ///Create a new spending limit for the controlled multisig.
    MultisigAddSpendingLimit(MultisigAddSpendingLimitIxArgs),
    ///Remove the spending limit from the controlled multisig.
    MultisigRemoveSpendingLimit(MultisigRemoveSpendingLimitIxArgs),
    ///Create a new config transaction.
    ConfigTransactionCreate(ConfigTransactionCreateIxArgs),
    ///Execute a config transaction.
    ///The transaction must be `Approved`.
    ConfigTransactionExecute,
    ///Create a new vault transaction.
    VaultTransactionCreate(VaultTransactionCreateIxArgs),
    ///Execute a vault transaction.
    ///The transaction must be `Approved`.
    VaultTransactionExecute,
    ///Create a new batch.
    BatchCreate(BatchCreateIxArgs),
    ///Add a transaction to the batch.
    BatchAddTransaction(BatchAddTransactionIxArgs),
    ///Execute a transaction from the batch.
    BatchExecuteTransaction,
    ///Create a new multisig proposal.
    ProposalCreate(ProposalCreateIxArgs),
    ///Update status of a multisig proposal from `Draft` to `Active`.
    ProposalActivate,
    ///Approve a multisig proposal on behalf of the `member`.
    ///The proposal must be `Active`.
    ProposalApprove(ProposalApproveIxArgs),
    ///Reject a multisig proposal on behalf of the `member`.
    ///The proposal must be `Active`.
    ProposalReject(ProposalRejectIxArgs),
    ///Cancel a multisig proposal on behalf of the `member`.
    ///The proposal must be `Approved`.
    ProposalCancel(ProposalCancelIxArgs),
    ///Use a spending limit to transfer tokens from a multisig vault to a destination account.
    SpendingLimitUse(SpendingLimitUseIxArgs),
    ///Closes a `ConfigTransaction` and the corresponding `Proposal`.
    ///`transaction` can be closed if either:
    ///- the `proposal` is in a terminal state: `Executed`, `Rejected`, or `Cancelled`.
    ///- the `proposal` is stale.
    ConfigTransactionAccountsClose,
    ///Closes a `VaultTransaction` and the corresponding `Proposal`.
    ///`transaction` can be closed if either:
    ///- the `proposal` is in a terminal state: `Executed`, `Rejected`, or `Cancelled`.
    ///- the `proposal` is stale and not `Approved`.
    VaultTransactionAccountsClose,
    ///Closes a `VaultBatchTransaction` belonging to the `batch` and `proposal`.
    ///`transaction` can be closed if either:
    ///- it's marked as executed within the `batch`;
    ///- the `proposal` is in a terminal state: `Executed`, `Rejected`, or `Cancelled`.
    ///- the `proposal` is stale and not `Approved`.
    VaultBatchTransactionAccountClose,
    ///Closes Batch and the corresponding Proposal accounts for proposals in terminal states:
    ///`Executed`, `Rejected`, or `Cancelled` or stale proposals that aren't `Approved`.
    ///This instruction is only allowed to be executed when all `VaultBatchTransaction` accounts
    ///in the `batch` are already closed: `batch.size == 0`.
    BatchAccountsClose,
}
/// Parse instruction data based on 1-byte discriminator (non-Anchor contracts)
pub fn parse_instruction(data: &[u8]) -> Result<SquadsInstruction, std::io::Error> {
    if data.is_empty() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data is empty",
        ));
    }
    let discriminator = data[0];
    let mut ix_data = &data[1..];
    match discriminator {
        0u8 => {
            let args = ProgramConfigInitIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::ProgramConfigInit(args))
        }
        1u8 => {
            let args = ProgramConfigSetAuthorityIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::ProgramConfigSetAuthority(args))
        }
        2u8 => {
            let args = ProgramConfigSetMultisigCreationFeeIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::ProgramConfigSetMultisigCreationFee(args))
        }
        3u8 => {
            let args = ProgramConfigSetTreasuryIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::ProgramConfigSetTreasury(args))
        }
        4u8 => {
            let args = MultisigCreateIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::MultisigCreate(args))
        }
        5u8 => {
            let args = MultisigCreateV2IxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::MultisigCreateV2(args))
        }
        6u8 => {
            let args = MultisigAddMemberIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::MultisigAddMember(args))
        }
        7u8 => {
            let args = MultisigRemoveMemberIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::MultisigRemoveMember(args))
        }
        8u8 => {
            let args = MultisigSetTimeLockIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::MultisigSetTimeLock(args))
        }
        9u8 => {
            let args = MultisigChangeThresholdIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::MultisigChangeThreshold(args))
        }
        10u8 => {
            let args = MultisigSetConfigAuthorityIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::MultisigSetConfigAuthority(args))
        }
        11u8 => {
            let args = MultisigSetRentCollectorIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::MultisigSetRentCollector(args))
        }
        12u8 => {
            let args = MultisigAddSpendingLimitIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::MultisigAddSpendingLimit(args))
        }
        13u8 => {
            let args = MultisigRemoveSpendingLimitIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::MultisigRemoveSpendingLimit(args))
        }
        14u8 => {
            let args = ConfigTransactionCreateIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::ConfigTransactionCreate(args))
        }
        15u8 => Ok(SquadsInstruction::ConfigTransactionExecute),
        16u8 => {
            let args = VaultTransactionCreateIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::VaultTransactionCreate(args))
        }
        17u8 => Ok(SquadsInstruction::VaultTransactionExecute),
        18u8 => {
            let args = BatchCreateIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::BatchCreate(args))
        }
        19u8 => {
            let args = BatchAddTransactionIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::BatchAddTransaction(args))
        }
        20u8 => Ok(SquadsInstruction::BatchExecuteTransaction),
        21u8 => {
            let args = ProposalCreateIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::ProposalCreate(args))
        }
        22u8 => Ok(SquadsInstruction::ProposalActivate),
        23u8 => {
            let args = ProposalApproveIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::ProposalApprove(args))
        }
        24u8 => {
            let args = ProposalRejectIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::ProposalReject(args))
        }
        25u8 => {
            let args = ProposalCancelIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::ProposalCancel(args))
        }
        26u8 => {
            let args = SpendingLimitUseIxArgs::deserialize(&mut ix_data)?;
            Ok(SquadsInstruction::SpendingLimitUse(args))
        }
        27u8 => Ok(SquadsInstruction::ConfigTransactionAccountsClose),
        28u8 => Ok(SquadsInstruction::VaultTransactionAccountsClose),
        29u8 => Ok(SquadsInstruction::VaultBatchTransactionAccountClose),
        30u8 => Ok(SquadsInstruction::BatchAccountsClose),
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {}", discriminator),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_program_config_init_consistency() {
        let test_args = ProgramConfigInitIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&PROGRAM_CONFIG_INIT_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::ProgramConfigInit(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ProgramConfigInit)
                );
            }
        }
    }
    #[test]
    fn test_program_config_set_authority_consistency() {
        let test_args = ProgramConfigSetAuthorityIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&PROGRAM_CONFIG_SET_AUTHORITY_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::ProgramConfigSetAuthority(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ProgramConfigSetAuthority)
                );
            }
        }
    }
    #[test]
    fn test_program_config_set_multisig_creation_fee_consistency() {
        let test_args = ProgramConfigSetMultisigCreationFeeIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&PROGRAM_CONFIG_SET_MULTISIG_CREATION_FEE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::ProgramConfigSetMultisigCreationFee(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ProgramConfigSetMultisigCreationFee)
                );
            }
        }
    }
    #[test]
    fn test_program_config_set_treasury_consistency() {
        let test_args = ProgramConfigSetTreasuryIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&PROGRAM_CONFIG_SET_TREASURY_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::ProgramConfigSetTreasury(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ProgramConfigSetTreasury)
                );
            }
        }
    }
    #[test]
    fn test_multisig_create_consistency() {
        let test_args = MultisigCreateIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MULTISIG_CREATE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::MultisigCreate(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(MultisigCreate)
                );
            }
        }
    }
    #[test]
    fn test_multisig_create_v_2_consistency() {
        let test_args = MultisigCreateV2IxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MULTISIG_CREATE_V2_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::MultisigCreateV2(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(MultisigCreateV2)
                );
            }
        }
    }
    #[test]
    fn test_multisig_add_member_consistency() {
        let test_args = MultisigAddMemberIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MULTISIG_ADD_MEMBER_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::MultisigAddMember(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(MultisigAddMember)
                );
            }
        }
    }
    #[test]
    fn test_multisig_remove_member_consistency() {
        let test_args = MultisigRemoveMemberIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MULTISIG_REMOVE_MEMBER_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::MultisigRemoveMember(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(MultisigRemoveMember)
                );
            }
        }
    }
    #[test]
    fn test_multisig_set_time_lock_consistency() {
        let test_args = MultisigSetTimeLockIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MULTISIG_SET_TIME_LOCK_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::MultisigSetTimeLock(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(MultisigSetTimeLock)
                );
            }
        }
    }
    #[test]
    fn test_multisig_change_threshold_consistency() {
        let test_args = MultisigChangeThresholdIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MULTISIG_CHANGE_THRESHOLD_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::MultisigChangeThreshold(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(MultisigChangeThreshold)
                );
            }
        }
    }
    #[test]
    fn test_multisig_set_config_authority_consistency() {
        let test_args = MultisigSetConfigAuthorityIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MULTISIG_SET_CONFIG_AUTHORITY_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::MultisigSetConfigAuthority(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(MultisigSetConfigAuthority)
                );
            }
        }
    }
    #[test]
    fn test_multisig_set_rent_collector_consistency() {
        let test_args = MultisigSetRentCollectorIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MULTISIG_SET_RENT_COLLECTOR_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::MultisigSetRentCollector(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(MultisigSetRentCollector)
                );
            }
        }
    }
    #[test]
    fn test_multisig_add_spending_limit_consistency() {
        let test_args = MultisigAddSpendingLimitIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MULTISIG_ADD_SPENDING_LIMIT_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::MultisigAddSpendingLimit(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(MultisigAddSpendingLimit)
                );
            }
        }
    }
    #[test]
    fn test_multisig_remove_spending_limit_consistency() {
        let test_args = MultisigRemoveSpendingLimitIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MULTISIG_REMOVE_SPENDING_LIMIT_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::MultisigRemoveSpendingLimit(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(MultisigRemoveSpendingLimit)
                );
            }
        }
    }
    #[test]
    fn test_config_transaction_create_consistency() {
        let test_args = ConfigTransactionCreateIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CONFIG_TRANSACTION_CREATE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::ConfigTransactionCreate(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ConfigTransactionCreate)
                );
            }
        }
    }
    #[test]
    fn test_config_transaction_execute_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CONFIG_TRANSACTION_EXECUTE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            SquadsInstruction::ConfigTransactionExecute => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_vault_transaction_create_consistency() {
        let test_args = VaultTransactionCreateIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&VAULT_TRANSACTION_CREATE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::VaultTransactionCreate(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(VaultTransactionCreate)
                );
            }
        }
    }
    #[test]
    fn test_vault_transaction_execute_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&VAULT_TRANSACTION_EXECUTE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            SquadsInstruction::VaultTransactionExecute => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_batch_create_consistency() {
        let test_args = BatchCreateIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&BATCH_CREATE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::BatchCreate(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(BatchCreate)
                );
            }
        }
    }
    #[test]
    fn test_batch_add_transaction_consistency() {
        let test_args = BatchAddTransactionIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&BATCH_ADD_TRANSACTION_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::BatchAddTransaction(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(BatchAddTransaction)
                );
            }
        }
    }
    #[test]
    fn test_batch_execute_transaction_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&BATCH_EXECUTE_TRANSACTION_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            SquadsInstruction::BatchExecuteTransaction => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_proposal_create_consistency() {
        let test_args = ProposalCreateIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&PROPOSAL_CREATE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::ProposalCreate(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ProposalCreate)
                );
            }
        }
    }
    #[test]
    fn test_proposal_activate_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&PROPOSAL_ACTIVATE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            SquadsInstruction::ProposalActivate => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_proposal_approve_consistency() {
        let test_args = ProposalApproveIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&PROPOSAL_APPROVE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::ProposalApprove(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ProposalApprove)
                );
            }
        }
    }
    #[test]
    fn test_proposal_reject_consistency() {
        let test_args = ProposalRejectIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&PROPOSAL_REJECT_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::ProposalReject(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ProposalReject)
                );
            }
        }
    }
    #[test]
    fn test_proposal_cancel_consistency() {
        let test_args = ProposalCancelIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&PROPOSAL_CANCEL_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::ProposalCancel(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ProposalCancel)
                );
            }
        }
    }
    #[test]
    fn test_spending_limit_use_consistency() {
        let test_args = SpendingLimitUseIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SPENDING_LIMIT_USE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(SquadsInstruction::SpendingLimitUse(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SpendingLimitUse)
                );
            }
        }
    }
    #[test]
    fn test_config_transaction_accounts_close_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CONFIG_TRANSACTION_ACCOUNTS_CLOSE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            SquadsInstruction::ConfigTransactionAccountsClose => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_vault_transaction_accounts_close_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&VAULT_TRANSACTION_ACCOUNTS_CLOSE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            SquadsInstruction::VaultTransactionAccountsClose => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_vault_batch_transaction_account_close_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&VAULT_BATCH_TRANSACTION_ACCOUNT_CLOSE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            SquadsInstruction::VaultBatchTransactionAccountClose => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_batch_accounts_close_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&BATCH_ACCOUNTS_CLOSE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            SquadsInstruction::BatchAccountsClose => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_args = ProgramConfigInitIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ProgramConfigInitIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &PROGRAM_CONFIG_INIT_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::ProgramConfigInit(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, PROGRAM_CONFIG_INIT_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ProgramConfigInit)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ProgramConfigInit),
                    e
                );
            }
        }
        let test_args = ProgramConfigSetAuthorityIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ProgramConfigSetAuthorityIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &PROGRAM_CONFIG_SET_AUTHORITY_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::ProgramConfigSetAuthority(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, PROGRAM_CONFIG_SET_AUTHORITY_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ProgramConfigSetAuthority)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ProgramConfigSetAuthority),
                    e
                );
            }
        }
        let test_args = ProgramConfigSetMultisigCreationFeeIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ProgramConfigSetMultisigCreationFeeIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &PROGRAM_CONFIG_SET_MULTISIG_CREATION_FEE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::ProgramConfigSetMultisigCreationFee(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator,
                        PROGRAM_CONFIG_SET_MULTISIG_CREATION_FEE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ProgramConfigSetMultisigCreationFee)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ProgramConfigSetMultisigCreationFee),
                    e
                );
            }
        }
        let test_args = ProgramConfigSetTreasuryIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ProgramConfigSetTreasuryIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &PROGRAM_CONFIG_SET_TREASURY_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::ProgramConfigSetTreasury(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, PROGRAM_CONFIG_SET_TREASURY_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ProgramConfigSetTreasury)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ProgramConfigSetTreasury),
                    e
                );
            }
        }
        let test_args = MultisigCreateIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(MultisigCreateIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &MULTISIG_CREATE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::MultisigCreate(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, MULTISIG_CREATE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MultisigCreate)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MultisigCreate),
                    e
                );
            }
        }
        let test_args = MultisigCreateV2IxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(MultisigCreateV2IxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &MULTISIG_CREATE_V2_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::MultisigCreateV2(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, MULTISIG_CREATE_V2_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MultisigCreateV2)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MultisigCreateV2),
                    e
                );
            }
        }
        let test_args = MultisigAddMemberIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(MultisigAddMemberIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &MULTISIG_ADD_MEMBER_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::MultisigAddMember(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, MULTISIG_ADD_MEMBER_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MultisigAddMember)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MultisigAddMember),
                    e
                );
            }
        }
        let test_args = MultisigRemoveMemberIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(MultisigRemoveMemberIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &MULTISIG_REMOVE_MEMBER_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::MultisigRemoveMember(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, MULTISIG_REMOVE_MEMBER_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MultisigRemoveMember)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MultisigRemoveMember),
                    e
                );
            }
        }
        let test_args = MultisigSetTimeLockIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(MultisigSetTimeLockIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &MULTISIG_SET_TIME_LOCK_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::MultisigSetTimeLock(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, MULTISIG_SET_TIME_LOCK_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MultisigSetTimeLock)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MultisigSetTimeLock),
                    e
                );
            }
        }
        let test_args = MultisigChangeThresholdIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(MultisigChangeThresholdIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &MULTISIG_CHANGE_THRESHOLD_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::MultisigChangeThreshold(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, MULTISIG_CHANGE_THRESHOLD_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MultisigChangeThreshold)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MultisigChangeThreshold),
                    e
                );
            }
        }
        let test_args = MultisigSetConfigAuthorityIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(MultisigSetConfigAuthorityIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &MULTISIG_SET_CONFIG_AUTHORITY_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::MultisigSetConfigAuthority(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, MULTISIG_SET_CONFIG_AUTHORITY_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MultisigSetConfigAuthority)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MultisigSetConfigAuthority),
                    e
                );
            }
        }
        let test_args = MultisigSetRentCollectorIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(MultisigSetRentCollectorIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &MULTISIG_SET_RENT_COLLECTOR_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::MultisigSetRentCollector(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, MULTISIG_SET_RENT_COLLECTOR_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MultisigSetRentCollector)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MultisigSetRentCollector),
                    e
                );
            }
        }
        let test_args = MultisigAddSpendingLimitIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(MultisigAddSpendingLimitIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &MULTISIG_ADD_SPENDING_LIMIT_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::MultisigAddSpendingLimit(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, MULTISIG_ADD_SPENDING_LIMIT_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MultisigAddSpendingLimit)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MultisigAddSpendingLimit),
                    e
                );
            }
        }
        let test_args = MultisigRemoveSpendingLimitIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(MultisigRemoveSpendingLimitIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &MULTISIG_REMOVE_SPENDING_LIMIT_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::MultisigRemoveSpendingLimit(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, MULTISIG_REMOVE_SPENDING_LIMIT_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MultisigRemoveSpendingLimit)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MultisigRemoveSpendingLimit),
                    e
                );
            }
        }
        let test_args = ConfigTransactionCreateIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ConfigTransactionCreateIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CONFIG_TRANSACTION_CREATE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::ConfigTransactionCreate(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CONFIG_TRANSACTION_CREATE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ConfigTransactionCreate)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ConfigTransactionCreate),
                    e
                );
            }
        }
        let test_data = CONFIG_TRANSACTION_EXECUTE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::ConfigTransactionExecute => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ConfigTransactionExecute)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ConfigTransactionExecute),
                    e
                );
            }
        }
        let test_args = VaultTransactionCreateIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(VaultTransactionCreateIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &VAULT_TRANSACTION_CREATE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::VaultTransactionCreate(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, VAULT_TRANSACTION_CREATE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(VaultTransactionCreate)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(VaultTransactionCreate),
                    e
                );
            }
        }
        let test_data = VAULT_TRANSACTION_EXECUTE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::VaultTransactionExecute => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(VaultTransactionExecute)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(VaultTransactionExecute),
                    e
                );
            }
        }
        let test_args = BatchCreateIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(BatchCreateIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &BATCH_CREATE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::BatchCreate(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, BATCH_CREATE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(BatchCreate))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(BatchCreate),
                    e
                );
            }
        }
        let test_args = BatchAddTransactionIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(BatchAddTransactionIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &BATCH_ADD_TRANSACTION_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::BatchAddTransaction(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, BATCH_ADD_TRANSACTION_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(BatchAddTransaction)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(BatchAddTransaction),
                    e
                );
            }
        }
        let test_data = BATCH_EXECUTE_TRANSACTION_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::BatchExecuteTransaction => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(BatchExecuteTransaction)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(BatchExecuteTransaction),
                    e
                );
            }
        }
        let test_args = ProposalCreateIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ProposalCreateIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &PROPOSAL_CREATE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::ProposalCreate(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, PROPOSAL_CREATE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ProposalCreate)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ProposalCreate),
                    e
                );
            }
        }
        let test_data = PROPOSAL_ACTIVATE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::ProposalActivate => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ProposalActivate)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ProposalActivate),
                    e
                );
            }
        }
        let test_args = ProposalApproveIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ProposalApproveIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &PROPOSAL_APPROVE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::ProposalApprove(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, PROPOSAL_APPROVE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ProposalApprove)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ProposalApprove),
                    e
                );
            }
        }
        let test_args = ProposalRejectIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ProposalRejectIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &PROPOSAL_REJECT_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::ProposalReject(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, PROPOSAL_REJECT_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ProposalReject)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ProposalReject),
                    e
                );
            }
        }
        let test_args = ProposalCancelIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ProposalCancelIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &PROPOSAL_CANCEL_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::ProposalCancel(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, PROPOSAL_CANCEL_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ProposalCancel)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ProposalCancel),
                    e
                );
            }
        }
        let test_args = SpendingLimitUseIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SpendingLimitUseIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SPENDING_LIMIT_USE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::SpendingLimitUse(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SPENDING_LIMIT_USE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SpendingLimitUse)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SpendingLimitUse),
                    e
                );
            }
        }
        let test_data = CONFIG_TRANSACTION_ACCOUNTS_CLOSE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::ConfigTransactionAccountsClose => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ConfigTransactionAccountsClose)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ConfigTransactionAccountsClose),
                    e
                );
            }
        }
        let test_data = VAULT_TRANSACTION_ACCOUNTS_CLOSE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::VaultTransactionAccountsClose => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(VaultTransactionAccountsClose)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(VaultTransactionAccountsClose),
                    e
                );
            }
        }
        let test_data = VAULT_BATCH_TRANSACTION_ACCOUNT_CLOSE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::VaultBatchTransactionAccountClose => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(VaultBatchTransactionAccountClose)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(VaultBatchTransactionAccountClose),
                    e
                );
            }
        }
        let test_data = BATCH_ACCOUNTS_CLOSE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                SquadsInstruction::BatchAccountsClose => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(BatchAccountsClose)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(BatchAccountsClose),
                    e
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = parse_instruction(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = parse_instruction(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
