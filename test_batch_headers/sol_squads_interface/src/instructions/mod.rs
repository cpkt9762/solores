//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::*;
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::AccountInfo,
    entrypoint::ProgramResult,
    instruction::{AccountMeta, Instruction},
    program::{invoke, invoke_signed},
    pubkey::Pubkey,
};
fn invoke_instruction<'info, A: Into<[AccountInfo<'info>; N]>, const N: usize>(
    ix: &Instruction,
    accounts: A,
) -> ProgramResult {
    let account_info: [AccountInfo<'info>; N] = accounts.into();
    invoke(ix, &account_info)
}
fn invoke_instruction_signed<'info, A: Into<[AccountInfo<'info>; N]>, const N: usize>(
    ix: &Instruction,
    accounts: A,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let account_info: [AccountInfo<'info>; N] = accounts.into();
    invoke_signed(ix, &account_info, seeds)
}
pub mod program_config_init;
pub use program_config_init::*;
pub mod program_config_set_authority;
pub use program_config_set_authority::*;
pub mod program_config_set_multisig_creation_fee;
pub use program_config_set_multisig_creation_fee::*;
pub mod program_config_set_treasury;
pub use program_config_set_treasury::*;
pub mod multisig_create;
pub use multisig_create::*;
pub mod multisig_create_v2;
pub use multisig_create_v2::*;
pub mod multisig_add_member;
pub use multisig_add_member::*;
pub mod multisig_remove_member;
pub use multisig_remove_member::*;
pub mod multisig_set_time_lock;
pub use multisig_set_time_lock::*;
pub mod multisig_change_threshold;
pub use multisig_change_threshold::*;
pub mod multisig_set_config_authority;
pub use multisig_set_config_authority::*;
pub mod multisig_set_rent_collector;
pub use multisig_set_rent_collector::*;
pub mod multisig_add_spending_limit;
pub use multisig_add_spending_limit::*;
pub mod multisig_remove_spending_limit;
pub use multisig_remove_spending_limit::*;
pub mod config_transaction_create;
pub use config_transaction_create::*;
pub mod config_transaction_execute;
pub use config_transaction_execute::*;
pub mod vault_transaction_create;
pub use vault_transaction_create::*;
pub mod vault_transaction_execute;
pub use vault_transaction_execute::*;
pub mod batch_create;
pub use batch_create::*;
pub mod batch_add_transaction;
pub use batch_add_transaction::*;
pub mod batch_execute_transaction;
pub use batch_execute_transaction::*;
pub mod proposal_create;
pub use proposal_create::*;
pub mod proposal_activate;
pub use proposal_activate::*;
pub mod proposal_approve;
pub use proposal_approve::*;
pub mod proposal_reject;
pub use proposal_reject::*;
pub mod proposal_cancel;
pub use proposal_cancel::*;
pub mod spending_limit_use;
pub use spending_limit_use::*;
pub mod config_transaction_accounts_close;
pub use config_transaction_accounts_close::*;
pub mod vault_transaction_accounts_close;
pub use vault_transaction_accounts_close::*;
pub mod vault_batch_transaction_account_close;
pub use vault_batch_transaction_account_close::*;
pub mod batch_accounts_close;
pub use batch_accounts_close::*;
#[derive(Clone, Debug, PartialEq)]
pub enum SquadsProgramIx {
    ProgramConfigInit(ProgramConfigInitIxArgs),
    ProgramConfigSetAuthority(ProgramConfigSetAuthorityIxArgs),
    ProgramConfigSetMultisigCreationFee(ProgramConfigSetMultisigCreationFeeIxArgs),
    ProgramConfigSetTreasury(ProgramConfigSetTreasuryIxArgs),
    MultisigCreate(MultisigCreateIxArgs),
    MultisigCreateV2(MultisigCreateV2IxArgs),
    MultisigAddMember(MultisigAddMemberIxArgs),
    MultisigRemoveMember(MultisigRemoveMemberIxArgs),
    MultisigSetTimeLock(MultisigSetTimeLockIxArgs),
    MultisigChangeThreshold(MultisigChangeThresholdIxArgs),
    MultisigSetConfigAuthority(MultisigSetConfigAuthorityIxArgs),
    MultisigSetRentCollector(MultisigSetRentCollectorIxArgs),
    MultisigAddSpendingLimit(MultisigAddSpendingLimitIxArgs),
    MultisigRemoveSpendingLimit(MultisigRemoveSpendingLimitIxArgs),
    ConfigTransactionCreate(ConfigTransactionCreateIxArgs),
    ConfigTransactionExecute,
    VaultTransactionCreate(VaultTransactionCreateIxArgs),
    VaultTransactionExecute,
    BatchCreate(BatchCreateIxArgs),
    BatchAddTransaction(BatchAddTransactionIxArgs),
    BatchExecuteTransaction,
    ProposalCreate(ProposalCreateIxArgs),
    ProposalActivate,
    ProposalApprove(ProposalApproveIxArgs),
    ProposalReject(ProposalRejectIxArgs),
    ProposalCancel(ProposalCancelIxArgs),
    SpendingLimitUse(SpendingLimitUseIxArgs),
    ConfigTransactionAccountsClose,
    VaultTransactionAccountsClose,
    VaultBatchTransactionAccountClose,
    BatchAccountsClose,
}
impl SquadsProgramIx {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        if buf.is_empty() {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Instruction data is empty",
            ));
        }
        let maybe_discm = buf[0];
        let mut reader = &buf[1..];
        match maybe_discm {
            PROGRAM_CONFIG_INIT_IX_DISCM => Ok(Self::ProgramConfigInit(
                ProgramConfigInitIxArgs::deserialize(&mut reader)?,
            )),
            PROGRAM_CONFIG_SET_AUTHORITY_IX_DISCM => Ok(Self::ProgramConfigSetAuthority(
                ProgramConfigSetAuthorityIxArgs::deserialize(&mut reader)?,
            )),
            PROGRAM_CONFIG_SET_MULTISIG_CREATION_FEE_IX_DISCM => {
                Ok(Self::ProgramConfigSetMultisigCreationFee(
                    ProgramConfigSetMultisigCreationFeeIxArgs::deserialize(&mut reader)?,
                ))
            }
            PROGRAM_CONFIG_SET_TREASURY_IX_DISCM => Ok(Self::ProgramConfigSetTreasury(
                ProgramConfigSetTreasuryIxArgs::deserialize(&mut reader)?,
            )),
            MULTISIG_CREATE_IX_DISCM => Ok(Self::MultisigCreate(
                MultisigCreateIxArgs::deserialize(&mut reader)?,
            )),
            MULTISIG_CREATE_V2_IX_DISCM => Ok(Self::MultisigCreateV2(
                MultisigCreateV2IxArgs::deserialize(&mut reader)?,
            )),
            MULTISIG_ADD_MEMBER_IX_DISCM => Ok(Self::MultisigAddMember(
                MultisigAddMemberIxArgs::deserialize(&mut reader)?,
            )),
            MULTISIG_REMOVE_MEMBER_IX_DISCM => Ok(Self::MultisigRemoveMember(
                MultisigRemoveMemberIxArgs::deserialize(&mut reader)?,
            )),
            MULTISIG_SET_TIME_LOCK_IX_DISCM => Ok(Self::MultisigSetTimeLock(
                MultisigSetTimeLockIxArgs::deserialize(&mut reader)?,
            )),
            MULTISIG_CHANGE_THRESHOLD_IX_DISCM => Ok(Self::MultisigChangeThreshold(
                MultisigChangeThresholdIxArgs::deserialize(&mut reader)?,
            )),
            MULTISIG_SET_CONFIG_AUTHORITY_IX_DISCM => Ok(Self::MultisigSetConfigAuthority(
                MultisigSetConfigAuthorityIxArgs::deserialize(&mut reader)?,
            )),
            MULTISIG_SET_RENT_COLLECTOR_IX_DISCM => Ok(Self::MultisigSetRentCollector(
                MultisigSetRentCollectorIxArgs::deserialize(&mut reader)?,
            )),
            MULTISIG_ADD_SPENDING_LIMIT_IX_DISCM => Ok(Self::MultisigAddSpendingLimit(
                MultisigAddSpendingLimitIxArgs::deserialize(&mut reader)?,
            )),
            MULTISIG_REMOVE_SPENDING_LIMIT_IX_DISCM => Ok(Self::MultisigRemoveSpendingLimit(
                MultisigRemoveSpendingLimitIxArgs::deserialize(&mut reader)?,
            )),
            CONFIG_TRANSACTION_CREATE_IX_DISCM => Ok(Self::ConfigTransactionCreate(
                ConfigTransactionCreateIxArgs::deserialize(&mut reader)?,
            )),
            CONFIG_TRANSACTION_EXECUTE_IX_DISCM => Ok(Self::ConfigTransactionExecute),
            VAULT_TRANSACTION_CREATE_IX_DISCM => Ok(Self::VaultTransactionCreate(
                VaultTransactionCreateIxArgs::deserialize(&mut reader)?,
            )),
            VAULT_TRANSACTION_EXECUTE_IX_DISCM => Ok(Self::VaultTransactionExecute),
            BATCH_CREATE_IX_DISCM => Ok(Self::BatchCreate(BatchCreateIxArgs::deserialize(
                &mut reader,
            )?)),
            BATCH_ADD_TRANSACTION_IX_DISCM => Ok(Self::BatchAddTransaction(
                BatchAddTransactionIxArgs::deserialize(&mut reader)?,
            )),
            BATCH_EXECUTE_TRANSACTION_IX_DISCM => Ok(Self::BatchExecuteTransaction),
            PROPOSAL_CREATE_IX_DISCM => Ok(Self::ProposalCreate(
                ProposalCreateIxArgs::deserialize(&mut reader)?,
            )),
            PROPOSAL_ACTIVATE_IX_DISCM => Ok(Self::ProposalActivate),
            PROPOSAL_APPROVE_IX_DISCM => Ok(Self::ProposalApprove(
                ProposalApproveIxArgs::deserialize(&mut reader)?,
            )),
            PROPOSAL_REJECT_IX_DISCM => Ok(Self::ProposalReject(
                ProposalRejectIxArgs::deserialize(&mut reader)?,
            )),
            PROPOSAL_CANCEL_IX_DISCM => Ok(Self::ProposalCancel(
                ProposalCancelIxArgs::deserialize(&mut reader)?,
            )),
            SPENDING_LIMIT_USE_IX_DISCM => Ok(Self::SpendingLimitUse(
                SpendingLimitUseIxArgs::deserialize(&mut reader)?,
            )),
            CONFIG_TRANSACTION_ACCOUNTS_CLOSE_IX_DISCM => Ok(Self::ConfigTransactionAccountsClose),
            VAULT_TRANSACTION_ACCOUNTS_CLOSE_IX_DISCM => Ok(Self::VaultTransactionAccountsClose),
            VAULT_BATCH_TRANSACTION_ACCOUNT_CLOSE_IX_DISCM => {
                Ok(Self::VaultBatchTransactionAccountClose)
            }
            BATCH_ACCOUNTS_CLOSE_IX_DISCM => Ok(Self::BatchAccountsClose),
            _ => Err(std::io::Error::new(
                std::io::ErrorKind::Other,
                format!("discm {} not found", maybe_discm),
            )),
        }
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        match self {
            Self::ProgramConfigInit(args) => {
                writer.write_all(&[PROGRAM_CONFIG_INIT_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::ProgramConfigSetAuthority(args) => {
                writer.write_all(&[PROGRAM_CONFIG_SET_AUTHORITY_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::ProgramConfigSetMultisigCreationFee(args) => {
                writer.write_all(&[PROGRAM_CONFIG_SET_MULTISIG_CREATION_FEE_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::ProgramConfigSetTreasury(args) => {
                writer.write_all(&[PROGRAM_CONFIG_SET_TREASURY_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::MultisigCreate(args) => {
                writer.write_all(&[MULTISIG_CREATE_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::MultisigCreateV2(args) => {
                writer.write_all(&[MULTISIG_CREATE_V2_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::MultisigAddMember(args) => {
                writer.write_all(&[MULTISIG_ADD_MEMBER_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::MultisigRemoveMember(args) => {
                writer.write_all(&[MULTISIG_REMOVE_MEMBER_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::MultisigSetTimeLock(args) => {
                writer.write_all(&[MULTISIG_SET_TIME_LOCK_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::MultisigChangeThreshold(args) => {
                writer.write_all(&[MULTISIG_CHANGE_THRESHOLD_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::MultisigSetConfigAuthority(args) => {
                writer.write_all(&[MULTISIG_SET_CONFIG_AUTHORITY_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::MultisigSetRentCollector(args) => {
                writer.write_all(&[MULTISIG_SET_RENT_COLLECTOR_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::MultisigAddSpendingLimit(args) => {
                writer.write_all(&[MULTISIG_ADD_SPENDING_LIMIT_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::MultisigRemoveSpendingLimit(args) => {
                writer.write_all(&[MULTISIG_REMOVE_SPENDING_LIMIT_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::ConfigTransactionCreate(args) => {
                writer.write_all(&[CONFIG_TRANSACTION_CREATE_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::ConfigTransactionExecute => {
                writer.write_all(&[CONFIG_TRANSACTION_EXECUTE_IX_DISCM])
            }
            Self::VaultTransactionCreate(args) => {
                writer.write_all(&[VAULT_TRANSACTION_CREATE_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::VaultTransactionExecute => {
                writer.write_all(&[VAULT_TRANSACTION_EXECUTE_IX_DISCM])
            }
            Self::BatchCreate(args) => {
                writer.write_all(&[BATCH_CREATE_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::BatchAddTransaction(args) => {
                writer.write_all(&[BATCH_ADD_TRANSACTION_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::BatchExecuteTransaction => {
                writer.write_all(&[BATCH_EXECUTE_TRANSACTION_IX_DISCM])
            }
            Self::ProposalCreate(args) => {
                writer.write_all(&[PROPOSAL_CREATE_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::ProposalActivate => writer.write_all(&[PROPOSAL_ACTIVATE_IX_DISCM]),
            Self::ProposalApprove(args) => {
                writer.write_all(&[PROPOSAL_APPROVE_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::ProposalReject(args) => {
                writer.write_all(&[PROPOSAL_REJECT_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::ProposalCancel(args) => {
                writer.write_all(&[PROPOSAL_CANCEL_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::SpendingLimitUse(args) => {
                writer.write_all(&[SPENDING_LIMIT_USE_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::ConfigTransactionAccountsClose => {
                writer.write_all(&[CONFIG_TRANSACTION_ACCOUNTS_CLOSE_IX_DISCM])
            }
            Self::VaultTransactionAccountsClose => {
                writer.write_all(&[VAULT_TRANSACTION_ACCOUNTS_CLOSE_IX_DISCM])
            }
            Self::VaultBatchTransactionAccountClose => {
                writer.write_all(&[VAULT_BATCH_TRANSACTION_ACCOUNT_CLOSE_IX_DISCM])
            }
            Self::BatchAccountsClose => writer.write_all(&[BATCH_ACCOUNTS_CLOSE_IX_DISCM]),
        }
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
