//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::*;
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::AccountInfo,
    entrypoint::ProgramResult,
    instruction::{AccountMeta, Instruction},
    program::{invoke, invoke_signed},
    pubkey::Pubkey,
};
fn invoke_instruction<'info, A: Into<[AccountInfo<'info>; N]>, const N: usize>(
    ix: &Instruction,
    accounts: A,
) -> ProgramResult {
    let account_info: [AccountInfo<'info>; N] = accounts.into();
    invoke(ix, &account_info)
}
fn invoke_instruction_signed<'info, A: Into<[AccountInfo<'info>; N]>, const N: usize>(
    ix: &Instruction,
    accounts: A,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let account_info: [AccountInfo<'info>; N] = accounts.into();
    invoke_signed(ix, &account_info, seeds)
}
pub mod token_mint;
pub use token_mint::*;
pub mod buy;
pub use buy::*;
pub mod sell;
pub use sell::*;
pub mod migrate_funds;
pub use migrate_funds::*;
pub mod config_init;
pub use config_init::*;
pub mod config_update;
pub use config_update::*;
#[derive(Clone, Debug, PartialEq)]
pub enum MoonshotProgramIx {
    TokenMint(TokenMintIxArgs),
    Buy(BuyIxArgs),
    Sell(SellIxArgs),
    MigrateFunds,
    ConfigInit(ConfigInitIxArgs),
    ConfigUpdate(ConfigUpdateIxArgs),
}
impl MoonshotProgramIx {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        if buf.is_empty() {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Instruction data is empty",
            ));
        }
        let maybe_discm = buf[0];
        let mut reader = &buf[1..];
        match maybe_discm {
            TOKEN_MINT_IX_DISCM => Ok(Self::TokenMint(TokenMintIxArgs::deserialize(&mut reader)?)),
            BUY_IX_DISCM => Ok(Self::Buy(BuyIxArgs::deserialize(&mut reader)?)),
            SELL_IX_DISCM => Ok(Self::Sell(SellIxArgs::deserialize(&mut reader)?)),
            MIGRATE_FUNDS_IX_DISCM => Ok(Self::MigrateFunds),
            CONFIG_INIT_IX_DISCM => Ok(Self::ConfigInit(ConfigInitIxArgs::deserialize(
                &mut reader,
            )?)),
            CONFIG_UPDATE_IX_DISCM => Ok(Self::ConfigUpdate(ConfigUpdateIxArgs::deserialize(
                &mut reader,
            )?)),
            _ => Err(std::io::Error::new(
                std::io::ErrorKind::Other,
                format!("discm {} not found", maybe_discm),
            )),
        }
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        match self {
            Self::TokenMint(args) => {
                writer.write_all(&[TOKEN_MINT_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::Buy(args) => {
                writer.write_all(&[BUY_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::Sell(args) => {
                writer.write_all(&[SELL_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::MigrateFunds => writer.write_all(&[MIGRATE_FUNDS_IX_DISCM]),
            Self::ConfigInit(args) => {
                writer.write_all(&[CONFIG_INIT_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::ConfigUpdate(args) => {
                writer.write_all(&[CONFIG_UPDATE_IX_DISCM])?;
                args.serialize(&mut writer)
            }
        }
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
