//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::accounts::*;
/// Program account types
#[derive(Clone, Debug, PartialEq)]
pub enum MeteoraDlmmAccount {
    BinArrayBitmapExtension(BinArrayBitmapExtension),
    ///An account to contain a range of bin. For example: Bin 100 <-> 200.
    ///For example:
    ///BinArray index: 0 contains bin 0 <-> 599
    ///index: 2 contains bin 600 <-> 1199, ...
    BinArray(BinArray),
    LbPair(LbPair),
    Oracle(Oracle),
    Position(Position),
    PositionV2(PositionV2),
    PresetParameter(PresetParameter),
}
/// Parse account data based on data length (non-Anchor contracts)
pub fn try_unpack_account(data: &[u8]) -> Result<MeteoraDlmmAccount, std::io::Error> {
    let data_len = data.len();
    const BIN_ARRAY_BITMAP_EXTENSION_LEN: usize = std::mem::size_of::<BinArrayBitmapExtension>();
    const BIN_ARRAY_LEN: usize = std::mem::size_of::<BinArray>();
    const LB_PAIR_LEN: usize = std::mem::size_of::<LbPair>();
    const ORACLE_LEN: usize = std::mem::size_of::<Oracle>();
    const POSITION_LEN: usize = std::mem::size_of::<Position>();
    const POSITION_V2_LEN: usize = std::mem::size_of::<PositionV2>();
    const PRESET_PARAMETER_LEN: usize = std::mem::size_of::<PresetParameter>();
    match data_len {
        BIN_ARRAY_BITMAP_EXTENSION_LEN => Ok(MeteoraDlmmAccount::BinArrayBitmapExtension(
            BinArrayBitmapExtension::from_bytes(data)?,
        )),
        BIN_ARRAY_LEN => Ok(MeteoraDlmmAccount::BinArray(BinArray::from_bytes(data)?)),
        LB_PAIR_LEN => Ok(MeteoraDlmmAccount::LbPair(LbPair::from_bytes(data)?)),
        ORACLE_LEN => Ok(MeteoraDlmmAccount::Oracle(Oracle::from_bytes(data)?)),
        POSITION_LEN => Ok(MeteoraDlmmAccount::Position(Position::from_bytes(data)?)),
        POSITION_V2_LEN => Ok(MeteoraDlmmAccount::PositionV2(PositionV2::from_bytes(
            data,
        )?)),
        PRESET_PARAMETER_LEN => Ok(MeteoraDlmmAccount::PresetParameter(
            PresetParameter::from_bytes(data)?,
        )),
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Invalid Account data length: {}", data_len),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    use borsh::{BorshDeserialize, BorshSerialize};
    #[test]
    fn test_bin_array_bitmap_extension_consistency() {
        let expected_first_field = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_account = BinArrayBitmapExtension {
            lb_pair: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(MeteoraDlmmAccount::BinArrayBitmapExtension(account)) => {
                assert_eq!(
                    account.lb_pair, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [80u8, 111u8, 124u8, 113u8, 55u8, 237u8, 18u8, 5u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(BinArrayBitmapExtension)
                );
            }
        }
    }
    #[test]
    fn test_bin_array_consistency() {
        let expected_first_field = 42i64;
        let test_account = BinArray {
            index: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(MeteoraDlmmAccount::BinArray(account)) => {
                assert_eq!(
                    account.index, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [92u8, 142u8, 92u8, 220u8, 5u8, 148u8, 70u8, 181u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(BinArray)
                );
            }
        }
    }
    #[test]
    fn test_lb_pair_consistency() {
        let expected_first_field = Default::default();
        let test_account = LbPair {
            parameters: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(MeteoraDlmmAccount::LbPair(account)) => {
                assert_eq!(
                    account.discriminator,
                    [33u8, 11u8, 49u8, 98u8, 181u8, 101u8, 177u8, 13u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(LbPair)
                );
            }
        }
    }
    #[test]
    fn test_oracle_consistency() {
        let expected_first_field = 42u64;
        let test_account = Oracle {
            idx: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(MeteoraDlmmAccount::Oracle(account)) => {
                assert_eq!(
                    account.idx, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [139u8, 194u8, 131u8, 179u8, 140u8, 179u8, 229u8, 244u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Oracle)
                );
            }
        }
    }
    #[test]
    fn test_position_consistency() {
        let expected_first_field = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_account = Position {
            lb_pair: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(MeteoraDlmmAccount::Position(account)) => {
                assert_eq!(
                    account.lb_pair, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [170u8, 188u8, 143u8, 228u8, 122u8, 64u8, 247u8, 208u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Position)
                );
            }
        }
    }
    #[test]
    fn test_position_v_2_consistency() {
        let expected_first_field = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_account = PositionV2 {
            lb_pair: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(MeteoraDlmmAccount::PositionV2(account)) => {
                assert_eq!(
                    account.lb_pair, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [117u8, 176u8, 212u8, 199u8, 245u8, 180u8, 133u8, 182u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(PositionV2)
                );
            }
        }
    }
    #[test]
    fn test_preset_parameter_consistency() {
        let expected_first_field = 42u16;
        let test_account = PresetParameter {
            bin_step: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(MeteoraDlmmAccount::PresetParameter(account)) => {
                assert_eq!(
                    account.bin_step, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [242u8, 62u8, 244u8, 34u8, 181u8, 112u8, 58u8, 170u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(PresetParameter)
                );
            }
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_account = BinArrayBitmapExtension::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            BinArrayBitmapExtension::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(BinArrayBitmapExtension)
                );
            }
        }
        let test_account = BinArray::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            BinArray::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(BinArray)
                );
            }
        }
        let test_account = LbPair::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            LbPair::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(LbPair)
                );
            }
        }
        let test_account = Oracle::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            Oracle::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(Oracle)
                );
            }
        }
        let test_account = Position::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            Position::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(Position)
                );
            }
        }
        let test_account = PositionV2::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            PositionV2::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(PositionV2)
                );
            }
        }
        let test_account = PresetParameter::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            PresetParameter::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(PresetParameter)
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = try_unpack_account(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = try_unpack_account(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
