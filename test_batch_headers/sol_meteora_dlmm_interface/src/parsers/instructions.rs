//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::instructions::*;
pub const INITIALIZE_LB_PAIR_IX_DISCM: u8 = 0u8;
pub const INITIALIZE_PERMISSION_LB_PAIR_IX_DISCM: u8 = 1u8;
pub const INITIALIZE_CUSTOMIZABLE_PERMISSIONLESS_LB_PAIR_IX_DISCM: u8 = 2u8;
pub const INITIALIZE_BIN_ARRAY_BITMAP_EXTENSION_IX_DISCM: u8 = 3u8;
pub const INITIALIZE_BIN_ARRAY_IX_DISCM: u8 = 4u8;
pub const ADD_LIQUIDITY_IX_DISCM: u8 = 5u8;
pub const ADD_LIQUIDITY_BY_WEIGHT_IX_DISCM: u8 = 6u8;
pub const ADD_LIQUIDITY_BY_STRATEGY_IX_DISCM: u8 = 7u8;
pub const ADD_LIQUIDITY_BY_STRATEGY_ONE_SIDE_IX_DISCM: u8 = 8u8;
pub const ADD_LIQUIDITY_ONE_SIDE_IX_DISCM: u8 = 9u8;
pub const REMOVE_LIQUIDITY_IX_DISCM: u8 = 10u8;
pub const INITIALIZE_POSITION_IX_DISCM: u8 = 11u8;
pub const INITIALIZE_POSITION_PDA_IX_DISCM: u8 = 12u8;
pub const INITIALIZE_POSITION_BY_OPERATOR_IX_DISCM: u8 = 13u8;
pub const UPDATE_POSITION_OPERATOR_IX_DISCM: u8 = 14u8;
pub const SWAP_IX_DISCM: u8 = 15u8;
pub const SWAP_EXACT_OUT_IX_DISCM: u8 = 16u8;
pub const SWAP_WITH_PRICE_IMPACT_IX_DISCM: u8 = 17u8;
pub const WITHDRAW_PROTOCOL_FEE_IX_DISCM: u8 = 18u8;
pub const INITIALIZE_REWARD_IX_DISCM: u8 = 19u8;
pub const FUND_REWARD_IX_DISCM: u8 = 20u8;
pub const UPDATE_REWARD_FUNDER_IX_DISCM: u8 = 21u8;
pub const UPDATE_REWARD_DURATION_IX_DISCM: u8 = 22u8;
pub const CLAIM_REWARD_IX_DISCM: u8 = 23u8;
pub const CLAIM_FEE_IX_DISCM: u8 = 24u8;
pub const CLOSE_POSITION_IX_DISCM: u8 = 25u8;
pub const UPDATE_FEE_PARAMETERS_IX_DISCM: u8 = 26u8;
pub const INCREASE_ORACLE_LENGTH_IX_DISCM: u8 = 27u8;
pub const INITIALIZE_PRESET_PARAMETER_IX_DISCM: u8 = 28u8;
pub const CLOSE_PRESET_PARAMETER_IX_DISCM: u8 = 29u8;
pub const REMOVE_ALL_LIQUIDITY_IX_DISCM: u8 = 30u8;
pub const TOGGLE_PAIR_STATUS_IX_DISCM: u8 = 31u8;
pub const MIGRATE_POSITION_IX_DISCM: u8 = 32u8;
pub const MIGRATE_BIN_ARRAY_IX_DISCM: u8 = 33u8;
pub const UPDATE_FEES_AND_REWARDS_IX_DISCM: u8 = 34u8;
pub const WITHDRAW_INELIGIBLE_REWARD_IX_DISCM: u8 = 35u8;
pub const SET_ACTIVATION_POINT_IX_DISCM: u8 = 36u8;
pub const REMOVE_LIQUIDITY_BY_RANGE_IX_DISCM: u8 = 37u8;
pub const ADD_LIQUIDITY_ONE_SIDE_PRECISE_IX_DISCM: u8 = 38u8;
pub const GO_TO_A_BIN_IX_DISCM: u8 = 39u8;
pub const SET_PRE_ACTIVATION_DURATION_IX_DISCM: u8 = 40u8;
pub const SET_PRE_ACTIVATION_SWAP_ADDRESS_IX_DISCM: u8 = 41u8;
/// Program instruction types
#[derive(Clone, Debug, PartialEq)]
pub enum MeteoraDlmmInstruction {
    InitializeLbPair(InitializeLbPairIxArgs),
    InitializePermissionLbPair(InitializePermissionLbPairIxArgs),
    InitializeCustomizablePermissionlessLbPair(InitializeCustomizablePermissionlessLbPairIxArgs),
    InitializeBinArrayBitmapExtension,
    InitializeBinArray(InitializeBinArrayIxArgs),
    AddLiquidity(AddLiquidityIxArgs),
    AddLiquidityByWeight(AddLiquidityByWeightIxArgs),
    AddLiquidityByStrategy(AddLiquidityByStrategyIxArgs),
    AddLiquidityByStrategyOneSide(AddLiquidityByStrategyOneSideIxArgs),
    AddLiquidityOneSide(AddLiquidityOneSideIxArgs),
    RemoveLiquidity(RemoveLiquidityIxArgs),
    InitializePosition(InitializePositionIxArgs),
    InitializePositionPda(InitializePositionPdaIxArgs),
    InitializePositionByOperator(InitializePositionByOperatorIxArgs),
    UpdatePositionOperator(UpdatePositionOperatorIxArgs),
    Swap(SwapIxArgs),
    SwapExactOut(SwapExactOutIxArgs),
    SwapWithPriceImpact(SwapWithPriceImpactIxArgs),
    WithdrawProtocolFee(WithdrawProtocolFeeIxArgs),
    InitializeReward(InitializeRewardIxArgs),
    FundReward(FundRewardIxArgs),
    UpdateRewardFunder(UpdateRewardFunderIxArgs),
    UpdateRewardDuration(UpdateRewardDurationIxArgs),
    ClaimReward(ClaimRewardIxArgs),
    ClaimFee,
    ClosePosition,
    UpdateFeeParameters(UpdateFeeParametersIxArgs),
    IncreaseOracleLength(IncreaseOracleLengthIxArgs),
    InitializePresetParameter(InitializePresetParameterIxArgs),
    ClosePresetParameter,
    RemoveAllLiquidity,
    TogglePairStatus,
    MigratePosition,
    MigrateBinArray,
    UpdateFeesAndRewards,
    WithdrawIneligibleReward(WithdrawIneligibleRewardIxArgs),
    SetActivationPoint(SetActivationPointIxArgs),
    RemoveLiquidityByRange(RemoveLiquidityByRangeIxArgs),
    AddLiquidityOneSidePrecise(AddLiquidityOneSidePreciseIxArgs),
    GoToABin(GoToABinIxArgs),
    SetPreActivationDuration(SetPreActivationDurationIxArgs),
    SetPreActivationSwapAddress(SetPreActivationSwapAddressIxArgs),
}
/// Parse instruction data based on 1-byte discriminator (non-Anchor contracts)
pub fn parse_instruction(data: &[u8]) -> Result<MeteoraDlmmInstruction, std::io::Error> {
    if data.is_empty() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data is empty",
        ));
    }
    let discriminator = data[0];
    let mut ix_data = &data[1..];
    match discriminator {
        0u8 => {
            let args = InitializeLbPairIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::InitializeLbPair(args))
        }
        1u8 => {
            let args = InitializePermissionLbPairIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::InitializePermissionLbPair(args))
        }
        2u8 => {
            let args = InitializeCustomizablePermissionlessLbPairIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::InitializeCustomizablePermissionlessLbPair(args))
        }
        3u8 => Ok(MeteoraDlmmInstruction::InitializeBinArrayBitmapExtension),
        4u8 => {
            let args = InitializeBinArrayIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::InitializeBinArray(args))
        }
        5u8 => {
            let args = AddLiquidityIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::AddLiquidity(args))
        }
        6u8 => {
            let args = AddLiquidityByWeightIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::AddLiquidityByWeight(args))
        }
        7u8 => {
            let args = AddLiquidityByStrategyIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::AddLiquidityByStrategy(args))
        }
        8u8 => {
            let args = AddLiquidityByStrategyOneSideIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::AddLiquidityByStrategyOneSide(args))
        }
        9u8 => {
            let args = AddLiquidityOneSideIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::AddLiquidityOneSide(args))
        }
        10u8 => {
            let args = RemoveLiquidityIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::RemoveLiquidity(args))
        }
        11u8 => {
            let args = InitializePositionIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::InitializePosition(args))
        }
        12u8 => {
            let args = InitializePositionPdaIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::InitializePositionPda(args))
        }
        13u8 => {
            let args = InitializePositionByOperatorIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::InitializePositionByOperator(args))
        }
        14u8 => {
            let args = UpdatePositionOperatorIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::UpdatePositionOperator(args))
        }
        15u8 => {
            let args = SwapIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::Swap(args))
        }
        16u8 => {
            let args = SwapExactOutIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::SwapExactOut(args))
        }
        17u8 => {
            let args = SwapWithPriceImpactIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::SwapWithPriceImpact(args))
        }
        18u8 => {
            let args = WithdrawProtocolFeeIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::WithdrawProtocolFee(args))
        }
        19u8 => {
            let args = InitializeRewardIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::InitializeReward(args))
        }
        20u8 => {
            let args = FundRewardIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::FundReward(args))
        }
        21u8 => {
            let args = UpdateRewardFunderIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::UpdateRewardFunder(args))
        }
        22u8 => {
            let args = UpdateRewardDurationIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::UpdateRewardDuration(args))
        }
        23u8 => {
            let args = ClaimRewardIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::ClaimReward(args))
        }
        24u8 => Ok(MeteoraDlmmInstruction::ClaimFee),
        25u8 => Ok(MeteoraDlmmInstruction::ClosePosition),
        26u8 => {
            let args = UpdateFeeParametersIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::UpdateFeeParameters(args))
        }
        27u8 => {
            let args = IncreaseOracleLengthIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::IncreaseOracleLength(args))
        }
        28u8 => {
            let args = InitializePresetParameterIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::InitializePresetParameter(args))
        }
        29u8 => Ok(MeteoraDlmmInstruction::ClosePresetParameter),
        30u8 => Ok(MeteoraDlmmInstruction::RemoveAllLiquidity),
        31u8 => Ok(MeteoraDlmmInstruction::TogglePairStatus),
        32u8 => Ok(MeteoraDlmmInstruction::MigratePosition),
        33u8 => Ok(MeteoraDlmmInstruction::MigrateBinArray),
        34u8 => Ok(MeteoraDlmmInstruction::UpdateFeesAndRewards),
        35u8 => {
            let args = WithdrawIneligibleRewardIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::WithdrawIneligibleReward(args))
        }
        36u8 => {
            let args = SetActivationPointIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::SetActivationPoint(args))
        }
        37u8 => {
            let args = RemoveLiquidityByRangeIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::RemoveLiquidityByRange(args))
        }
        38u8 => {
            let args = AddLiquidityOneSidePreciseIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::AddLiquidityOneSidePrecise(args))
        }
        39u8 => {
            let args = GoToABinIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::GoToABin(args))
        }
        40u8 => {
            let args = SetPreActivationDurationIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::SetPreActivationDuration(args))
        }
        41u8 => {
            let args = SetPreActivationSwapAddressIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDlmmInstruction::SetPreActivationSwapAddress(args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {}", discriminator),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_initialize_lb_pair_consistency() {
        let expected_first_arg = 1000i32;
        let test_args = InitializeLbPairIxArgs {
            active_id: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_LB_PAIR_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::InitializeLbPair(args)) => {
                assert_eq!(
                    args.active_id, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializeLbPair)
                );
            }
        }
    }
    #[test]
    fn test_initialize_permission_lb_pair_consistency() {
        let test_args = InitializePermissionLbPairIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_PERMISSION_LB_PAIR_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::InitializePermissionLbPair(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializePermissionLbPair)
                );
            }
        }
    }
    #[test]
    fn test_initialize_customizable_permissionless_lb_pair_consistency() {
        let test_args = InitializeCustomizablePermissionlessLbPairIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_CUSTOMIZABLE_PERMISSIONLESS_LB_PAIR_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::InitializeCustomizablePermissionlessLbPair(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializeCustomizablePermissionlessLbPair)
                );
            }
        }
    }
    #[test]
    fn test_initialize_bin_array_bitmap_extension_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_BIN_ARRAY_BITMAP_EXTENSION_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDlmmInstruction::InitializeBinArrayBitmapExtension => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_initialize_bin_array_consistency() {
        let expected_first_arg = 1000i64;
        let test_args = InitializeBinArrayIxArgs {
            index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_BIN_ARRAY_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::InitializeBinArray(args)) => {
                assert_eq!(
                    args.index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializeBinArray)
                );
            }
        }
    }
    #[test]
    fn test_add_liquidity_consistency() {
        let test_args = AddLiquidityIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&ADD_LIQUIDITY_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::AddLiquidity(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(AddLiquidity)
                );
            }
        }
    }
    #[test]
    fn test_add_liquidity_by_weight_consistency() {
        let test_args = AddLiquidityByWeightIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&ADD_LIQUIDITY_BY_WEIGHT_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::AddLiquidityByWeight(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(AddLiquidityByWeight)
                );
            }
        }
    }
    #[test]
    fn test_add_liquidity_by_strategy_consistency() {
        let test_args = AddLiquidityByStrategyIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&ADD_LIQUIDITY_BY_STRATEGY_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::AddLiquidityByStrategy(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(AddLiquidityByStrategy)
                );
            }
        }
    }
    #[test]
    fn test_add_liquidity_by_strategy_one_side_consistency() {
        let test_args = AddLiquidityByStrategyOneSideIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&ADD_LIQUIDITY_BY_STRATEGY_ONE_SIDE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::AddLiquidityByStrategyOneSide(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(AddLiquidityByStrategyOneSide)
                );
            }
        }
    }
    #[test]
    fn test_add_liquidity_one_side_consistency() {
        let test_args = AddLiquidityOneSideIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&ADD_LIQUIDITY_ONE_SIDE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::AddLiquidityOneSide(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(AddLiquidityOneSide)
                );
            }
        }
    }
    #[test]
    fn test_remove_liquidity_consistency() {
        let test_args = RemoveLiquidityIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&REMOVE_LIQUIDITY_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::RemoveLiquidity(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(RemoveLiquidity)
                );
            }
        }
    }
    #[test]
    fn test_initialize_position_consistency() {
        let expected_first_arg = 1000i32;
        let test_args = InitializePositionIxArgs {
            lower_bin_id: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_POSITION_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::InitializePosition(args)) => {
                assert_eq!(
                    args.lower_bin_id, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializePosition)
                );
            }
        }
    }
    #[test]
    fn test_initialize_position_pda_consistency() {
        let expected_first_arg = 1000i32;
        let test_args = InitializePositionPdaIxArgs {
            lower_bin_id: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_POSITION_PDA_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::InitializePositionPda(args)) => {
                assert_eq!(
                    args.lower_bin_id, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializePositionPda)
                );
            }
        }
    }
    #[test]
    fn test_initialize_position_by_operator_consistency() {
        let expected_first_arg = 1000i32;
        let test_args = InitializePositionByOperatorIxArgs {
            lower_bin_id: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_POSITION_BY_OPERATOR_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::InitializePositionByOperator(args)) => {
                assert_eq!(
                    args.lower_bin_id, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializePositionByOperator)
                );
            }
        }
    }
    #[test]
    fn test_update_position_operator_consistency() {
        let expected_first_arg = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_args = UpdatePositionOperatorIxArgs {
            operator: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&UPDATE_POSITION_OPERATOR_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::UpdatePositionOperator(args)) => {
                assert_eq!(
                    args.operator, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(UpdatePositionOperator)
                );
            }
        }
    }
    #[test]
    fn test_swap_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = SwapIxArgs {
            amount_in: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SWAP_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::Swap(args)) => {
                assert_eq!(
                    args.amount_in, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Swap)
                );
            }
        }
    }
    #[test]
    fn test_swap_exact_out_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = SwapExactOutIxArgs {
            max_in_amount: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SWAP_EXACT_OUT_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::SwapExactOut(args)) => {
                assert_eq!(
                    args.max_in_amount, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SwapExactOut)
                );
            }
        }
    }
    #[test]
    fn test_swap_with_price_impact_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = SwapWithPriceImpactIxArgs {
            amount_in: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SWAP_WITH_PRICE_IMPACT_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::SwapWithPriceImpact(args)) => {
                assert_eq!(
                    args.amount_in, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SwapWithPriceImpact)
                );
            }
        }
    }
    #[test]
    fn test_withdraw_protocol_fee_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = WithdrawProtocolFeeIxArgs {
            amount_x: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&WITHDRAW_PROTOCOL_FEE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::WithdrawProtocolFee(args)) => {
                assert_eq!(
                    args.amount_x, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(WithdrawProtocolFee)
                );
            }
        }
    }
    #[test]
    fn test_initialize_reward_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = InitializeRewardIxArgs {
            reward_index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_REWARD_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::InitializeReward(args)) => {
                assert_eq!(
                    args.reward_index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializeReward)
                );
            }
        }
    }
    #[test]
    fn test_fund_reward_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = FundRewardIxArgs {
            reward_index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&FUND_REWARD_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::FundReward(args)) => {
                assert_eq!(
                    args.reward_index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(FundReward)
                );
            }
        }
    }
    #[test]
    fn test_update_reward_funder_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = UpdateRewardFunderIxArgs {
            reward_index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&UPDATE_REWARD_FUNDER_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::UpdateRewardFunder(args)) => {
                assert_eq!(
                    args.reward_index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(UpdateRewardFunder)
                );
            }
        }
    }
    #[test]
    fn test_update_reward_duration_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = UpdateRewardDurationIxArgs {
            reward_index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&UPDATE_REWARD_DURATION_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::UpdateRewardDuration(args)) => {
                assert_eq!(
                    args.reward_index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(UpdateRewardDuration)
                );
            }
        }
    }
    #[test]
    fn test_claim_reward_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = ClaimRewardIxArgs {
            reward_index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CLAIM_REWARD_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::ClaimReward(args)) => {
                assert_eq!(
                    args.reward_index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ClaimReward)
                );
            }
        }
    }
    #[test]
    fn test_claim_fee_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CLAIM_FEE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDlmmInstruction::ClaimFee => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_close_position_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CLOSE_POSITION_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDlmmInstruction::ClosePosition => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_update_fee_parameters_consistency() {
        let test_args = UpdateFeeParametersIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&UPDATE_FEE_PARAMETERS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::UpdateFeeParameters(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(UpdateFeeParameters)
                );
            }
        }
    }
    #[test]
    fn test_increase_oracle_length_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = IncreaseOracleLengthIxArgs {
            length_to_add: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INCREASE_ORACLE_LENGTH_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::IncreaseOracleLength(args)) => {
                assert_eq!(
                    args.length_to_add, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(IncreaseOracleLength)
                );
            }
        }
    }
    #[test]
    fn test_initialize_preset_parameter_consistency() {
        let test_args = InitializePresetParameterIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_PRESET_PARAMETER_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::InitializePresetParameter(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializePresetParameter)
                );
            }
        }
    }
    #[test]
    fn test_close_preset_parameter_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CLOSE_PRESET_PARAMETER_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDlmmInstruction::ClosePresetParameter => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_remove_all_liquidity_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&REMOVE_ALL_LIQUIDITY_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDlmmInstruction::RemoveAllLiquidity => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_toggle_pair_status_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&TOGGLE_PAIR_STATUS_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDlmmInstruction::TogglePairStatus => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_migrate_position_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MIGRATE_POSITION_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDlmmInstruction::MigratePosition => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_migrate_bin_array_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MIGRATE_BIN_ARRAY_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDlmmInstruction::MigrateBinArray => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_update_fees_and_rewards_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&UPDATE_FEES_AND_REWARDS_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDlmmInstruction::UpdateFeesAndRewards => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_withdraw_ineligible_reward_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = WithdrawIneligibleRewardIxArgs {
            reward_index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&WITHDRAW_INELIGIBLE_REWARD_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::WithdrawIneligibleReward(args)) => {
                assert_eq!(
                    args.reward_index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(WithdrawIneligibleReward)
                );
            }
        }
    }
    #[test]
    fn test_set_activation_point_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = SetActivationPointIxArgs {
            activation_point: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_ACTIVATION_POINT_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::SetActivationPoint(args)) => {
                assert_eq!(
                    args.activation_point, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SetActivationPoint)
                );
            }
        }
    }
    #[test]
    fn test_remove_liquidity_by_range_consistency() {
        let expected_first_arg = 1000i32;
        let test_args = RemoveLiquidityByRangeIxArgs {
            from_bin_id: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&REMOVE_LIQUIDITY_BY_RANGE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::RemoveLiquidityByRange(args)) => {
                assert_eq!(
                    args.from_bin_id, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(RemoveLiquidityByRange)
                );
            }
        }
    }
    #[test]
    fn test_add_liquidity_one_side_precise_consistency() {
        let test_args = AddLiquidityOneSidePreciseIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&ADD_LIQUIDITY_ONE_SIDE_PRECISE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::AddLiquidityOneSidePrecise(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(AddLiquidityOneSidePrecise)
                );
            }
        }
    }
    #[test]
    fn test_go_to_a_bin_consistency() {
        let expected_first_arg = 1000i32;
        let test_args = GoToABinIxArgs {
            bin_id: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&GO_TO_A_BIN_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::GoToABin(args)) => {
                assert_eq!(
                    args.bin_id, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(GoToABin)
                );
            }
        }
    }
    #[test]
    fn test_set_pre_activation_duration_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = SetPreActivationDurationIxArgs {
            pre_activation_duration: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_PRE_ACTIVATION_DURATION_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::SetPreActivationDuration(args)) => {
                assert_eq!(
                    args.pre_activation_duration, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SetPreActivationDuration)
                );
            }
        }
    }
    #[test]
    fn test_set_pre_activation_swap_address_consistency() {
        let expected_first_arg = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_args = SetPreActivationSwapAddressIxArgs {
            pre_activation_swap_address: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_PRE_ACTIVATION_SWAP_ADDRESS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDlmmInstruction::SetPreActivationSwapAddress(args)) => {
                assert_eq!(
                    args.pre_activation_swap_address, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SetPreActivationSwapAddress)
                );
            }
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_args = InitializeLbPairIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializeLbPairIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_LB_PAIR_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::InitializeLbPair(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_LB_PAIR_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializeLbPair)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializeLbPair),
                    e
                );
            }
        }
        let test_args = InitializePermissionLbPairIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializePermissionLbPairIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_PERMISSION_LB_PAIR_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::InitializePermissionLbPair(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_PERMISSION_LB_PAIR_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializePermissionLbPair)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializePermissionLbPair),
                    e
                );
            }
        }
        let test_args = InitializeCustomizablePermissionlessLbPairIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializeCustomizablePermissionlessLbPairIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_CUSTOMIZABLE_PERMISSIONLESS_LB_PAIR_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::InitializeCustomizablePermissionlessLbPair(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator,
                        INITIALIZE_CUSTOMIZABLE_PERMISSIONLESS_LB_PAIR_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializeCustomizablePermissionlessLbPair)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializeCustomizablePermissionlessLbPair),
                    e
                );
            }
        }
        let test_data = INITIALIZE_BIN_ARRAY_BITMAP_EXTENSION_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::InitializeBinArrayBitmapExtension => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializeBinArrayBitmapExtension)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializeBinArrayBitmapExtension),
                    e
                );
            }
        }
        let test_args = InitializeBinArrayIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializeBinArrayIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_BIN_ARRAY_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::InitializeBinArray(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_BIN_ARRAY_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializeBinArray)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializeBinArray),
                    e
                );
            }
        }
        let test_args = AddLiquidityIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(AddLiquidityIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &ADD_LIQUIDITY_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::AddLiquidity(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, ADD_LIQUIDITY_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(AddLiquidity))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(AddLiquidity),
                    e
                );
            }
        }
        let test_args = AddLiquidityByWeightIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(AddLiquidityByWeightIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &ADD_LIQUIDITY_BY_WEIGHT_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::AddLiquidityByWeight(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, ADD_LIQUIDITY_BY_WEIGHT_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(AddLiquidityByWeight)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(AddLiquidityByWeight),
                    e
                );
            }
        }
        let test_args = AddLiquidityByStrategyIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(AddLiquidityByStrategyIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &ADD_LIQUIDITY_BY_STRATEGY_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::AddLiquidityByStrategy(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, ADD_LIQUIDITY_BY_STRATEGY_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(AddLiquidityByStrategy)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(AddLiquidityByStrategy),
                    e
                );
            }
        }
        let test_args = AddLiquidityByStrategyOneSideIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(AddLiquidityByStrategyOneSideIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &ADD_LIQUIDITY_BY_STRATEGY_ONE_SIDE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::AddLiquidityByStrategyOneSide(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, ADD_LIQUIDITY_BY_STRATEGY_ONE_SIDE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(AddLiquidityByStrategyOneSide)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(AddLiquidityByStrategyOneSide),
                    e
                );
            }
        }
        let test_args = AddLiquidityOneSideIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(AddLiquidityOneSideIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &ADD_LIQUIDITY_ONE_SIDE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::AddLiquidityOneSide(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, ADD_LIQUIDITY_ONE_SIDE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(AddLiquidityOneSide)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(AddLiquidityOneSide),
                    e
                );
            }
        }
        let test_args = RemoveLiquidityIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(RemoveLiquidityIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &REMOVE_LIQUIDITY_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::RemoveLiquidity(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, REMOVE_LIQUIDITY_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(RemoveLiquidity)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(RemoveLiquidity),
                    e
                );
            }
        }
        let test_args = InitializePositionIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializePositionIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_POSITION_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::InitializePosition(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_POSITION_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializePosition)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializePosition),
                    e
                );
            }
        }
        let test_args = InitializePositionPdaIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializePositionPdaIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_POSITION_PDA_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::InitializePositionPda(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_POSITION_PDA_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializePositionPda)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializePositionPda),
                    e
                );
            }
        }
        let test_args = InitializePositionByOperatorIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializePositionByOperatorIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_POSITION_BY_OPERATOR_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::InitializePositionByOperator(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_POSITION_BY_OPERATOR_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializePositionByOperator)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializePositionByOperator),
                    e
                );
            }
        }
        let test_args = UpdatePositionOperatorIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(UpdatePositionOperatorIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &UPDATE_POSITION_OPERATOR_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::UpdatePositionOperator(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, UPDATE_POSITION_OPERATOR_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(UpdatePositionOperator)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(UpdatePositionOperator),
                    e
                );
            }
        }
        let test_args = SwapIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SwapIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SWAP_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::Swap(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SWAP_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(Swap)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Swap),
                    e
                );
            }
        }
        let test_args = SwapExactOutIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SwapExactOutIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SWAP_EXACT_OUT_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::SwapExactOut(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SWAP_EXACT_OUT_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(SwapExactOut))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SwapExactOut),
                    e
                );
            }
        }
        let test_args = SwapWithPriceImpactIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SwapWithPriceImpactIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SWAP_WITH_PRICE_IMPACT_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::SwapWithPriceImpact(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SWAP_WITH_PRICE_IMPACT_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SwapWithPriceImpact)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SwapWithPriceImpact),
                    e
                );
            }
        }
        let test_args = WithdrawProtocolFeeIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(WithdrawProtocolFeeIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &WITHDRAW_PROTOCOL_FEE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::WithdrawProtocolFee(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, WITHDRAW_PROTOCOL_FEE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(WithdrawProtocolFee)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(WithdrawProtocolFee),
                    e
                );
            }
        }
        let test_args = InitializeRewardIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializeRewardIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_REWARD_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::InitializeReward(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_REWARD_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializeReward)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializeReward),
                    e
                );
            }
        }
        let test_args = FundRewardIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(FundRewardIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &FUND_REWARD_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::FundReward(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, FUND_REWARD_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(FundReward))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(FundReward),
                    e
                );
            }
        }
        let test_args = UpdateRewardFunderIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(UpdateRewardFunderIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &UPDATE_REWARD_FUNDER_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::UpdateRewardFunder(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, UPDATE_REWARD_FUNDER_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(UpdateRewardFunder)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(UpdateRewardFunder),
                    e
                );
            }
        }
        let test_args = UpdateRewardDurationIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(UpdateRewardDurationIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &UPDATE_REWARD_DURATION_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::UpdateRewardDuration(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, UPDATE_REWARD_DURATION_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(UpdateRewardDuration)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(UpdateRewardDuration),
                    e
                );
            }
        }
        let test_args = ClaimRewardIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ClaimRewardIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CLAIM_REWARD_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::ClaimReward(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CLAIM_REWARD_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(ClaimReward))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ClaimReward),
                    e
                );
            }
        }
        let test_data = CLAIM_FEE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::ClaimFee => {}
                _ => panic!("Parsed instruction should be {}", stringify!(ClaimFee)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ClaimFee),
                    e
                );
            }
        }
        let test_data = CLOSE_POSITION_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::ClosePosition => {}
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(ClosePosition))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ClosePosition),
                    e
                );
            }
        }
        let test_args = UpdateFeeParametersIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(UpdateFeeParametersIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &UPDATE_FEE_PARAMETERS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::UpdateFeeParameters(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, UPDATE_FEE_PARAMETERS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(UpdateFeeParameters)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(UpdateFeeParameters),
                    e
                );
            }
        }
        let test_args = IncreaseOracleLengthIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(IncreaseOracleLengthIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INCREASE_ORACLE_LENGTH_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::IncreaseOracleLength(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INCREASE_ORACLE_LENGTH_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(IncreaseOracleLength)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(IncreaseOracleLength),
                    e
                );
            }
        }
        let test_args = InitializePresetParameterIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializePresetParameterIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_PRESET_PARAMETER_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::InitializePresetParameter(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_PRESET_PARAMETER_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializePresetParameter)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializePresetParameter),
                    e
                );
            }
        }
        let test_data = CLOSE_PRESET_PARAMETER_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::ClosePresetParameter => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ClosePresetParameter)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ClosePresetParameter),
                    e
                );
            }
        }
        let test_data = REMOVE_ALL_LIQUIDITY_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::RemoveAllLiquidity => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(RemoveAllLiquidity)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(RemoveAllLiquidity),
                    e
                );
            }
        }
        let test_data = TOGGLE_PAIR_STATUS_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::TogglePairStatus => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(TogglePairStatus)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(TogglePairStatus),
                    e
                );
            }
        }
        let test_data = MIGRATE_POSITION_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::MigratePosition => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MigratePosition)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MigratePosition),
                    e
                );
            }
        }
        let test_data = MIGRATE_BIN_ARRAY_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::MigrateBinArray => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MigrateBinArray)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MigrateBinArray),
                    e
                );
            }
        }
        let test_data = UPDATE_FEES_AND_REWARDS_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::UpdateFeesAndRewards => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(UpdateFeesAndRewards)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(UpdateFeesAndRewards),
                    e
                );
            }
        }
        let test_args = WithdrawIneligibleRewardIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(WithdrawIneligibleRewardIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &WITHDRAW_INELIGIBLE_REWARD_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::WithdrawIneligibleReward(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, WITHDRAW_INELIGIBLE_REWARD_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(WithdrawIneligibleReward)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(WithdrawIneligibleReward),
                    e
                );
            }
        }
        let test_args = SetActivationPointIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SetActivationPointIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SET_ACTIVATION_POINT_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::SetActivationPoint(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SET_ACTIVATION_POINT_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SetActivationPoint)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetActivationPoint),
                    e
                );
            }
        }
        let test_args = RemoveLiquidityByRangeIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(RemoveLiquidityByRangeIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &REMOVE_LIQUIDITY_BY_RANGE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::RemoveLiquidityByRange(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, REMOVE_LIQUIDITY_BY_RANGE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(RemoveLiquidityByRange)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(RemoveLiquidityByRange),
                    e
                );
            }
        }
        let test_args = AddLiquidityOneSidePreciseIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(AddLiquidityOneSidePreciseIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &ADD_LIQUIDITY_ONE_SIDE_PRECISE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::AddLiquidityOneSidePrecise(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, ADD_LIQUIDITY_ONE_SIDE_PRECISE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(AddLiquidityOneSidePrecise)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(AddLiquidityOneSidePrecise),
                    e
                );
            }
        }
        let test_args = GoToABinIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(GoToABinIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &GO_TO_A_BIN_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::GoToABin(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, GO_TO_A_BIN_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(GoToABin)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(GoToABin),
                    e
                );
            }
        }
        let test_args = SetPreActivationDurationIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SetPreActivationDurationIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SET_PRE_ACTIVATION_DURATION_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::SetPreActivationDuration(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SET_PRE_ACTIVATION_DURATION_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SetPreActivationDuration)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetPreActivationDuration),
                    e
                );
            }
        }
        let test_args = SetPreActivationSwapAddressIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SetPreActivationSwapAddressIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SET_PRE_ACTIVATION_SWAP_ADDRESS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDlmmInstruction::SetPreActivationSwapAddress(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SET_PRE_ACTIVATION_SWAP_ADDRESS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SetPreActivationSwapAddress)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetPreActivationSwapAddress),
                    e
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = parse_instruction(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = parse_instruction(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
