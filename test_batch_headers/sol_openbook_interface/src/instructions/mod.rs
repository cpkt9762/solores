//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::*;
use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::AccountInfo,
    entrypoint::ProgramResult,
    instruction::{AccountMeta, Instruction},
    program::{invoke, invoke_signed},
    pubkey::Pubkey,
};
fn invoke_instruction<'info, A: Into<[AccountInfo<'info>; N]>, const N: usize>(
    ix: &Instruction,
    accounts: A,
) -> ProgramResult {
    let account_info: [AccountInfo<'info>; N] = accounts.into();
    invoke(ix, &account_info)
}
fn invoke_instruction_signed<'info, A: Into<[AccountInfo<'info>; N]>, const N: usize>(
    ix: &Instruction,
    accounts: A,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let account_info: [AccountInfo<'info>; N] = accounts.into();
    invoke_signed(ix, &account_info, seeds)
}
pub mod initialize_market;
pub use initialize_market::*;
pub mod new_order;
pub use new_order::*;
pub mod match_orders;
pub use match_orders::*;
pub mod consume_events;
pub use consume_events::*;
pub mod cancel_order;
pub use cancel_order::*;
pub mod settle_funds;
pub use settle_funds::*;
pub mod cancel_order_by_client_id;
pub use cancel_order_by_client_id::*;
pub mod disable_market;
pub use disable_market::*;
pub mod sweep_fees;
pub use sweep_fees::*;
pub mod new_order_v2;
pub use new_order_v2::*;
pub mod new_order_v3;
pub use new_order_v3::*;
pub mod cancel_order_v2;
pub use cancel_order_v2::*;
pub mod cancel_order_by_client_id_v2;
pub use cancel_order_by_client_id_v2::*;
pub mod send_take;
pub use send_take::*;
pub mod close_open_orders;
pub use close_open_orders::*;
pub mod init_open_orders;
pub use init_open_orders::*;
pub mod prune;
pub use prune::*;
pub mod consume_events_permissioned;
pub use consume_events_permissioned::*;
pub mod cancel_orders_by_client_ids;
pub use cancel_orders_by_client_ids::*;
pub mod replace_order_by_client_id;
pub use replace_order_by_client_id::*;
pub mod replace_orders_by_client_ids;
pub use replace_orders_by_client_ids::*;
#[derive(Clone, Debug, PartialEq)]
pub enum OpenbookProgramIx {
    InitializeMarket(InitializeMarketIxArgs),
    NewOrder(NewOrderIxArgs),
    MatchOrders(MatchOrdersIxArgs),
    ConsumeEvents(ConsumeEventsIxArgs),
    CancelOrder(CancelOrderIxArgs),
    SettleFunds,
    CancelOrderByClientId(CancelOrderByClientIdIxArgs),
    DisableMarket,
    SweepFees,
    NewOrderV2(NewOrderV2IxArgs),
    NewOrderV3(NewOrderV3IxArgs),
    CancelOrderV2(CancelOrderV2IxArgs),
    CancelOrderByClientIdV2(CancelOrderByClientIdV2IxArgs),
    SendTake(SendTakeIxArgs),
    CloseOpenOrders,
    InitOpenOrders,
    Prune(PruneIxArgs),
    ConsumeEventsPermissioned(ConsumeEventsPermissionedIxArgs),
    CancelOrdersByClientIds(CancelOrdersByClientIdsIxArgs),
    ReplaceOrderByClientId(ReplaceOrderByClientIdIxArgs),
    ReplaceOrdersByClientIds(ReplaceOrdersByClientIdsIxArgs),
}
impl OpenbookProgramIx {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        if buf.is_empty() {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Instruction data is empty",
            ));
        }
        let maybe_discm = buf[0];
        let mut reader = &buf[1..];
        match maybe_discm {
            INITIALIZE_MARKET_IX_DISCM => Ok(Self::InitializeMarket(
                InitializeMarketIxArgs::deserialize(&mut reader)?,
            )),
            NEW_ORDER_IX_DISCM => Ok(Self::NewOrder(NewOrderIxArgs::deserialize(&mut reader)?)),
            MATCH_ORDERS_IX_DISCM => Ok(Self::MatchOrders(MatchOrdersIxArgs::deserialize(
                &mut reader,
            )?)),
            CONSUME_EVENTS_IX_DISCM => Ok(Self::ConsumeEvents(ConsumeEventsIxArgs::deserialize(
                &mut reader,
            )?)),
            CANCEL_ORDER_IX_DISCM => Ok(Self::CancelOrder(CancelOrderIxArgs::deserialize(
                &mut reader,
            )?)),
            SETTLE_FUNDS_IX_DISCM => Ok(Self::SettleFunds),
            CANCEL_ORDER_BY_CLIENT_ID_IX_DISCM => Ok(Self::CancelOrderByClientId(
                CancelOrderByClientIdIxArgs::deserialize(&mut reader)?,
            )),
            DISABLE_MARKET_IX_DISCM => Ok(Self::DisableMarket),
            SWEEP_FEES_IX_DISCM => Ok(Self::SweepFees),
            NEW_ORDER_V2_IX_DISCM => Ok(Self::NewOrderV2(NewOrderV2IxArgs::deserialize(
                &mut reader,
            )?)),
            NEW_ORDER_V3_IX_DISCM => Ok(Self::NewOrderV3(NewOrderV3IxArgs::deserialize(
                &mut reader,
            )?)),
            CANCEL_ORDER_V2_IX_DISCM => Ok(Self::CancelOrderV2(CancelOrderV2IxArgs::deserialize(
                &mut reader,
            )?)),
            CANCEL_ORDER_BY_CLIENT_ID_V2_IX_DISCM => Ok(Self::CancelOrderByClientIdV2(
                CancelOrderByClientIdV2IxArgs::deserialize(&mut reader)?,
            )),
            SEND_TAKE_IX_DISCM => Ok(Self::SendTake(SendTakeIxArgs::deserialize(&mut reader)?)),
            CLOSE_OPEN_ORDERS_IX_DISCM => Ok(Self::CloseOpenOrders),
            INIT_OPEN_ORDERS_IX_DISCM => Ok(Self::InitOpenOrders),
            PRUNE_IX_DISCM => Ok(Self::Prune(PruneIxArgs::deserialize(&mut reader)?)),
            CONSUME_EVENTS_PERMISSIONED_IX_DISCM => Ok(Self::ConsumeEventsPermissioned(
                ConsumeEventsPermissionedIxArgs::deserialize(&mut reader)?,
            )),
            CANCEL_ORDERS_BY_CLIENT_IDS_IX_DISCM => Ok(Self::CancelOrdersByClientIds(
                CancelOrdersByClientIdsIxArgs::deserialize(&mut reader)?,
            )),
            REPLACE_ORDER_BY_CLIENT_ID_IX_DISCM => Ok(Self::ReplaceOrderByClientId(
                ReplaceOrderByClientIdIxArgs::deserialize(&mut reader)?,
            )),
            REPLACE_ORDERS_BY_CLIENT_IDS_IX_DISCM => Ok(Self::ReplaceOrdersByClientIds(
                ReplaceOrdersByClientIdsIxArgs::deserialize(&mut reader)?,
            )),
            _ => Err(std::io::Error::new(
                std::io::ErrorKind::Other,
                format!("discm {} not found", maybe_discm),
            )),
        }
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        match self {
            Self::InitializeMarket(args) => {
                writer.write_all(&[INITIALIZE_MARKET_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::NewOrder(args) => {
                writer.write_all(&[NEW_ORDER_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::MatchOrders(args) => {
                writer.write_all(&[MATCH_ORDERS_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::ConsumeEvents(args) => {
                writer.write_all(&[CONSUME_EVENTS_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::CancelOrder(args) => {
                writer.write_all(&[CANCEL_ORDER_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::SettleFunds => writer.write_all(&[SETTLE_FUNDS_IX_DISCM]),
            Self::CancelOrderByClientId(args) => {
                writer.write_all(&[CANCEL_ORDER_BY_CLIENT_ID_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::DisableMarket => writer.write_all(&[DISABLE_MARKET_IX_DISCM]),
            Self::SweepFees => writer.write_all(&[SWEEP_FEES_IX_DISCM]),
            Self::NewOrderV2(args) => {
                writer.write_all(&[NEW_ORDER_V2_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::NewOrderV3(args) => {
                writer.write_all(&[NEW_ORDER_V3_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::CancelOrderV2(args) => {
                writer.write_all(&[CANCEL_ORDER_V2_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::CancelOrderByClientIdV2(args) => {
                writer.write_all(&[CANCEL_ORDER_BY_CLIENT_ID_V2_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::SendTake(args) => {
                writer.write_all(&[SEND_TAKE_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::CloseOpenOrders => writer.write_all(&[CLOSE_OPEN_ORDERS_IX_DISCM]),
            Self::InitOpenOrders => writer.write_all(&[INIT_OPEN_ORDERS_IX_DISCM]),
            Self::Prune(args) => {
                writer.write_all(&[PRUNE_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::ConsumeEventsPermissioned(args) => {
                writer.write_all(&[CONSUME_EVENTS_PERMISSIONED_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::CancelOrdersByClientIds(args) => {
                writer.write_all(&[CANCEL_ORDERS_BY_CLIENT_IDS_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::ReplaceOrderByClientId(args) => {
                writer.write_all(&[REPLACE_ORDER_BY_CLIENT_ID_IX_DISCM])?;
                args.serialize(&mut writer)
            }
            Self::ReplaceOrdersByClientIds(args) => {
                writer.write_all(&[REPLACE_ORDERS_BY_CLIENT_IDS_IX_DISCM])?;
                args.serialize(&mut writer)
            }
        }
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
