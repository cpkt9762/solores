//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::instructions::*;
pub const INITIALIZE_MARKET_IX_DISCM: u8 = 0u8;
pub const NEW_ORDER_IX_DISCM: u8 = 1u8;
pub const MATCH_ORDERS_IX_DISCM: u8 = 2u8;
pub const CONSUME_EVENTS_IX_DISCM: u8 = 3u8;
pub const CANCEL_ORDER_IX_DISCM: u8 = 4u8;
pub const SETTLE_FUNDS_IX_DISCM: u8 = 5u8;
pub const CANCEL_ORDER_BY_CLIENT_ID_IX_DISCM: u8 = 6u8;
pub const DISABLE_MARKET_IX_DISCM: u8 = 7u8;
pub const SWEEP_FEES_IX_DISCM: u8 = 8u8;
pub const NEW_ORDER_V2_IX_DISCM: u8 = 9u8;
pub const NEW_ORDER_V3_IX_DISCM: u8 = 10u8;
pub const CANCEL_ORDER_V2_IX_DISCM: u8 = 11u8;
pub const CANCEL_ORDER_BY_CLIENT_ID_V2_IX_DISCM: u8 = 12u8;
pub const SEND_TAKE_IX_DISCM: u8 = 13u8;
pub const CLOSE_OPEN_ORDERS_IX_DISCM: u8 = 14u8;
pub const INIT_OPEN_ORDERS_IX_DISCM: u8 = 15u8;
pub const PRUNE_IX_DISCM: u8 = 16u8;
pub const CONSUME_EVENTS_PERMISSIONED_IX_DISCM: u8 = 17u8;
pub const CANCEL_ORDERS_BY_CLIENT_IDS_IX_DISCM: u8 = 18u8;
pub const REPLACE_ORDER_BY_CLIENT_ID_IX_DISCM: u8 = 19u8;
pub const REPLACE_ORDERS_BY_CLIENT_IDS_IX_DISCM: u8 = 20u8;
/// Program instruction types
#[derive(Clone, Debug, PartialEq)]
pub enum OpenbookInstruction {
    InitializeMarket(InitializeMarketIxArgs),
    NewOrder(NewOrderIxArgs),
    MatchOrders(MatchOrdersIxArgs),
    ConsumeEvents(ConsumeEventsIxArgs),
    CancelOrder(CancelOrderIxArgs),
    SettleFunds,
    CancelOrderByClientId(CancelOrderByClientIdIxArgs),
    DisableMarket,
    SweepFees,
    NewOrderV2(NewOrderV2IxArgs),
    NewOrderV3(NewOrderV3IxArgs),
    CancelOrderV2(CancelOrderV2IxArgs),
    CancelOrderByClientIdV2(CancelOrderByClientIdV2IxArgs),
    SendTake(SendTakeIxArgs),
    CloseOpenOrders,
    InitOpenOrders,
    ///Removes all orders for a given open orders account from the orderbook.
    Prune(PruneIxArgs),
    ConsumeEventsPermissioned(ConsumeEventsPermissionedIxArgs),
    CancelOrdersByClientIds(CancelOrdersByClientIdsIxArgs),
    ReplaceOrderByClientId(ReplaceOrderByClientIdIxArgs),
    ReplaceOrdersByClientIds(ReplaceOrdersByClientIdsIxArgs),
}
/// Parse instruction data based on 1-byte discriminator (non-Anchor contracts)
pub fn parse_instruction(data: &[u8]) -> Result<OpenbookInstruction, std::io::Error> {
    if data.is_empty() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data is empty",
        ));
    }
    let discriminator = data[0];
    let mut ix_data = &data[1..];
    match discriminator {
        0u8 => {
            let args = InitializeMarketIxArgs::deserialize(&mut ix_data)?;
            Ok(OpenbookInstruction::InitializeMarket(args))
        }
        1u8 => {
            let args = NewOrderIxArgs::deserialize(&mut ix_data)?;
            Ok(OpenbookInstruction::NewOrder(args))
        }
        2u8 => {
            let args = MatchOrdersIxArgs::deserialize(&mut ix_data)?;
            Ok(OpenbookInstruction::MatchOrders(args))
        }
        3u8 => {
            let args = ConsumeEventsIxArgs::deserialize(&mut ix_data)?;
            Ok(OpenbookInstruction::ConsumeEvents(args))
        }
        4u8 => {
            let args = CancelOrderIxArgs::deserialize(&mut ix_data)?;
            Ok(OpenbookInstruction::CancelOrder(args))
        }
        5u8 => Ok(OpenbookInstruction::SettleFunds),
        6u8 => {
            let args = CancelOrderByClientIdIxArgs::deserialize(&mut ix_data)?;
            Ok(OpenbookInstruction::CancelOrderByClientId(args))
        }
        7u8 => Ok(OpenbookInstruction::DisableMarket),
        8u8 => Ok(OpenbookInstruction::SweepFees),
        9u8 => {
            let args = NewOrderV2IxArgs::deserialize(&mut ix_data)?;
            Ok(OpenbookInstruction::NewOrderV2(args))
        }
        10u8 => {
            let args = NewOrderV3IxArgs::deserialize(&mut ix_data)?;
            Ok(OpenbookInstruction::NewOrderV3(args))
        }
        11u8 => {
            let args = CancelOrderV2IxArgs::deserialize(&mut ix_data)?;
            Ok(OpenbookInstruction::CancelOrderV2(args))
        }
        12u8 => {
            let args = CancelOrderByClientIdV2IxArgs::deserialize(&mut ix_data)?;
            Ok(OpenbookInstruction::CancelOrderByClientIdV2(args))
        }
        13u8 => {
            let args = SendTakeIxArgs::deserialize(&mut ix_data)?;
            Ok(OpenbookInstruction::SendTake(args))
        }
        14u8 => Ok(OpenbookInstruction::CloseOpenOrders),
        15u8 => Ok(OpenbookInstruction::InitOpenOrders),
        16u8 => {
            let args = PruneIxArgs::deserialize(&mut ix_data)?;
            Ok(OpenbookInstruction::Prune(args))
        }
        17u8 => {
            let args = ConsumeEventsPermissionedIxArgs::deserialize(&mut ix_data)?;
            Ok(OpenbookInstruction::ConsumeEventsPermissioned(args))
        }
        18u8 => {
            let args = CancelOrdersByClientIdsIxArgs::deserialize(&mut ix_data)?;
            Ok(OpenbookInstruction::CancelOrdersByClientIds(args))
        }
        19u8 => {
            let args = ReplaceOrderByClientIdIxArgs::deserialize(&mut ix_data)?;
            Ok(OpenbookInstruction::ReplaceOrderByClientId(args))
        }
        20u8 => {
            let args = ReplaceOrdersByClientIdsIxArgs::deserialize(&mut ix_data)?;
            Ok(OpenbookInstruction::ReplaceOrdersByClientIds(args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {}", discriminator),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_initialize_market_consistency() {
        let test_args = InitializeMarketIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_MARKET_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(OpenbookInstruction::InitializeMarket(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializeMarket)
                );
            }
        }
    }
    #[test]
    fn test_new_order_consistency() {
        let test_args = NewOrderIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&NEW_ORDER_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(OpenbookInstruction::NewOrder(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(NewOrder)
                );
            }
        }
    }
    #[test]
    fn test_match_orders_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = MatchOrdersIxArgs {
            limit: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MATCH_ORDERS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(OpenbookInstruction::MatchOrders(args)) => {
                assert_eq!(
                    args.limit, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(MatchOrders)
                );
            }
        }
    }
    #[test]
    fn test_consume_events_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = ConsumeEventsIxArgs {
            limit: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CONSUME_EVENTS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(OpenbookInstruction::ConsumeEvents(args)) => {
                assert_eq!(
                    args.limit, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ConsumeEvents)
                );
            }
        }
    }
    #[test]
    fn test_cancel_order_consistency() {
        let test_args = CancelOrderIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CANCEL_ORDER_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(OpenbookInstruction::CancelOrder(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CancelOrder)
                );
            }
        }
    }
    #[test]
    fn test_settle_funds_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SETTLE_FUNDS_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            OpenbookInstruction::SettleFunds => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_cancel_order_by_client_id_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = CancelOrderByClientIdIxArgs {
            client_order_id: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CANCEL_ORDER_BY_CLIENT_ID_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(OpenbookInstruction::CancelOrderByClientId(args)) => {
                assert_eq!(
                    args.client_order_id, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CancelOrderByClientId)
                );
            }
        }
    }
    #[test]
    fn test_disable_market_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&DISABLE_MARKET_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            OpenbookInstruction::DisableMarket => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_sweep_fees_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SWEEP_FEES_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            OpenbookInstruction::SweepFees => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_new_order_v_2_consistency() {
        let test_args = NewOrderV2IxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&NEW_ORDER_V2_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(OpenbookInstruction::NewOrderV2(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(NewOrderV2)
                );
            }
        }
    }
    #[test]
    fn test_new_order_v_3_consistency() {
        let test_args = NewOrderV3IxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&NEW_ORDER_V3_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(OpenbookInstruction::NewOrderV3(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(NewOrderV3)
                );
            }
        }
    }
    #[test]
    fn test_cancel_order_v_2_consistency() {
        let test_args = CancelOrderV2IxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CANCEL_ORDER_V2_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(OpenbookInstruction::CancelOrderV2(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CancelOrderV2)
                );
            }
        }
    }
    #[test]
    fn test_cancel_order_by_client_id_v_2_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = CancelOrderByClientIdV2IxArgs {
            client_order_id: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CANCEL_ORDER_BY_CLIENT_ID_V2_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(OpenbookInstruction::CancelOrderByClientIdV2(args)) => {
                assert_eq!(
                    args.client_order_id, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CancelOrderByClientIdV2)
                );
            }
        }
    }
    #[test]
    fn test_send_take_consistency() {
        let test_args = SendTakeIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SEND_TAKE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(OpenbookInstruction::SendTake(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SendTake)
                );
            }
        }
    }
    #[test]
    fn test_close_open_orders_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CLOSE_OPEN_ORDERS_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            OpenbookInstruction::CloseOpenOrders => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_init_open_orders_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INIT_OPEN_ORDERS_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            OpenbookInstruction::InitOpenOrders => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_prune_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = PruneIxArgs {
            limit: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&PRUNE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(OpenbookInstruction::Prune(args)) => {
                assert_eq!(
                    args.limit, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Prune)
                );
            }
        }
    }
    #[test]
    fn test_consume_events_permissioned_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = ConsumeEventsPermissionedIxArgs {
            limit: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CONSUME_EVENTS_PERMISSIONED_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(OpenbookInstruction::ConsumeEventsPermissioned(args)) => {
                assert_eq!(
                    args.limit, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ConsumeEventsPermissioned)
                );
            }
        }
    }
    #[test]
    fn test_cancel_orders_by_client_ids_consistency() {
        let test_args = CancelOrdersByClientIdsIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CANCEL_ORDERS_BY_CLIENT_IDS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(OpenbookInstruction::CancelOrdersByClientIds(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CancelOrdersByClientIds)
                );
            }
        }
    }
    #[test]
    fn test_replace_order_by_client_id_consistency() {
        let test_args = ReplaceOrderByClientIdIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&REPLACE_ORDER_BY_CLIENT_ID_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(OpenbookInstruction::ReplaceOrderByClientId(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ReplaceOrderByClientId)
                );
            }
        }
    }
    #[test]
    fn test_replace_orders_by_client_ids_consistency() {
        let test_args = ReplaceOrdersByClientIdsIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&REPLACE_ORDERS_BY_CLIENT_IDS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(OpenbookInstruction::ReplaceOrdersByClientIds(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ReplaceOrdersByClientIds)
                );
            }
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_args = InitializeMarketIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializeMarketIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_MARKET_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::InitializeMarket(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_MARKET_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializeMarket)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializeMarket),
                    e
                );
            }
        }
        let test_args = NewOrderIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(NewOrderIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &NEW_ORDER_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::NewOrder(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, NEW_ORDER_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(NewOrder)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(NewOrder),
                    e
                );
            }
        }
        let test_args = MatchOrdersIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(MatchOrdersIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &MATCH_ORDERS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::MatchOrders(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, MATCH_ORDERS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(MatchOrders))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MatchOrders),
                    e
                );
            }
        }
        let test_args = ConsumeEventsIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ConsumeEventsIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CONSUME_EVENTS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::ConsumeEvents(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CONSUME_EVENTS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(ConsumeEvents))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ConsumeEvents),
                    e
                );
            }
        }
        let test_args = CancelOrderIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CancelOrderIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CANCEL_ORDER_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::CancelOrder(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CANCEL_ORDER_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(CancelOrder))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CancelOrder),
                    e
                );
            }
        }
        let test_data = SETTLE_FUNDS_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::SettleFunds => {}
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(SettleFunds))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SettleFunds),
                    e
                );
            }
        }
        let test_args = CancelOrderByClientIdIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CancelOrderByClientIdIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CANCEL_ORDER_BY_CLIENT_ID_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::CancelOrderByClientId(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CANCEL_ORDER_BY_CLIENT_ID_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CancelOrderByClientId)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CancelOrderByClientId),
                    e
                );
            }
        }
        let test_data = DISABLE_MARKET_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::DisableMarket => {}
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(DisableMarket))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(DisableMarket),
                    e
                );
            }
        }
        let test_data = SWEEP_FEES_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::SweepFees => {}
                _ => panic!("Parsed instruction should be {}", stringify!(SweepFees)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SweepFees),
                    e
                );
            }
        }
        let test_args = NewOrderV2IxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(NewOrderV2IxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &NEW_ORDER_V2_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::NewOrderV2(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, NEW_ORDER_V2_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(NewOrderV2))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(NewOrderV2),
                    e
                );
            }
        }
        let test_args = NewOrderV3IxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(NewOrderV3IxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &NEW_ORDER_V3_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::NewOrderV3(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, NEW_ORDER_V3_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(NewOrderV3))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(NewOrderV3),
                    e
                );
            }
        }
        let test_args = CancelOrderV2IxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CancelOrderV2IxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CANCEL_ORDER_V2_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::CancelOrderV2(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CANCEL_ORDER_V2_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(CancelOrderV2))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CancelOrderV2),
                    e
                );
            }
        }
        let test_args = CancelOrderByClientIdV2IxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CancelOrderByClientIdV2IxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CANCEL_ORDER_BY_CLIENT_ID_V2_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::CancelOrderByClientIdV2(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CANCEL_ORDER_BY_CLIENT_ID_V2_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CancelOrderByClientIdV2)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CancelOrderByClientIdV2),
                    e
                );
            }
        }
        let test_args = SendTakeIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SendTakeIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SEND_TAKE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::SendTake(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SEND_TAKE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(SendTake)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SendTake),
                    e
                );
            }
        }
        let test_data = CLOSE_OPEN_ORDERS_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::CloseOpenOrders => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CloseOpenOrders)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CloseOpenOrders),
                    e
                );
            }
        }
        let test_data = INIT_OPEN_ORDERS_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::InitOpenOrders => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitOpenOrders)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitOpenOrders),
                    e
                );
            }
        }
        let test_args = PruneIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(PruneIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &PRUNE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::Prune(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, PRUNE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(Prune)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Prune),
                    e
                );
            }
        }
        let test_args = ConsumeEventsPermissionedIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ConsumeEventsPermissionedIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CONSUME_EVENTS_PERMISSIONED_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::ConsumeEventsPermissioned(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CONSUME_EVENTS_PERMISSIONED_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ConsumeEventsPermissioned)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ConsumeEventsPermissioned),
                    e
                );
            }
        }
        let test_args = CancelOrdersByClientIdsIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CancelOrdersByClientIdsIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CANCEL_ORDERS_BY_CLIENT_IDS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::CancelOrdersByClientIds(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CANCEL_ORDERS_BY_CLIENT_IDS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CancelOrdersByClientIds)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CancelOrdersByClientIds),
                    e
                );
            }
        }
        let test_args = ReplaceOrderByClientIdIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ReplaceOrderByClientIdIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &REPLACE_ORDER_BY_CLIENT_ID_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::ReplaceOrderByClientId(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, REPLACE_ORDER_BY_CLIENT_ID_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ReplaceOrderByClientId)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ReplaceOrderByClientId),
                    e
                );
            }
        }
        let test_args = ReplaceOrdersByClientIdsIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ReplaceOrdersByClientIdsIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &REPLACE_ORDERS_BY_CLIENT_IDS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                OpenbookInstruction::ReplaceOrdersByClientIds(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, REPLACE_ORDERS_BY_CLIENT_IDS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ReplaceOrdersByClientIds)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ReplaceOrdersByClientIds),
                    e
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = parse_instruction(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = parse_instruction(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
