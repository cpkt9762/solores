//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use super::*;
#[derive(Clone, Debug, BorshDeserialize, BorshSerialize, PartialEq, Eq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Amm {
    pub initializer_key: Pubkey,
    pub initializer_deposit_token_account: Pubkey,
    pub initializer_receive_token_account: Pubkey,
    pub initializer_amount: u64,
    pub taker_amount: u64,
    ///Is the swap initialized, with data written to it
    pub is_initialized: bool,
    ///Bump seed used to generate the program address / authority
    pub bump_seed: u8,
    ///Freeze swap
    pub freeze_trade: u8,
    ///Freeze deposit
    pub freeze_deposit: u8,
    ///Freeze withdraw
    pub freeze_withdraw: u8,
    ///Base decimals account
    pub base_decimals: u8,
    ///Token program ID associated with the swap
    pub token_program_id: Pubkey,
    ///Address of token A liquidity account
    pub token_a_account: Pubkey,
    ///Address of token B liquidity account
    pub token_b_account: Pubkey,
    ///Address of pool token mint
    pub pool_mint: Pubkey,
    ///Address of token A mint
    pub token_a_mint: Pubkey,
    ///Address of token B mint
    pub token_b_mint: Pubkey,
    ///Address of pool fee account
    pub fee_account: Pubkey,
    ///Oracle Main account
    pub oracle_main_account: Pubkey,
    ///Oracle Sub account
    pub oracle_sub_account: Pubkey,
    ///oracle Pc account
    pub oracle_pc_account: Pubkey,
    ///Fees associated with swap
    pub fees: AmmFees,
    ///Curve associated with swap
    pub curve: AmmCurve,
    ///Curve associated with swap
    pub config: AmmConfig,
    ///Temp area
    pub amm_p_temp1: Pubkey,
    ///Temp area
    pub amm_p_temp2: Pubkey,
    ///Temp area
    pub amm_p_temp3: Pubkey,
    ///Temp area
    pub amm_p_temp4: Pubkey,
    ///Temp area
    pub amm_p_temp5: Pubkey,
}
impl Default for Amm {
    fn default() -> Self {
        Self {
            initializer_key: Pubkey::default(),
            initializer_deposit_token_account: Pubkey::default(),
            initializer_receive_token_account: Pubkey::default(),
            initializer_amount: Default::default(),
            taker_amount: Default::default(),
            is_initialized: Default::default(),
            bump_seed: Default::default(),
            freeze_trade: Default::default(),
            freeze_deposit: Default::default(),
            freeze_withdraw: Default::default(),
            base_decimals: Default::default(),
            token_program_id: Pubkey::default(),
            token_a_account: Pubkey::default(),
            token_b_account: Pubkey::default(),
            pool_mint: Pubkey::default(),
            token_a_mint: Pubkey::default(),
            token_b_mint: Pubkey::default(),
            fee_account: Pubkey::default(),
            oracle_main_account: Pubkey::default(),
            oracle_sub_account: Pubkey::default(),
            oracle_pc_account: Pubkey::default(),
            fees: Default::default(),
            curve: Default::default(),
            config: Default::default(),
            amm_p_temp1: Pubkey::default(),
            amm_p_temp2: Pubkey::default(),
            amm_p_temp3: Pubkey::default(),
            amm_p_temp4: Pubkey::default(),
            amm_p_temp5: Pubkey::default(),
        }
    }
}
impl Amm {
    pub const LEN: usize = std::mem::size_of::<Self>();
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        borsh::to_vec(self)
    }
    pub fn from_bytes(data: &[u8]) -> Result<Self, std::io::Error> {
        if data.len() != Self::LEN {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!(
                    "Invalid data length. Expected: {}, got: {}",
                    Self::LEN,
                    data.len()
                ),
            ));
        }
        borsh::from_slice(data)
    }
}
