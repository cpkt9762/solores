//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::instructions::*;
pub const SWAP_IX_DISCM: u8 = 0u8;
pub const SWAP_WITH_FREE_FUNDS_IX_DISCM: u8 = 1u8;
pub const PLACE_LIMIT_ORDER_IX_DISCM: u8 = 2u8;
pub const PLACE_LIMIT_ORDER_WITH_FREE_FUNDS_IX_DISCM: u8 = 3u8;
pub const REDUCE_ORDER_IX_DISCM: u8 = 4u8;
pub const REDUCE_ORDER_WITH_FREE_FUNDS_IX_DISCM: u8 = 5u8;
pub const CANCEL_ALL_ORDERS_IX_DISCM: u8 = 6u8;
pub const CANCEL_ALL_ORDERS_WITH_FREE_FUNDS_IX_DISCM: u8 = 7u8;
pub const CANCEL_UP_TO_IX_DISCM: u8 = 8u8;
pub const CANCEL_UP_TO_WITH_FREE_FUNDS_IX_DISCM: u8 = 9u8;
pub const CANCEL_MULTIPLE_ORDERS_BY_ID_IX_DISCM: u8 = 10u8;
pub const CANCEL_MULTIPLE_ORDERS_BY_ID_WITH_FREE_FUNDS_IX_DISCM: u8 = 11u8;
pub const WITHDRAW_FUNDS_IX_DISCM: u8 = 12u8;
pub const DEPOSIT_FUNDS_IX_DISCM: u8 = 13u8;
pub const REQUEST_SEAT_IX_DISCM: u8 = 14u8;
pub const LOG_IX_DISCM: u8 = 15u8;
pub const PLACE_MULTIPLE_POST_ONLY_ORDERS_IX_DISCM: u8 = 16u8;
pub const PLACE_MULTIPLE_POST_ONLY_ORDERS_WITH_FREE_FUNDS_IX_DISCM: u8 = 17u8;
pub const INITIALIZE_MARKET_IX_DISCM: u8 = 100u8;
pub const CLAIM_AUTHORITY_IX_DISCM: u8 = 101u8;
pub const NAME_SUCCESSOR_IX_DISCM: u8 = 102u8;
pub const CHANGE_MARKET_STATUS_IX_DISCM: u8 = 103u8;
pub const CHANGE_SEAT_STATUS_IX_DISCM: u8 = 104u8;
pub const REQUEST_SEAT_AUTHORIZED_IX_DISCM: u8 = 105u8;
pub const EVICT_SEAT_IX_DISCM: u8 = 106u8;
pub const FORCE_CANCEL_ORDERS_IX_DISCM: u8 = 107u8;
pub const COLLECT_FEES_IX_DISCM: u8 = 108u8;
pub const CHANGE_FEE_RECIPIENT_IX_DISCM: u8 = 109u8;
/// Program instruction types
#[derive(Clone, Debug, PartialEq)]
pub enum PhoenixInstruction {
    Swap(SwapIxArgs),
    SwapWithFreeFunds(SwapWithFreeFundsIxArgs),
    PlaceLimitOrder(PlaceLimitOrderIxArgs),
    PlaceLimitOrderWithFreeFunds(PlaceLimitOrderWithFreeFundsIxArgs),
    ReduceOrder(ReduceOrderIxArgs),
    ReduceOrderWithFreeFunds(ReduceOrderWithFreeFundsIxArgs),
    CancelAllOrders,
    CancelAllOrdersWithFreeFunds,
    CancelUpTo(CancelUpToIxArgs),
    CancelUpToWithFreeFunds(CancelUpToWithFreeFundsIxArgs),
    CancelMultipleOrdersById(CancelMultipleOrdersByIdIxArgs),
    CancelMultipleOrdersByIdWithFreeFunds(CancelMultipleOrdersByIdWithFreeFundsIxArgs),
    WithdrawFunds(WithdrawFundsIxArgs),
    DepositFunds(DepositFundsIxArgs),
    RequestSeat,
    Log,
    PlaceMultiplePostOnlyOrders(PlaceMultiplePostOnlyOrdersIxArgs),
    PlaceMultiplePostOnlyOrdersWithFreeFunds(PlaceMultiplePostOnlyOrdersWithFreeFundsIxArgs),
    InitializeMarket(InitializeMarketIxArgs),
    ClaimAuthority,
    NameSuccessor(NameSuccessorIxArgs),
    ChangeMarketStatus(ChangeMarketStatusIxArgs),
    ChangeSeatStatus(ChangeSeatStatusIxArgs),
    RequestSeatAuthorized,
    EvictSeat,
    ForceCancelOrders(ForceCancelOrdersIxArgs),
    CollectFees,
    ChangeFeeRecipient,
}
/// Parse instruction data based on 1-byte discriminator (non-Anchor contracts)
pub fn parse_instruction(data: &[u8]) -> Result<PhoenixInstruction, std::io::Error> {
    if data.is_empty() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data is empty",
        ));
    }
    let discriminator = data[0];
    let mut ix_data = &data[1..];
    match discriminator {
        0u8 => {
            let args = SwapIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::Swap(args))
        }
        1u8 => {
            let args = SwapWithFreeFundsIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::SwapWithFreeFunds(args))
        }
        2u8 => {
            let args = PlaceLimitOrderIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::PlaceLimitOrder(args))
        }
        3u8 => {
            let args = PlaceLimitOrderWithFreeFundsIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::PlaceLimitOrderWithFreeFunds(args))
        }
        4u8 => {
            let args = ReduceOrderIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::ReduceOrder(args))
        }
        5u8 => {
            let args = ReduceOrderWithFreeFundsIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::ReduceOrderWithFreeFunds(args))
        }
        6u8 => Ok(PhoenixInstruction::CancelAllOrders),
        7u8 => Ok(PhoenixInstruction::CancelAllOrdersWithFreeFunds),
        8u8 => {
            let args = CancelUpToIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::CancelUpTo(args))
        }
        9u8 => {
            let args = CancelUpToWithFreeFundsIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::CancelUpToWithFreeFunds(args))
        }
        10u8 => {
            let args = CancelMultipleOrdersByIdIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::CancelMultipleOrdersById(args))
        }
        11u8 => {
            let args = CancelMultipleOrdersByIdWithFreeFundsIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::CancelMultipleOrdersByIdWithFreeFunds(
                args,
            ))
        }
        12u8 => {
            let args = WithdrawFundsIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::WithdrawFunds(args))
        }
        13u8 => {
            let args = DepositFundsIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::DepositFunds(args))
        }
        14u8 => Ok(PhoenixInstruction::RequestSeat),
        15u8 => Ok(PhoenixInstruction::Log),
        16u8 => {
            let args = PlaceMultiplePostOnlyOrdersIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::PlaceMultiplePostOnlyOrders(args))
        }
        17u8 => {
            let args = PlaceMultiplePostOnlyOrdersWithFreeFundsIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::PlaceMultiplePostOnlyOrdersWithFreeFunds(args))
        }
        18u8 => {
            let args = InitializeMarketIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::InitializeMarket(args))
        }
        19u8 => Ok(PhoenixInstruction::ClaimAuthority),
        20u8 => {
            let args = NameSuccessorIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::NameSuccessor(args))
        }
        21u8 => {
            let args = ChangeMarketStatusIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::ChangeMarketStatus(args))
        }
        22u8 => {
            let args = ChangeSeatStatusIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::ChangeSeatStatus(args))
        }
        23u8 => Ok(PhoenixInstruction::RequestSeatAuthorized),
        24u8 => Ok(PhoenixInstruction::EvictSeat),
        25u8 => {
            let args = ForceCancelOrdersIxArgs::deserialize(&mut ix_data)?;
            Ok(PhoenixInstruction::ForceCancelOrders(args))
        }
        26u8 => Ok(PhoenixInstruction::CollectFees),
        27u8 => Ok(PhoenixInstruction::ChangeFeeRecipient),
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {}", discriminator),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_swap_consistency() {
        let test_args = SwapIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SWAP_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::Swap(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Swap)
                );
            }
        }
    }
    #[test]
    fn test_swap_with_free_funds_consistency() {
        let test_args = SwapWithFreeFundsIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SWAP_WITH_FREE_FUNDS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::SwapWithFreeFunds(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SwapWithFreeFunds)
                );
            }
        }
    }
    #[test]
    fn test_place_limit_order_consistency() {
        let test_args = PlaceLimitOrderIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&PLACE_LIMIT_ORDER_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::PlaceLimitOrder(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(PlaceLimitOrder)
                );
            }
        }
    }
    #[test]
    fn test_place_limit_order_with_free_funds_consistency() {
        let test_args = PlaceLimitOrderWithFreeFundsIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&PLACE_LIMIT_ORDER_WITH_FREE_FUNDS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::PlaceLimitOrderWithFreeFunds(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(PlaceLimitOrderWithFreeFunds)
                );
            }
        }
    }
    #[test]
    fn test_reduce_order_consistency() {
        let test_args = ReduceOrderIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&REDUCE_ORDER_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::ReduceOrder(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ReduceOrder)
                );
            }
        }
    }
    #[test]
    fn test_reduce_order_with_free_funds_consistency() {
        let test_args = ReduceOrderWithFreeFundsIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&REDUCE_ORDER_WITH_FREE_FUNDS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::ReduceOrderWithFreeFunds(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ReduceOrderWithFreeFunds)
                );
            }
        }
    }
    #[test]
    fn test_cancel_all_orders_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CANCEL_ALL_ORDERS_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            PhoenixInstruction::CancelAllOrders => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_cancel_all_orders_with_free_funds_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CANCEL_ALL_ORDERS_WITH_FREE_FUNDS_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            PhoenixInstruction::CancelAllOrdersWithFreeFunds => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_cancel_up_to_consistency() {
        let test_args = CancelUpToIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CANCEL_UP_TO_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::CancelUpTo(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CancelUpTo)
                );
            }
        }
    }
    #[test]
    fn test_cancel_up_to_with_free_funds_consistency() {
        let test_args = CancelUpToWithFreeFundsIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CANCEL_UP_TO_WITH_FREE_FUNDS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::CancelUpToWithFreeFunds(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CancelUpToWithFreeFunds)
                );
            }
        }
    }
    #[test]
    fn test_cancel_multiple_orders_by_id_consistency() {
        let test_args = CancelMultipleOrdersByIdIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CANCEL_MULTIPLE_ORDERS_BY_ID_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::CancelMultipleOrdersById(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CancelMultipleOrdersById)
                );
            }
        }
    }
    #[test]
    fn test_cancel_multiple_orders_by_id_with_free_funds_consistency() {
        let test_args = CancelMultipleOrdersByIdWithFreeFundsIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CANCEL_MULTIPLE_ORDERS_BY_ID_WITH_FREE_FUNDS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::CancelMultipleOrdersByIdWithFreeFunds(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CancelMultipleOrdersByIdWithFreeFunds)
                );
            }
        }
    }
    #[test]
    fn test_withdraw_funds_consistency() {
        let test_args = WithdrawFundsIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&WITHDRAW_FUNDS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::WithdrawFunds(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(WithdrawFunds)
                );
            }
        }
    }
    #[test]
    fn test_deposit_funds_consistency() {
        let test_args = DepositFundsIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&DEPOSIT_FUNDS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::DepositFunds(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(DepositFunds)
                );
            }
        }
    }
    #[test]
    fn test_request_seat_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&REQUEST_SEAT_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            PhoenixInstruction::RequestSeat => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_log_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&LOG_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            PhoenixInstruction::Log => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_place_multiple_post_only_orders_consistency() {
        let test_args = PlaceMultiplePostOnlyOrdersIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&PLACE_MULTIPLE_POST_ONLY_ORDERS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::PlaceMultiplePostOnlyOrders(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(PlaceMultiplePostOnlyOrders)
                );
            }
        }
    }
    #[test]
    fn test_place_multiple_post_only_orders_with_free_funds_consistency() {
        let test_args = PlaceMultiplePostOnlyOrdersWithFreeFundsIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&PLACE_MULTIPLE_POST_ONLY_ORDERS_WITH_FREE_FUNDS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::PlaceMultiplePostOnlyOrdersWithFreeFunds(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(PlaceMultiplePostOnlyOrdersWithFreeFunds)
                );
            }
        }
    }
    #[test]
    fn test_initialize_market_consistency() {
        let test_args = InitializeMarketIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_MARKET_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::InitializeMarket(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializeMarket)
                );
            }
        }
    }
    #[test]
    fn test_claim_authority_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CLAIM_AUTHORITY_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            PhoenixInstruction::ClaimAuthority => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_name_successor_consistency() {
        let expected_first_arg = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_args = NameSuccessorIxArgs {
            successor: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&NAME_SUCCESSOR_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::NameSuccessor(args)) => {
                assert_eq!(
                    args.successor, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(NameSuccessor)
                );
            }
        }
    }
    #[test]
    fn test_change_market_status_consistency() {
        let test_args = ChangeMarketStatusIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CHANGE_MARKET_STATUS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::ChangeMarketStatus(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ChangeMarketStatus)
                );
            }
        }
    }
    #[test]
    fn test_change_seat_status_consistency() {
        let test_args = ChangeSeatStatusIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CHANGE_SEAT_STATUS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::ChangeSeatStatus(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ChangeSeatStatus)
                );
            }
        }
    }
    #[test]
    fn test_request_seat_authorized_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&REQUEST_SEAT_AUTHORIZED_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            PhoenixInstruction::RequestSeatAuthorized => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_evict_seat_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&EVICT_SEAT_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            PhoenixInstruction::EvictSeat => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_force_cancel_orders_consistency() {
        let test_args = ForceCancelOrdersIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&FORCE_CANCEL_ORDERS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PhoenixInstruction::ForceCancelOrders(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ForceCancelOrders)
                );
            }
        }
    }
    #[test]
    fn test_collect_fees_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&COLLECT_FEES_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            PhoenixInstruction::CollectFees => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_change_fee_recipient_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CHANGE_FEE_RECIPIENT_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            PhoenixInstruction::ChangeFeeRecipient => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_args = SwapIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SwapIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SWAP_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::Swap(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SWAP_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(Swap)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Swap),
                    e
                );
            }
        }
        let test_args = SwapWithFreeFundsIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SwapWithFreeFundsIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SWAP_WITH_FREE_FUNDS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::SwapWithFreeFunds(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SWAP_WITH_FREE_FUNDS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SwapWithFreeFunds)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SwapWithFreeFunds),
                    e
                );
            }
        }
        let test_args = PlaceLimitOrderIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(PlaceLimitOrderIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &PLACE_LIMIT_ORDER_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::PlaceLimitOrder(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, PLACE_LIMIT_ORDER_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(PlaceLimitOrder)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(PlaceLimitOrder),
                    e
                );
            }
        }
        let test_args = PlaceLimitOrderWithFreeFundsIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(PlaceLimitOrderWithFreeFundsIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &PLACE_LIMIT_ORDER_WITH_FREE_FUNDS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::PlaceLimitOrderWithFreeFunds(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, PLACE_LIMIT_ORDER_WITH_FREE_FUNDS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(PlaceLimitOrderWithFreeFunds)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(PlaceLimitOrderWithFreeFunds),
                    e
                );
            }
        }
        let test_args = ReduceOrderIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ReduceOrderIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &REDUCE_ORDER_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::ReduceOrder(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, REDUCE_ORDER_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(ReduceOrder))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ReduceOrder),
                    e
                );
            }
        }
        let test_args = ReduceOrderWithFreeFundsIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ReduceOrderWithFreeFundsIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &REDUCE_ORDER_WITH_FREE_FUNDS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::ReduceOrderWithFreeFunds(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, REDUCE_ORDER_WITH_FREE_FUNDS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ReduceOrderWithFreeFunds)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ReduceOrderWithFreeFunds),
                    e
                );
            }
        }
        let test_data = CANCEL_ALL_ORDERS_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::CancelAllOrders => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CancelAllOrders)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CancelAllOrders),
                    e
                );
            }
        }
        let test_data = CANCEL_ALL_ORDERS_WITH_FREE_FUNDS_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::CancelAllOrdersWithFreeFunds => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CancelAllOrdersWithFreeFunds)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CancelAllOrdersWithFreeFunds),
                    e
                );
            }
        }
        let test_args = CancelUpToIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CancelUpToIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CANCEL_UP_TO_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::CancelUpTo(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CANCEL_UP_TO_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(CancelUpTo))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CancelUpTo),
                    e
                );
            }
        }
        let test_args = CancelUpToWithFreeFundsIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CancelUpToWithFreeFundsIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CANCEL_UP_TO_WITH_FREE_FUNDS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::CancelUpToWithFreeFunds(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CANCEL_UP_TO_WITH_FREE_FUNDS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CancelUpToWithFreeFunds)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CancelUpToWithFreeFunds),
                    e
                );
            }
        }
        let test_args = CancelMultipleOrdersByIdIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CancelMultipleOrdersByIdIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CANCEL_MULTIPLE_ORDERS_BY_ID_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::CancelMultipleOrdersById(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CANCEL_MULTIPLE_ORDERS_BY_ID_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CancelMultipleOrdersById)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CancelMultipleOrdersById),
                    e
                );
            }
        }
        let test_args = CancelMultipleOrdersByIdWithFreeFundsIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CancelMultipleOrdersByIdWithFreeFundsIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CANCEL_MULTIPLE_ORDERS_BY_ID_WITH_FREE_FUNDS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::CancelMultipleOrdersByIdWithFreeFunds(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator,
                        CANCEL_MULTIPLE_ORDERS_BY_ID_WITH_FREE_FUNDS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CancelMultipleOrdersByIdWithFreeFunds)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CancelMultipleOrdersByIdWithFreeFunds),
                    e
                );
            }
        }
        let test_args = WithdrawFundsIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(WithdrawFundsIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &WITHDRAW_FUNDS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::WithdrawFunds(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, WITHDRAW_FUNDS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(WithdrawFunds))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(WithdrawFunds),
                    e
                );
            }
        }
        let test_args = DepositFundsIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(DepositFundsIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &DEPOSIT_FUNDS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::DepositFunds(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, DEPOSIT_FUNDS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(DepositFunds))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(DepositFunds),
                    e
                );
            }
        }
        let test_data = REQUEST_SEAT_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::RequestSeat => {}
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(RequestSeat))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(RequestSeat),
                    e
                );
            }
        }
        let test_data = LOG_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::Log => {}
                _ => panic!("Parsed instruction should be {}", stringify!(Log)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Log),
                    e
                );
            }
        }
        let test_args = PlaceMultiplePostOnlyOrdersIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(PlaceMultiplePostOnlyOrdersIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &PLACE_MULTIPLE_POST_ONLY_ORDERS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::PlaceMultiplePostOnlyOrders(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, PLACE_MULTIPLE_POST_ONLY_ORDERS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(PlaceMultiplePostOnlyOrders)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(PlaceMultiplePostOnlyOrders),
                    e
                );
            }
        }
        let test_args = PlaceMultiplePostOnlyOrdersWithFreeFundsIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(PlaceMultiplePostOnlyOrdersWithFreeFundsIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &PLACE_MULTIPLE_POST_ONLY_ORDERS_WITH_FREE_FUNDS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::PlaceMultiplePostOnlyOrdersWithFreeFunds(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator,
                        PLACE_MULTIPLE_POST_ONLY_ORDERS_WITH_FREE_FUNDS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(PlaceMultiplePostOnlyOrdersWithFreeFunds)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(PlaceMultiplePostOnlyOrdersWithFreeFunds),
                    e
                );
            }
        }
        let test_args = InitializeMarketIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializeMarketIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_MARKET_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::InitializeMarket(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_MARKET_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializeMarket)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializeMarket),
                    e
                );
            }
        }
        let test_data = CLAIM_AUTHORITY_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::ClaimAuthority => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ClaimAuthority)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ClaimAuthority),
                    e
                );
            }
        }
        let test_args = NameSuccessorIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(NameSuccessorIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &NAME_SUCCESSOR_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::NameSuccessor(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, NAME_SUCCESSOR_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(NameSuccessor))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(NameSuccessor),
                    e
                );
            }
        }
        let test_args = ChangeMarketStatusIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ChangeMarketStatusIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CHANGE_MARKET_STATUS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::ChangeMarketStatus(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CHANGE_MARKET_STATUS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ChangeMarketStatus)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ChangeMarketStatus),
                    e
                );
            }
        }
        let test_args = ChangeSeatStatusIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ChangeSeatStatusIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CHANGE_SEAT_STATUS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::ChangeSeatStatus(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CHANGE_SEAT_STATUS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ChangeSeatStatus)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ChangeSeatStatus),
                    e
                );
            }
        }
        let test_data = REQUEST_SEAT_AUTHORIZED_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::RequestSeatAuthorized => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(RequestSeatAuthorized)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(RequestSeatAuthorized),
                    e
                );
            }
        }
        let test_data = EVICT_SEAT_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::EvictSeat => {}
                _ => panic!("Parsed instruction should be {}", stringify!(EvictSeat)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(EvictSeat),
                    e
                );
            }
        }
        let test_args = ForceCancelOrdersIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ForceCancelOrdersIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &FORCE_CANCEL_ORDERS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::ForceCancelOrders(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, FORCE_CANCEL_ORDERS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ForceCancelOrders)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ForceCancelOrders),
                    e
                );
            }
        }
        let test_data = COLLECT_FEES_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::CollectFees => {}
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(CollectFees))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CollectFees),
                    e
                );
            }
        }
        let test_data = CHANGE_FEE_RECIPIENT_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PhoenixInstruction::ChangeFeeRecipient => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ChangeFeeRecipient)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ChangeFeeRecipient),
                    e
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = parse_instruction(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = parse_instruction(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
