//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::instructions::*;
pub const INITIALIZE_IX_DISCM: u8 = 0u8;
pub const SET_PARAMS_IX_DISCM: u8 = 1u8;
pub const CREATE_IX_DISCM: u8 = 2u8;
pub const BUY_IX_DISCM: u8 = 3u8;
pub const SELL_IX_DISCM: u8 = 4u8;
pub const WITHDRAW_IX_DISCM: u8 = 5u8;
/// Program instruction types
#[derive(Clone, Debug, PartialEq)]
pub enum PumpfunInstruction {
    ///Creates the global state.
    Initialize,
    ///Sets the global state parameters.
    SetParams(SetParamsIxArgs),
    ///Creates a new coin and bonding curve.
    Create(CreateIxArgs),
    ///Buys tokens from a bonding curve.
    Buy(BuyIxArgs),
    ///Sells tokens into a bonding curve.
    Sell(SellIxArgs),
    ///Allows the admin to withdraw liquidity for a migration once the bonding curve completes
    Withdraw,
}
/// Parse instruction data based on 1-byte discriminator (non-Anchor contracts)
pub fn parse_instruction(data: &[u8]) -> Result<PumpfunInstruction, std::io::Error> {
    if data.is_empty() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data is empty",
        ));
    }
    let discriminator = data[0];
    let mut ix_data = &data[1..];
    match discriminator {
        0u8 => Ok(PumpfunInstruction::Initialize),
        1u8 => {
            let args = SetParamsIxArgs::deserialize(&mut ix_data)?;
            Ok(PumpfunInstruction::SetParams(args))
        }
        2u8 => {
            let args = CreateIxArgs::deserialize(&mut ix_data)?;
            Ok(PumpfunInstruction::Create(args))
        }
        3u8 => {
            let args = BuyIxArgs::deserialize(&mut ix_data)?;
            Ok(PumpfunInstruction::Buy(args))
        }
        4u8 => {
            let args = SellIxArgs::deserialize(&mut ix_data)?;
            Ok(PumpfunInstruction::Sell(args))
        }
        5u8 => Ok(PumpfunInstruction::Withdraw),
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {}", discriminator),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_initialize_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            PumpfunInstruction::Initialize => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_set_params_consistency() {
        let expected_first_arg = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_args = SetParamsIxArgs {
            fee_recipient: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_PARAMS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PumpfunInstruction::SetParams(args)) => {
                assert_eq!(
                    args.fee_recipient, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SetParams)
                );
            }
        }
    }
    #[test]
    fn test_create_consistency() {
        let expected_first_arg = "test".to_string();
        let test_args = CreateIxArgs {
            name: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PumpfunInstruction::Create(args)) => {
                assert_eq!(
                    args.name, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Create)
                );
            }
        }
    }
    #[test]
    fn test_buy_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = BuyIxArgs {
            amount: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&BUY_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PumpfunInstruction::Buy(args)) => {
                assert_eq!(
                    args.amount, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Buy)
                );
            }
        }
    }
    #[test]
    fn test_sell_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = SellIxArgs {
            amount: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SELL_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PumpfunInstruction::Sell(args)) => {
                assert_eq!(
                    args.amount, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Sell)
                );
            }
        }
    }
    #[test]
    fn test_withdraw_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&WITHDRAW_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            PumpfunInstruction::Withdraw => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_data = INITIALIZE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PumpfunInstruction::Initialize => {}
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(Initialize))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Initialize),
                    e
                );
            }
        }
        let test_args = SetParamsIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SetParamsIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SET_PARAMS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PumpfunInstruction::SetParams(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SET_PARAMS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(SetParams)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetParams),
                    e
                );
            }
        }
        let test_args = CreateIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CreateIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CREATE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PumpfunInstruction::Create(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CREATE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(Create)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Create),
                    e
                );
            }
        }
        let test_args = BuyIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(BuyIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &BUY_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PumpfunInstruction::Buy(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, BUY_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(Buy)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Buy),
                    e
                );
            }
        }
        let test_args = SellIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SellIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SELL_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PumpfunInstruction::Sell(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SELL_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(Sell)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Sell),
                    e
                );
            }
        }
        let test_data = WITHDRAW_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PumpfunInstruction::Withdraw => {}
                _ => panic!("Parsed instruction should be {}", stringify!(Withdraw)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Withdraw),
                    e
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = parse_instruction(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = parse_instruction(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
