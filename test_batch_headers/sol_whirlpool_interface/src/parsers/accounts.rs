//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::accounts::*;
/// Program account types
#[derive(Clone, Debug, PartialEq)]
pub enum WhirlpoolAccount {
    WhirlpoolsConfigExtension(WhirlpoolsConfigExtension),
    WhirlpoolsConfig(WhirlpoolsConfig),
    FeeTier(FeeTier),
    PositionBundle(PositionBundle),
    Position(Position),
    TickArray(TickArray),
    TokenBadge(TokenBadge),
    Whirlpool(Whirlpool),
}
/// Parse account data based on data length (non-Anchor contracts)
pub fn try_unpack_account(data: &[u8]) -> Result<WhirlpoolAccount, std::io::Error> {
    let data_len = data.len();
    const WHIRLPOOLS_CONFIG_EXTENSION_LEN: usize = std::mem::size_of::<WhirlpoolsConfigExtension>();
    const WHIRLPOOLS_CONFIG_LEN: usize = std::mem::size_of::<WhirlpoolsConfig>();
    const FEE_TIER_LEN: usize = std::mem::size_of::<FeeTier>();
    const POSITION_BUNDLE_LEN: usize = std::mem::size_of::<PositionBundle>();
    const POSITION_LEN: usize = std::mem::size_of::<Position>();
    const TICK_ARRAY_LEN: usize = std::mem::size_of::<TickArray>();
    const TOKEN_BADGE_LEN: usize = std::mem::size_of::<TokenBadge>();
    const WHIRLPOOL_LEN: usize = std::mem::size_of::<Whirlpool>();
    match data_len {
        WHIRLPOOLS_CONFIG_EXTENSION_LEN => Ok(WhirlpoolAccount::WhirlpoolsConfigExtension(
            WhirlpoolsConfigExtension::from_bytes(data)?,
        )),
        WHIRLPOOLS_CONFIG_LEN => Ok(WhirlpoolAccount::WhirlpoolsConfig(
            WhirlpoolsConfig::from_bytes(data)?,
        )),
        FEE_TIER_LEN => Ok(WhirlpoolAccount::FeeTier(FeeTier::from_bytes(data)?)),
        POSITION_BUNDLE_LEN => Ok(WhirlpoolAccount::PositionBundle(
            PositionBundle::from_bytes(data)?,
        )),
        POSITION_LEN => Ok(WhirlpoolAccount::Position(Position::from_bytes(data)?)),
        TICK_ARRAY_LEN => Ok(WhirlpoolAccount::TickArray(TickArray::from_bytes(data)?)),
        TOKEN_BADGE_LEN => Ok(WhirlpoolAccount::TokenBadge(TokenBadge::from_bytes(data)?)),
        WHIRLPOOL_LEN => Ok(WhirlpoolAccount::Whirlpool(Whirlpool::from_bytes(data)?)),
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Invalid Account data length: {}", data_len),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    use borsh::{BorshDeserialize, BorshSerialize};
    #[test]
    fn test_whirlpools_config_extension_consistency() {
        let expected_first_field = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_account = WhirlpoolsConfigExtension {
            whirlpools_config: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(WhirlpoolAccount::WhirlpoolsConfigExtension(account)) => {
                assert_eq!(
                    account.whirlpools_config, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [2u8, 99u8, 215u8, 163u8, 240u8, 26u8, 153u8, 58u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(WhirlpoolsConfigExtension)
                );
            }
        }
    }
    #[test]
    fn test_whirlpools_config_consistency() {
        let expected_first_field = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_account = WhirlpoolsConfig {
            fee_authority: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(WhirlpoolAccount::WhirlpoolsConfig(account)) => {
                assert_eq!(
                    account.fee_authority, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [157u8, 20u8, 49u8, 224u8, 217u8, 87u8, 193u8, 254u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(WhirlpoolsConfig)
                );
            }
        }
    }
    #[test]
    fn test_fee_tier_consistency() {
        let expected_first_field = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_account = FeeTier {
            whirlpools_config: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(WhirlpoolAccount::FeeTier(account)) => {
                assert_eq!(
                    account.whirlpools_config, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [56u8, 75u8, 159u8, 76u8, 142u8, 68u8, 190u8, 105u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(FeeTier)
                );
            }
        }
    }
    #[test]
    fn test_position_bundle_consistency() {
        let expected_first_field = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_account = PositionBundle {
            position_bundle_mint: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(WhirlpoolAccount::PositionBundle(account)) => {
                assert_eq!(
                    account.position_bundle_mint, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [129u8, 169u8, 175u8, 65u8, 185u8, 95u8, 32u8, 100u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(PositionBundle)
                );
            }
        }
    }
    #[test]
    fn test_position_consistency() {
        let expected_first_field = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_account = Position {
            whirlpool: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(WhirlpoolAccount::Position(account)) => {
                assert_eq!(
                    account.whirlpool, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [170u8, 188u8, 143u8, 228u8, 122u8, 64u8, 247u8, 208u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Position)
                );
            }
        }
    }
    #[test]
    fn test_tick_array_consistency() {
        let expected_first_field = 42i32;
        let test_account = TickArray {
            start_tick_index: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(WhirlpoolAccount::TickArray(account)) => {
                assert_eq!(
                    account.start_tick_index, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [69u8, 97u8, 189u8, 190u8, 110u8, 7u8, 66u8, 187u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(TickArray)
                );
            }
        }
    }
    #[test]
    fn test_token_badge_consistency() {
        let expected_first_field = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_account = TokenBadge {
            whirlpools_config: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(WhirlpoolAccount::TokenBadge(account)) => {
                assert_eq!(
                    account.whirlpools_config, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [116u8, 219u8, 204u8, 229u8, 249u8, 116u8, 255u8, 150u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(TokenBadge)
                );
            }
        }
    }
    #[test]
    fn test_whirlpool_consistency() {
        let expected_first_field = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_account = Whirlpool {
            whirlpools_config: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(WhirlpoolAccount::Whirlpool(account)) => {
                assert_eq!(
                    account.whirlpools_config, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [63u8, 149u8, 209u8, 12u8, 225u8, 128u8, 99u8, 9u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Whirlpool)
                );
            }
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_account = WhirlpoolsConfigExtension::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            WhirlpoolsConfigExtension::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(WhirlpoolsConfigExtension)
                );
            }
        }
        let test_account = WhirlpoolsConfig::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            WhirlpoolsConfig::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(WhirlpoolsConfig)
                );
            }
        }
        let test_account = FeeTier::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            FeeTier::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(FeeTier)
                );
            }
        }
        let test_account = PositionBundle::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            PositionBundle::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(PositionBundle)
                );
            }
        }
        let test_account = Position::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            Position::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(Position)
                );
            }
        }
        let test_account = TickArray::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            TickArray::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(TickArray)
                );
            }
        }
        let test_account = TokenBadge::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            TokenBadge::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(TokenBadge)
                );
            }
        }
        let test_account = Whirlpool::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            Whirlpool::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(Whirlpool)
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = try_unpack_account(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = try_unpack_account(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
