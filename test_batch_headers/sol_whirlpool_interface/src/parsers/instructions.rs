//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::instructions::*;
pub const INITIALIZE_CONFIG_IX_DISCM: u8 = 0u8;
pub const INITIALIZE_POOL_IX_DISCM: u8 = 1u8;
pub const INITIALIZE_TICK_ARRAY_IX_DISCM: u8 = 2u8;
pub const INITIALIZE_FEE_TIER_IX_DISCM: u8 = 3u8;
pub const INITIALIZE_REWARD_IX_DISCM: u8 = 4u8;
pub const SET_REWARD_EMISSIONS_IX_DISCM: u8 = 5u8;
pub const OPEN_POSITION_IX_DISCM: u8 = 6u8;
pub const OPEN_POSITION_WITH_METADATA_IX_DISCM: u8 = 7u8;
pub const INCREASE_LIQUIDITY_IX_DISCM: u8 = 8u8;
pub const DECREASE_LIQUIDITY_IX_DISCM: u8 = 9u8;
pub const UPDATE_FEES_AND_REWARDS_IX_DISCM: u8 = 10u8;
pub const COLLECT_FEES_IX_DISCM: u8 = 11u8;
pub const COLLECT_REWARD_IX_DISCM: u8 = 12u8;
pub const COLLECT_PROTOCOL_FEES_IX_DISCM: u8 = 13u8;
pub const SWAP_IX_DISCM: u8 = 14u8;
pub const CLOSE_POSITION_IX_DISCM: u8 = 15u8;
pub const SET_DEFAULT_FEE_RATE_IX_DISCM: u8 = 16u8;
pub const SET_DEFAULT_PROTOCOL_FEE_RATE_IX_DISCM: u8 = 17u8;
pub const SET_FEE_RATE_IX_DISCM: u8 = 18u8;
pub const SET_PROTOCOL_FEE_RATE_IX_DISCM: u8 = 19u8;
pub const SET_FEE_AUTHORITY_IX_DISCM: u8 = 20u8;
pub const SET_COLLECT_PROTOCOL_FEES_AUTHORITY_IX_DISCM: u8 = 21u8;
pub const SET_REWARD_AUTHORITY_IX_DISCM: u8 = 22u8;
pub const SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_IX_DISCM: u8 = 23u8;
pub const SET_REWARD_EMISSIONS_SUPER_AUTHORITY_IX_DISCM: u8 = 24u8;
pub const TWO_HOP_SWAP_IX_DISCM: u8 = 25u8;
pub const INITIALIZE_POSITION_BUNDLE_IX_DISCM: u8 = 26u8;
pub const INITIALIZE_POSITION_BUNDLE_WITH_METADATA_IX_DISCM: u8 = 27u8;
pub const DELETE_POSITION_BUNDLE_IX_DISCM: u8 = 28u8;
pub const OPEN_BUNDLED_POSITION_IX_DISCM: u8 = 29u8;
pub const CLOSE_BUNDLED_POSITION_IX_DISCM: u8 = 30u8;
pub const COLLECT_FEES_V2_IX_DISCM: u8 = 31u8;
pub const COLLECT_PROTOCOL_FEES_V2_IX_DISCM: u8 = 32u8;
pub const COLLECT_REWARD_V2_IX_DISCM: u8 = 33u8;
pub const DECREASE_LIQUIDITY_V2_IX_DISCM: u8 = 34u8;
pub const INCREASE_LIQUIDITY_V2_IX_DISCM: u8 = 35u8;
pub const INITIALIZE_POOL_V2_IX_DISCM: u8 = 36u8;
pub const INITIALIZE_REWARD_V2_IX_DISCM: u8 = 37u8;
pub const SET_REWARD_EMISSIONS_V2_IX_DISCM: u8 = 38u8;
pub const SWAP_V2_IX_DISCM: u8 = 39u8;
pub const TWO_HOP_SWAP_V2_IX_DISCM: u8 = 40u8;
pub const INITIALIZE_CONFIG_EXTENSION_IX_DISCM: u8 = 41u8;
pub const SET_CONFIG_EXTENSION_AUTHORITY_IX_DISCM: u8 = 42u8;
pub const SET_TOKEN_BADGE_AUTHORITY_IX_DISCM: u8 = 43u8;
pub const INITIALIZE_TOKEN_BADGE_IX_DISCM: u8 = 44u8;
pub const DELETE_TOKEN_BADGE_IX_DISCM: u8 = 45u8;
/// Program instruction types
#[derive(Clone, Debug, PartialEq)]
pub enum WhirlpoolInstruction {
    InitializeConfig(InitializeConfigIxArgs),
    InitializePool(InitializePoolIxArgs),
    InitializeTickArray(InitializeTickArrayIxArgs),
    InitializeFeeTier(InitializeFeeTierIxArgs),
    InitializeReward(InitializeRewardIxArgs),
    SetRewardEmissions(SetRewardEmissionsIxArgs),
    OpenPosition(OpenPositionIxArgs),
    OpenPositionWithMetadata(OpenPositionWithMetadataIxArgs),
    IncreaseLiquidity(IncreaseLiquidityIxArgs),
    DecreaseLiquidity(DecreaseLiquidityIxArgs),
    UpdateFeesAndRewards,
    CollectFees,
    CollectReward(CollectRewardIxArgs),
    CollectProtocolFees,
    Swap(SwapIxArgs),
    ClosePosition,
    SetDefaultFeeRate(SetDefaultFeeRateIxArgs),
    SetDefaultProtocolFeeRate(SetDefaultProtocolFeeRateIxArgs),
    SetFeeRate(SetFeeRateIxArgs),
    SetProtocolFeeRate(SetProtocolFeeRateIxArgs),
    SetFeeAuthority,
    SetCollectProtocolFeesAuthority,
    SetRewardAuthority(SetRewardAuthorityIxArgs),
    SetRewardAuthorityBySuperAuthority(SetRewardAuthorityBySuperAuthorityIxArgs),
    SetRewardEmissionsSuperAuthority,
    TwoHopSwap(TwoHopSwapIxArgs),
    InitializePositionBundle,
    InitializePositionBundleWithMetadata,
    DeletePositionBundle,
    OpenBundledPosition(OpenBundledPositionIxArgs),
    CloseBundledPosition(CloseBundledPositionIxArgs),
    CollectFeesV2(CollectFeesV2IxArgs),
    CollectProtocolFeesV2(CollectProtocolFeesV2IxArgs),
    CollectRewardV2(CollectRewardV2IxArgs),
    DecreaseLiquidityV2(DecreaseLiquidityV2IxArgs),
    IncreaseLiquidityV2(IncreaseLiquidityV2IxArgs),
    InitializePoolV2(InitializePoolV2IxArgs),
    InitializeRewardV2(InitializeRewardV2IxArgs),
    SetRewardEmissionsV2(SetRewardEmissionsV2IxArgs),
    SwapV2(SwapV2IxArgs),
    TwoHopSwapV2(TwoHopSwapV2IxArgs),
    InitializeConfigExtension,
    SetConfigExtensionAuthority,
    SetTokenBadgeAuthority,
    InitializeTokenBadge,
    DeleteTokenBadge,
}
/// Parse instruction data based on 1-byte discriminator (non-Anchor contracts)
pub fn parse_instruction(data: &[u8]) -> Result<WhirlpoolInstruction, std::io::Error> {
    if data.is_empty() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data is empty",
        ));
    }
    let discriminator = data[0];
    let mut ix_data = &data[1..];
    match discriminator {
        0u8 => {
            let args = InitializeConfigIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::InitializeConfig(args))
        }
        1u8 => {
            let args = InitializePoolIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::InitializePool(args))
        }
        2u8 => {
            let args = InitializeTickArrayIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::InitializeTickArray(args))
        }
        3u8 => {
            let args = InitializeFeeTierIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::InitializeFeeTier(args))
        }
        4u8 => {
            let args = InitializeRewardIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::InitializeReward(args))
        }
        5u8 => {
            let args = SetRewardEmissionsIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::SetRewardEmissions(args))
        }
        6u8 => {
            let args = OpenPositionIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::OpenPosition(args))
        }
        7u8 => {
            let args = OpenPositionWithMetadataIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::OpenPositionWithMetadata(args))
        }
        8u8 => {
            let args = IncreaseLiquidityIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::IncreaseLiquidity(args))
        }
        9u8 => {
            let args = DecreaseLiquidityIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::DecreaseLiquidity(args))
        }
        10u8 => Ok(WhirlpoolInstruction::UpdateFeesAndRewards),
        11u8 => Ok(WhirlpoolInstruction::CollectFees),
        12u8 => {
            let args = CollectRewardIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::CollectReward(args))
        }
        13u8 => Ok(WhirlpoolInstruction::CollectProtocolFees),
        14u8 => {
            let args = SwapIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::Swap(args))
        }
        15u8 => Ok(WhirlpoolInstruction::ClosePosition),
        16u8 => {
            let args = SetDefaultFeeRateIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::SetDefaultFeeRate(args))
        }
        17u8 => {
            let args = SetDefaultProtocolFeeRateIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::SetDefaultProtocolFeeRate(args))
        }
        18u8 => {
            let args = SetFeeRateIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::SetFeeRate(args))
        }
        19u8 => {
            let args = SetProtocolFeeRateIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::SetProtocolFeeRate(args))
        }
        20u8 => Ok(WhirlpoolInstruction::SetFeeAuthority),
        21u8 => Ok(WhirlpoolInstruction::SetCollectProtocolFeesAuthority),
        22u8 => {
            let args = SetRewardAuthorityIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::SetRewardAuthority(args))
        }
        23u8 => {
            let args = SetRewardAuthorityBySuperAuthorityIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::SetRewardAuthorityBySuperAuthority(
                args,
            ))
        }
        24u8 => Ok(WhirlpoolInstruction::SetRewardEmissionsSuperAuthority),
        25u8 => {
            let args = TwoHopSwapIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::TwoHopSwap(args))
        }
        26u8 => Ok(WhirlpoolInstruction::InitializePositionBundle),
        27u8 => Ok(WhirlpoolInstruction::InitializePositionBundleWithMetadata),
        28u8 => Ok(WhirlpoolInstruction::DeletePositionBundle),
        29u8 => {
            let args = OpenBundledPositionIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::OpenBundledPosition(args))
        }
        30u8 => {
            let args = CloseBundledPositionIxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::CloseBundledPosition(args))
        }
        31u8 => {
            let args = CollectFeesV2IxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::CollectFeesV2(args))
        }
        32u8 => {
            let args = CollectProtocolFeesV2IxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::CollectProtocolFeesV2(args))
        }
        33u8 => {
            let args = CollectRewardV2IxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::CollectRewardV2(args))
        }
        34u8 => {
            let args = DecreaseLiquidityV2IxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::DecreaseLiquidityV2(args))
        }
        35u8 => {
            let args = IncreaseLiquidityV2IxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::IncreaseLiquidityV2(args))
        }
        36u8 => {
            let args = InitializePoolV2IxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::InitializePoolV2(args))
        }
        37u8 => {
            let args = InitializeRewardV2IxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::InitializeRewardV2(args))
        }
        38u8 => {
            let args = SetRewardEmissionsV2IxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::SetRewardEmissionsV2(args))
        }
        39u8 => {
            let args = SwapV2IxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::SwapV2(args))
        }
        40u8 => {
            let args = TwoHopSwapV2IxArgs::deserialize(&mut ix_data)?;
            Ok(WhirlpoolInstruction::TwoHopSwapV2(args))
        }
        41u8 => Ok(WhirlpoolInstruction::InitializeConfigExtension),
        42u8 => Ok(WhirlpoolInstruction::SetConfigExtensionAuthority),
        43u8 => Ok(WhirlpoolInstruction::SetTokenBadgeAuthority),
        44u8 => Ok(WhirlpoolInstruction::InitializeTokenBadge),
        45u8 => Ok(WhirlpoolInstruction::DeleteTokenBadge),
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {}", discriminator),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_initialize_config_consistency() {
        let expected_first_arg = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_args = InitializeConfigIxArgs {
            fee_authority: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_CONFIG_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::InitializeConfig(args)) => {
                assert_eq!(
                    args.fee_authority, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializeConfig)
                );
            }
        }
    }
    #[test]
    fn test_initialize_pool_consistency() {
        let test_args = InitializePoolIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_POOL_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::InitializePool(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializePool)
                );
            }
        }
    }
    #[test]
    fn test_initialize_tick_array_consistency() {
        let expected_first_arg = 1000i32;
        let test_args = InitializeTickArrayIxArgs {
            start_tick_index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_TICK_ARRAY_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::InitializeTickArray(args)) => {
                assert_eq!(
                    args.start_tick_index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializeTickArray)
                );
            }
        }
    }
    #[test]
    fn test_initialize_fee_tier_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = InitializeFeeTierIxArgs {
            tick_spacing: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_FEE_TIER_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::InitializeFeeTier(args)) => {
                assert_eq!(
                    args.tick_spacing, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializeFeeTier)
                );
            }
        }
    }
    #[test]
    fn test_initialize_reward_consistency() {
        let expected_first_arg = 100u8;
        let test_args = InitializeRewardIxArgs {
            reward_index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_REWARD_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::InitializeReward(args)) => {
                assert_eq!(
                    args.reward_index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializeReward)
                );
            }
        }
    }
    #[test]
    fn test_set_reward_emissions_consistency() {
        let expected_first_arg = 100u8;
        let test_args = SetRewardEmissionsIxArgs {
            reward_index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_REWARD_EMISSIONS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::SetRewardEmissions(args)) => {
                assert_eq!(
                    args.reward_index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SetRewardEmissions)
                );
            }
        }
    }
    #[test]
    fn test_open_position_consistency() {
        let test_args = OpenPositionIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&OPEN_POSITION_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::OpenPosition(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(OpenPosition)
                );
            }
        }
    }
    #[test]
    fn test_open_position_with_metadata_consistency() {
        let test_args = OpenPositionWithMetadataIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&OPEN_POSITION_WITH_METADATA_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::OpenPositionWithMetadata(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(OpenPositionWithMetadata)
                );
            }
        }
    }
    #[test]
    fn test_increase_liquidity_consistency() {
        let test_args = IncreaseLiquidityIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INCREASE_LIQUIDITY_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::IncreaseLiquidity(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(IncreaseLiquidity)
                );
            }
        }
    }
    #[test]
    fn test_decrease_liquidity_consistency() {
        let test_args = DecreaseLiquidityIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&DECREASE_LIQUIDITY_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::DecreaseLiquidity(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(DecreaseLiquidity)
                );
            }
        }
    }
    #[test]
    fn test_update_fees_and_rewards_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&UPDATE_FEES_AND_REWARDS_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            WhirlpoolInstruction::UpdateFeesAndRewards => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_collect_fees_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&COLLECT_FEES_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            WhirlpoolInstruction::CollectFees => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_collect_reward_consistency() {
        let expected_first_arg = 100u8;
        let test_args = CollectRewardIxArgs {
            reward_index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&COLLECT_REWARD_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::CollectReward(args)) => {
                assert_eq!(
                    args.reward_index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CollectReward)
                );
            }
        }
    }
    #[test]
    fn test_collect_protocol_fees_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&COLLECT_PROTOCOL_FEES_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            WhirlpoolInstruction::CollectProtocolFees => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_swap_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = SwapIxArgs {
            amount: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SWAP_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::Swap(args)) => {
                assert_eq!(
                    args.amount, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Swap)
                );
            }
        }
    }
    #[test]
    fn test_close_position_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CLOSE_POSITION_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            WhirlpoolInstruction::ClosePosition => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_set_default_fee_rate_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = SetDefaultFeeRateIxArgs {
            default_fee_rate: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_DEFAULT_FEE_RATE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::SetDefaultFeeRate(args)) => {
                assert_eq!(
                    args.default_fee_rate, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SetDefaultFeeRate)
                );
            }
        }
    }
    #[test]
    fn test_set_default_protocol_fee_rate_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = SetDefaultProtocolFeeRateIxArgs {
            default_protocol_fee_rate: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_DEFAULT_PROTOCOL_FEE_RATE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::SetDefaultProtocolFeeRate(args)) => {
                assert_eq!(
                    args.default_protocol_fee_rate, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SetDefaultProtocolFeeRate)
                );
            }
        }
    }
    #[test]
    fn test_set_fee_rate_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = SetFeeRateIxArgs {
            fee_rate: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_FEE_RATE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::SetFeeRate(args)) => {
                assert_eq!(
                    args.fee_rate, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SetFeeRate)
                );
            }
        }
    }
    #[test]
    fn test_set_protocol_fee_rate_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = SetProtocolFeeRateIxArgs {
            protocol_fee_rate: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_PROTOCOL_FEE_RATE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::SetProtocolFeeRate(args)) => {
                assert_eq!(
                    args.protocol_fee_rate, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SetProtocolFeeRate)
                );
            }
        }
    }
    #[test]
    fn test_set_fee_authority_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_FEE_AUTHORITY_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            WhirlpoolInstruction::SetFeeAuthority => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_set_collect_protocol_fees_authority_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_COLLECT_PROTOCOL_FEES_AUTHORITY_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            WhirlpoolInstruction::SetCollectProtocolFeesAuthority => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_set_reward_authority_consistency() {
        let expected_first_arg = 100u8;
        let test_args = SetRewardAuthorityIxArgs {
            reward_index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_REWARD_AUTHORITY_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::SetRewardAuthority(args)) => {
                assert_eq!(
                    args.reward_index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SetRewardAuthority)
                );
            }
        }
    }
    #[test]
    fn test_set_reward_authority_by_super_authority_consistency() {
        let expected_first_arg = 100u8;
        let test_args = SetRewardAuthorityBySuperAuthorityIxArgs {
            reward_index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::SetRewardAuthorityBySuperAuthority(args)) => {
                assert_eq!(
                    args.reward_index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SetRewardAuthorityBySuperAuthority)
                );
            }
        }
    }
    #[test]
    fn test_set_reward_emissions_super_authority_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_REWARD_EMISSIONS_SUPER_AUTHORITY_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            WhirlpoolInstruction::SetRewardEmissionsSuperAuthority => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_two_hop_swap_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = TwoHopSwapIxArgs {
            amount: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&TWO_HOP_SWAP_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::TwoHopSwap(args)) => {
                assert_eq!(
                    args.amount, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(TwoHopSwap)
                );
            }
        }
    }
    #[test]
    fn test_initialize_position_bundle_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_POSITION_BUNDLE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            WhirlpoolInstruction::InitializePositionBundle => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_initialize_position_bundle_with_metadata_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_POSITION_BUNDLE_WITH_METADATA_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            WhirlpoolInstruction::InitializePositionBundleWithMetadata => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_delete_position_bundle_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&DELETE_POSITION_BUNDLE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            WhirlpoolInstruction::DeletePositionBundle => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_open_bundled_position_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = OpenBundledPositionIxArgs {
            bundle_index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&OPEN_BUNDLED_POSITION_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::OpenBundledPosition(args)) => {
                assert_eq!(
                    args.bundle_index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(OpenBundledPosition)
                );
            }
        }
    }
    #[test]
    fn test_close_bundled_position_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = CloseBundledPositionIxArgs {
            bundle_index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CLOSE_BUNDLED_POSITION_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::CloseBundledPosition(args)) => {
                assert_eq!(
                    args.bundle_index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CloseBundledPosition)
                );
            }
        }
    }
    #[test]
    fn test_collect_fees_v_2_consistency() {
        let test_args = CollectFeesV2IxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&COLLECT_FEES_V2_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::CollectFeesV2(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CollectFeesV2)
                );
            }
        }
    }
    #[test]
    fn test_collect_protocol_fees_v_2_consistency() {
        let test_args = CollectProtocolFeesV2IxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&COLLECT_PROTOCOL_FEES_V2_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::CollectProtocolFeesV2(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CollectProtocolFeesV2)
                );
            }
        }
    }
    #[test]
    fn test_collect_reward_v_2_consistency() {
        let expected_first_arg = 100u8;
        let test_args = CollectRewardV2IxArgs {
            reward_index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&COLLECT_REWARD_V2_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::CollectRewardV2(args)) => {
                assert_eq!(
                    args.reward_index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CollectRewardV2)
                );
            }
        }
    }
    #[test]
    fn test_decrease_liquidity_v_2_consistency() {
        let test_args = DecreaseLiquidityV2IxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&DECREASE_LIQUIDITY_V2_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::DecreaseLiquidityV2(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(DecreaseLiquidityV2)
                );
            }
        }
    }
    #[test]
    fn test_increase_liquidity_v_2_consistency() {
        let test_args = IncreaseLiquidityV2IxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INCREASE_LIQUIDITY_V2_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::IncreaseLiquidityV2(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(IncreaseLiquidityV2)
                );
            }
        }
    }
    #[test]
    fn test_initialize_pool_v_2_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = InitializePoolV2IxArgs {
            tick_spacing: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_POOL_V2_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::InitializePoolV2(args)) => {
                assert_eq!(
                    args.tick_spacing, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializePoolV2)
                );
            }
        }
    }
    #[test]
    fn test_initialize_reward_v_2_consistency() {
        let expected_first_arg = 100u8;
        let test_args = InitializeRewardV2IxArgs {
            reward_index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_REWARD_V2_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::InitializeRewardV2(args)) => {
                assert_eq!(
                    args.reward_index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializeRewardV2)
                );
            }
        }
    }
    #[test]
    fn test_set_reward_emissions_v_2_consistency() {
        let expected_first_arg = 100u8;
        let test_args = SetRewardEmissionsV2IxArgs {
            reward_index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_REWARD_EMISSIONS_V2_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::SetRewardEmissionsV2(args)) => {
                assert_eq!(
                    args.reward_index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SetRewardEmissionsV2)
                );
            }
        }
    }
    #[test]
    fn test_swap_v_2_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = SwapV2IxArgs {
            amount: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SWAP_V2_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::SwapV2(args)) => {
                assert_eq!(
                    args.amount, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SwapV2)
                );
            }
        }
    }
    #[test]
    fn test_two_hop_swap_v_2_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = TwoHopSwapV2IxArgs {
            amount: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&TWO_HOP_SWAP_V2_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(WhirlpoolInstruction::TwoHopSwapV2(args)) => {
                assert_eq!(
                    args.amount, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(TwoHopSwapV2)
                );
            }
        }
    }
    #[test]
    fn test_initialize_config_extension_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_CONFIG_EXTENSION_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            WhirlpoolInstruction::InitializeConfigExtension => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_set_config_extension_authority_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_CONFIG_EXTENSION_AUTHORITY_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            WhirlpoolInstruction::SetConfigExtensionAuthority => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_set_token_badge_authority_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_TOKEN_BADGE_AUTHORITY_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            WhirlpoolInstruction::SetTokenBadgeAuthority => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_initialize_token_badge_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_TOKEN_BADGE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            WhirlpoolInstruction::InitializeTokenBadge => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_delete_token_badge_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&DELETE_TOKEN_BADGE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            WhirlpoolInstruction::DeleteTokenBadge => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_args = InitializeConfigIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializeConfigIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_CONFIG_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::InitializeConfig(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_CONFIG_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializeConfig)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializeConfig),
                    e
                );
            }
        }
        let test_args = InitializePoolIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializePoolIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_POOL_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::InitializePool(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_POOL_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializePool)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializePool),
                    e
                );
            }
        }
        let test_args = InitializeTickArrayIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializeTickArrayIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_TICK_ARRAY_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::InitializeTickArray(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_TICK_ARRAY_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializeTickArray)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializeTickArray),
                    e
                );
            }
        }
        let test_args = InitializeFeeTierIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializeFeeTierIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_FEE_TIER_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::InitializeFeeTier(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_FEE_TIER_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializeFeeTier)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializeFeeTier),
                    e
                );
            }
        }
        let test_args = InitializeRewardIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializeRewardIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_REWARD_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::InitializeReward(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_REWARD_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializeReward)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializeReward),
                    e
                );
            }
        }
        let test_args = SetRewardEmissionsIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SetRewardEmissionsIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SET_REWARD_EMISSIONS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::SetRewardEmissions(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SET_REWARD_EMISSIONS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SetRewardEmissions)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetRewardEmissions),
                    e
                );
            }
        }
        let test_args = OpenPositionIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(OpenPositionIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &OPEN_POSITION_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::OpenPosition(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, OPEN_POSITION_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(OpenPosition))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(OpenPosition),
                    e
                );
            }
        }
        let test_args = OpenPositionWithMetadataIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(OpenPositionWithMetadataIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &OPEN_POSITION_WITH_METADATA_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::OpenPositionWithMetadata(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, OPEN_POSITION_WITH_METADATA_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(OpenPositionWithMetadata)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(OpenPositionWithMetadata),
                    e
                );
            }
        }
        let test_args = IncreaseLiquidityIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(IncreaseLiquidityIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INCREASE_LIQUIDITY_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::IncreaseLiquidity(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INCREASE_LIQUIDITY_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(IncreaseLiquidity)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(IncreaseLiquidity),
                    e
                );
            }
        }
        let test_args = DecreaseLiquidityIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(DecreaseLiquidityIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &DECREASE_LIQUIDITY_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::DecreaseLiquidity(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, DECREASE_LIQUIDITY_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(DecreaseLiquidity)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(DecreaseLiquidity),
                    e
                );
            }
        }
        let test_data = UPDATE_FEES_AND_REWARDS_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::UpdateFeesAndRewards => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(UpdateFeesAndRewards)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(UpdateFeesAndRewards),
                    e
                );
            }
        }
        let test_data = COLLECT_FEES_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::CollectFees => {}
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(CollectFees))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CollectFees),
                    e
                );
            }
        }
        let test_args = CollectRewardIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CollectRewardIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &COLLECT_REWARD_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::CollectReward(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, COLLECT_REWARD_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(CollectReward))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CollectReward),
                    e
                );
            }
        }
        let test_data = COLLECT_PROTOCOL_FEES_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::CollectProtocolFees => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CollectProtocolFees)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CollectProtocolFees),
                    e
                );
            }
        }
        let test_args = SwapIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SwapIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SWAP_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::Swap(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SWAP_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(Swap)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Swap),
                    e
                );
            }
        }
        let test_data = CLOSE_POSITION_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::ClosePosition => {}
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(ClosePosition))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ClosePosition),
                    e
                );
            }
        }
        let test_args = SetDefaultFeeRateIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SetDefaultFeeRateIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SET_DEFAULT_FEE_RATE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::SetDefaultFeeRate(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SET_DEFAULT_FEE_RATE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SetDefaultFeeRate)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetDefaultFeeRate),
                    e
                );
            }
        }
        let test_args = SetDefaultProtocolFeeRateIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SetDefaultProtocolFeeRateIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SET_DEFAULT_PROTOCOL_FEE_RATE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::SetDefaultProtocolFeeRate(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SET_DEFAULT_PROTOCOL_FEE_RATE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SetDefaultProtocolFeeRate)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetDefaultProtocolFeeRate),
                    e
                );
            }
        }
        let test_args = SetFeeRateIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SetFeeRateIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SET_FEE_RATE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::SetFeeRate(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SET_FEE_RATE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(SetFeeRate))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetFeeRate),
                    e
                );
            }
        }
        let test_args = SetProtocolFeeRateIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SetProtocolFeeRateIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SET_PROTOCOL_FEE_RATE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::SetProtocolFeeRate(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SET_PROTOCOL_FEE_RATE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SetProtocolFeeRate)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetProtocolFeeRate),
                    e
                );
            }
        }
        let test_data = SET_FEE_AUTHORITY_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::SetFeeAuthority => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SetFeeAuthority)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetFeeAuthority),
                    e
                );
            }
        }
        let test_data = SET_COLLECT_PROTOCOL_FEES_AUTHORITY_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::SetCollectProtocolFeesAuthority => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SetCollectProtocolFeesAuthority)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetCollectProtocolFeesAuthority),
                    e
                );
            }
        }
        let test_args = SetRewardAuthorityIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SetRewardAuthorityIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SET_REWARD_AUTHORITY_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::SetRewardAuthority(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SET_REWARD_AUTHORITY_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SetRewardAuthority)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetRewardAuthority),
                    e
                );
            }
        }
        let test_args = SetRewardAuthorityBySuperAuthorityIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SetRewardAuthorityBySuperAuthorityIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::SetRewardAuthorityBySuperAuthority(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SetRewardAuthorityBySuperAuthority)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetRewardAuthorityBySuperAuthority),
                    e
                );
            }
        }
        let test_data = SET_REWARD_EMISSIONS_SUPER_AUTHORITY_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::SetRewardEmissionsSuperAuthority => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SetRewardEmissionsSuperAuthority)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetRewardEmissionsSuperAuthority),
                    e
                );
            }
        }
        let test_args = TwoHopSwapIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(TwoHopSwapIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &TWO_HOP_SWAP_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::TwoHopSwap(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, TWO_HOP_SWAP_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(TwoHopSwap))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(TwoHopSwap),
                    e
                );
            }
        }
        let test_data = INITIALIZE_POSITION_BUNDLE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::InitializePositionBundle => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializePositionBundle)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializePositionBundle),
                    e
                );
            }
        }
        let test_data = INITIALIZE_POSITION_BUNDLE_WITH_METADATA_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::InitializePositionBundleWithMetadata => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializePositionBundleWithMetadata)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializePositionBundleWithMetadata),
                    e
                );
            }
        }
        let test_data = DELETE_POSITION_BUNDLE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::DeletePositionBundle => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(DeletePositionBundle)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(DeletePositionBundle),
                    e
                );
            }
        }
        let test_args = OpenBundledPositionIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(OpenBundledPositionIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &OPEN_BUNDLED_POSITION_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::OpenBundledPosition(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, OPEN_BUNDLED_POSITION_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(OpenBundledPosition)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(OpenBundledPosition),
                    e
                );
            }
        }
        let test_args = CloseBundledPositionIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CloseBundledPositionIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CLOSE_BUNDLED_POSITION_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::CloseBundledPosition(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CLOSE_BUNDLED_POSITION_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CloseBundledPosition)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CloseBundledPosition),
                    e
                );
            }
        }
        let test_args = CollectFeesV2IxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CollectFeesV2IxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &COLLECT_FEES_V2_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::CollectFeesV2(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, COLLECT_FEES_V2_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(CollectFeesV2))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CollectFeesV2),
                    e
                );
            }
        }
        let test_args = CollectProtocolFeesV2IxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CollectProtocolFeesV2IxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &COLLECT_PROTOCOL_FEES_V2_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::CollectProtocolFeesV2(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, COLLECT_PROTOCOL_FEES_V2_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CollectProtocolFeesV2)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CollectProtocolFeesV2),
                    e
                );
            }
        }
        let test_args = CollectRewardV2IxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CollectRewardV2IxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &COLLECT_REWARD_V2_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::CollectRewardV2(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, COLLECT_REWARD_V2_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CollectRewardV2)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CollectRewardV2),
                    e
                );
            }
        }
        let test_args = DecreaseLiquidityV2IxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(DecreaseLiquidityV2IxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &DECREASE_LIQUIDITY_V2_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::DecreaseLiquidityV2(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, DECREASE_LIQUIDITY_V2_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(DecreaseLiquidityV2)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(DecreaseLiquidityV2),
                    e
                );
            }
        }
        let test_args = IncreaseLiquidityV2IxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(IncreaseLiquidityV2IxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INCREASE_LIQUIDITY_V2_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::IncreaseLiquidityV2(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INCREASE_LIQUIDITY_V2_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(IncreaseLiquidityV2)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(IncreaseLiquidityV2),
                    e
                );
            }
        }
        let test_args = InitializePoolV2IxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializePoolV2IxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_POOL_V2_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::InitializePoolV2(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_POOL_V2_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializePoolV2)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializePoolV2),
                    e
                );
            }
        }
        let test_args = InitializeRewardV2IxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializeRewardV2IxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_REWARD_V2_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::InitializeRewardV2(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_REWARD_V2_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializeRewardV2)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializeRewardV2),
                    e
                );
            }
        }
        let test_args = SetRewardEmissionsV2IxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SetRewardEmissionsV2IxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SET_REWARD_EMISSIONS_V2_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::SetRewardEmissionsV2(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SET_REWARD_EMISSIONS_V2_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SetRewardEmissionsV2)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetRewardEmissionsV2),
                    e
                );
            }
        }
        let test_args = SwapV2IxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SwapV2IxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SWAP_V2_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::SwapV2(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SWAP_V2_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(SwapV2)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SwapV2),
                    e
                );
            }
        }
        let test_args = TwoHopSwapV2IxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(TwoHopSwapV2IxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &TWO_HOP_SWAP_V2_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::TwoHopSwapV2(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, TWO_HOP_SWAP_V2_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(TwoHopSwapV2))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(TwoHopSwapV2),
                    e
                );
            }
        }
        let test_data = INITIALIZE_CONFIG_EXTENSION_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::InitializeConfigExtension => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializeConfigExtension)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializeConfigExtension),
                    e
                );
            }
        }
        let test_data = SET_CONFIG_EXTENSION_AUTHORITY_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::SetConfigExtensionAuthority => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SetConfigExtensionAuthority)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetConfigExtensionAuthority),
                    e
                );
            }
        }
        let test_data = SET_TOKEN_BADGE_AUTHORITY_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::SetTokenBadgeAuthority => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SetTokenBadgeAuthority)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetTokenBadgeAuthority),
                    e
                );
            }
        }
        let test_data = INITIALIZE_TOKEN_BADGE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::InitializeTokenBadge => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializeTokenBadge)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializeTokenBadge),
                    e
                );
            }
        }
        let test_data = DELETE_TOKEN_BADGE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                WhirlpoolInstruction::DeleteTokenBadge => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(DeleteTokenBadge)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(DeleteTokenBadge),
                    e
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = parse_instruction(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = parse_instruction(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
