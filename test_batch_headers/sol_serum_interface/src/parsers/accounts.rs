//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::accounts::*;
/// Program account types
#[derive(Clone, Debug, PartialEq)]
pub enum SerumAccount {
    MarketStateV2(MarketStateV2),
    MarketState(MarketState),
    OpenOrders(OpenOrders),
    RequestQueueHeader(RequestQueueHeader),
    Request(Request),
    EventQueueHeader(EventQueueHeader),
    Event(Event),
}
/// Parse account data based on data length (non-Anchor contracts)
pub fn try_unpack_account(data: &[u8]) -> Result<SerumAccount, std::io::Error> {
    let data_len = data.len();
    const MARKET_STATE_V2_LEN: usize = std::mem::size_of::<MarketStateV2>();
    const MARKET_STATE_LEN: usize = std::mem::size_of::<MarketState>();
    const OPEN_ORDERS_LEN: usize = std::mem::size_of::<OpenOrders>();
    const REQUEST_QUEUE_HEADER_LEN: usize = std::mem::size_of::<RequestQueueHeader>();
    const REQUEST_LEN: usize = std::mem::size_of::<Request>();
    const EVENT_QUEUE_HEADER_LEN: usize = std::mem::size_of::<EventQueueHeader>();
    const EVENT_LEN: usize = std::mem::size_of::<Event>();
    match data_len {
        MARKET_STATE_V2_LEN => Ok(SerumAccount::MarketStateV2(MarketStateV2::from_bytes(
            data,
        )?)),
        MARKET_STATE_LEN => Ok(SerumAccount::MarketState(MarketState::from_bytes(data)?)),
        OPEN_ORDERS_LEN => Ok(SerumAccount::OpenOrders(OpenOrders::from_bytes(data)?)),
        REQUEST_QUEUE_HEADER_LEN => Ok(SerumAccount::RequestQueueHeader(
            RequestQueueHeader::from_bytes(data)?,
        )),
        REQUEST_LEN => Ok(SerumAccount::Request(Request::from_bytes(data)?)),
        EVENT_QUEUE_HEADER_LEN => Ok(SerumAccount::EventQueueHeader(
            EventQueueHeader::from_bytes(data)?,
        )),
        EVENT_LEN => Ok(SerumAccount::Event(Event::from_bytes(data)?)),
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Invalid Account data length: {}", data_len),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    use borsh::{BorshDeserialize, BorshSerialize};
    #[test]
    fn test_market_state_v_2_consistency() {
        let expected_first_field = Default::default();
        let test_account = MarketStateV2 {
            inner: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(SerumAccount::MarketStateV2(account)) => {
                assert_eq!(
                    account.discriminator,
                    [181u8, 11u8, 35u8, 91u8, 85u8, 209u8, 1u8, 51u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(MarketStateV2)
                );
            }
        }
    }
    #[test]
    fn test_market_state_consistency() {
        let expected_first_field = 42u64;
        let test_account = MarketState {
            account_flags: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(SerumAccount::MarketState(account)) => {
                assert_eq!(
                    account.account_flags, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [0u8, 125u8, 123u8, 215u8, 95u8, 96u8, 164u8, 194u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(MarketState)
                );
            }
        }
    }
    #[test]
    fn test_open_orders_consistency() {
        let expected_first_field = 42u64;
        let test_account = OpenOrders {
            account_flags: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(SerumAccount::OpenOrders(account)) => {
                assert_eq!(
                    account.account_flags, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [139u8, 166u8, 123u8, 206u8, 111u8, 2u8, 116u8, 33u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(OpenOrders)
                );
            }
        }
    }
    #[test]
    fn test_request_queue_header_consistency() {
        let expected_first_field = 42u64;
        let test_account = RequestQueueHeader {
            account_flags: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(SerumAccount::RequestQueueHeader(account)) => {
                assert_eq!(
                    account.account_flags, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [28u8, 165u8, 120u8, 78u8, 225u8, 191u8, 157u8, 182u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(RequestQueueHeader)
                );
            }
        }
    }
    #[test]
    fn test_request_consistency() {
        let expected_first_field = 42u8;
        let test_account = Request {
            request_flags: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(SerumAccount::Request(account)) => {
                assert_eq!(
                    account.request_flags, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [125u8, 172u8, 150u8, 161u8, 162u8, 115u8, 39u8, 71u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Request)
                );
            }
        }
    }
    #[test]
    fn test_event_queue_header_consistency() {
        let expected_first_field = 42u64;
        let test_account = EventQueueHeader {
            account_flags: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(SerumAccount::EventQueueHeader(account)) => {
                assert_eq!(
                    account.account_flags, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [63u8, 228u8, 117u8, 106u8, 79u8, 9u8, 172u8, 71u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(EventQueueHeader)
                );
            }
        }
    }
    #[test]
    fn test_event_consistency() {
        let expected_first_field = 42u8;
        let test_account = Event {
            event_flags: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(SerumAccount::Event(account)) => {
                assert_eq!(
                    account.event_flags, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [125u8, 192u8, 125u8, 158u8, 9u8, 115u8, 152u8, 233u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Event)
                );
            }
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_account = MarketStateV2::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            MarketStateV2::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(MarketStateV2)
                );
            }
        }
        let test_account = MarketState::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            MarketState::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(MarketState)
                );
            }
        }
        let test_account = OpenOrders::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            OpenOrders::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(OpenOrders)
                );
            }
        }
        let test_account = RequestQueueHeader::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            RequestQueueHeader::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(RequestQueueHeader)
                );
            }
        }
        let test_account = Request::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            Request::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(Request)
                );
            }
        }
        let test_account = EventQueueHeader::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            EventQueueHeader::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(EventQueueHeader)
                );
            }
        }
        let test_account = Event::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            Event::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(Event)
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = try_unpack_account(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = try_unpack_account(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
