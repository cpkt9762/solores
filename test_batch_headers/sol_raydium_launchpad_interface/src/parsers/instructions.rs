//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::instructions::*;
pub const BUY_EXACT_IN_IX_DISCM: [u8; 8] = [250u8, 234u8, 13u8, 123u8, 213u8, 156u8, 19u8, 236u8];
pub const BUY_EXACT_OUT_IX_DISCM: [u8; 8] = [24u8, 211u8, 116u8, 40u8, 105u8, 3u8, 153u8, 56u8];
pub const CLAIM_PLATFORM_FEE_IX_DISCM: [u8; 8] =
    [156u8, 39u8, 208u8, 135u8, 76u8, 237u8, 61u8, 72u8];
pub const CLAIM_VESTED_TOKEN_IX_DISCM: [u8; 8] =
    [49u8, 33u8, 104u8, 30u8, 189u8, 157u8, 79u8, 35u8];
pub const COLLECT_FEE_IX_DISCM: [u8; 8] = [60u8, 173u8, 247u8, 103u8, 4u8, 93u8, 130u8, 48u8];
pub const COLLECT_MIGRATE_FEE_IX_DISCM: [u8; 8] =
    [255u8, 186u8, 150u8, 223u8, 235u8, 118u8, 201u8, 186u8];
pub const CREATE_CONFIG_IX_DISCM: [u8; 8] = [201u8, 207u8, 243u8, 114u8, 75u8, 111u8, 47u8, 189u8];
pub const CREATE_PLATFORM_CONFIG_IX_DISCM: [u8; 8] =
    [176u8, 90u8, 196u8, 175u8, 253u8, 113u8, 220u8, 20u8];
pub const CREATE_VESTING_ACCOUNT_IX_DISCM: [u8; 8] =
    [129u8, 178u8, 2u8, 13u8, 217u8, 172u8, 230u8, 218u8];
pub const INITIALIZE_IX_DISCM: [u8; 8] = [175u8, 175u8, 109u8, 31u8, 13u8, 152u8, 155u8, 237u8];
pub const MIGRATE_TO_AMM_IX_DISCM: [u8; 8] =
    [207u8, 82u8, 192u8, 145u8, 254u8, 207u8, 145u8, 223u8];
pub const MIGRATE_TO_CPSWAP_IX_DISCM: [u8; 8] =
    [136u8, 92u8, 200u8, 103u8, 28u8, 218u8, 144u8, 140u8];
pub const SELL_EXACT_IN_IX_DISCM: [u8; 8] = [149u8, 39u8, 222u8, 155u8, 211u8, 124u8, 152u8, 26u8];
pub const SELL_EXACT_OUT_IX_DISCM: [u8; 8] = [95u8, 200u8, 71u8, 34u8, 8u8, 9u8, 11u8, 166u8];
pub const UPDATE_CONFIG_IX_DISCM: [u8; 8] = [29u8, 158u8, 252u8, 191u8, 10u8, 83u8, 219u8, 99u8];
pub const UPDATE_PLATFORM_CONFIG_IX_DISCM: [u8; 8] =
    [195u8, 60u8, 76u8, 129u8, 146u8, 45u8, 67u8, 143u8];
/// Program instruction types
#[derive(Clone, Debug, PartialEq)]
pub enum RaydiumLaunchpadInstruction {
    ///Use the given amount of quote tokens to purchase base tokens.
    ///# Arguments
    ///* `ctx` - The context of accounts
    ///* `amount_in` - Amount of quote token to purchase
    ///* `minimum_amount_out` - Minimum amount of base token to receive (slippage protection)
    ///* `share_fee_rate` - Fee rate for the share
    BuyExactIn(BuyExactInIxArgs),
    ///Use quote tokens to purchase the given amount of base tokens.
    ///# Arguments
    ///* `ctx` - The context of accounts
    ///* `amount_out` - Amount of base token to receive
    ///* `maximum_amount_in` - Maximum amount of quote token to purchase (slippage protection)
    ///* `share_fee_rate` - Fee rate for the share
    BuyExactOut(BuyExactOutIxArgs),
    ///Claim platform fee
    ///# Arguments
    ///* `ctx` - The context of accounts
    ClaimPlatformFee,
    ///Claim vested token
    ///# Arguments
    ClaimVestedToken,
    ///Collects accumulated fees from the pool
    ///# Arguments
    ///* `ctx` - The context of accounts
    CollectFee,
    ///Collects  migrate fees from the pool
    ///# Arguments
    ///* `ctx` - The context of accounts
    CollectMigrateFee,
    ///Creates a new configuration
    ///# Arguments
    ///* `ctx` - The accounts needed by instruction
    ///* `curve_type` - The type of bonding curve (0: ConstantProduct)
    ///* `index` - The index of config, there may be multiple config with the same curve type.
    ///* `trade_fee_rate` - Trade fee rate, must be less than RATE_DENOMINATOR_VALUE
    CreateConfig(CreateConfigIxArgs),
    ///Create platform config account
    ///# Arguments
    ///* `ctx` - The context of accounts
    ///# Fields
    ///* `fee_rate` - Fee rate of the platform
    ///* `name` - Name of the platform
    ///* `web` - Website of the platform
    ///* `img` - Image link of the platform
    CreatePlatformConfig(CreatePlatformConfigIxArgs),
    ///Create vesting account
    ///# Arguments
    ///* `ctx` - The context of accounts
    ///* `share` - The share amount of base token to be vested
    CreateVestingAccount(CreateVestingAccountIxArgs),
    ///Initializes a new trading pool
    ///# Arguments
    ///* `ctx` - The context of accounts containing pool and token information
    Initialize(InitializeIxArgs),
    ///# Arguments
    ///* `ctx` - The context of accounts
    MigrateToAmm(MigrateToAmmIxArgs),
    ///# Arguments
    ///* `ctx` - The context of accounts
    MigrateToCpswap,
    ///Use the given amount of base tokens to sell for quote tokens.
    ///# Arguments
    ///* `ctx` - The context of accounts
    ///* `amount_in` - Amount of base token to sell
    ///* `minimum_amount_out` - Minimum amount of quote token to receive (slippage protection)
    ///* `share_fee_rate` - Fee rate for the share
    SellExactIn(SellExactInIxArgs),
    ///Sell base tokens for the given amount of quote tokens.
    ///# Arguments
    ///* `ctx` - The context of accounts
    ///* `amount_out` - Amount of quote token to receive
    ///* `maximum_amount_in` - Maximum amount of base token to purchase (slippage protection)
    ///* `share_fee_rate` - Fee rate for the share
    SellExactOut(SellExactOutIxArgs),
    ///Updates configuration parameters
    ///# Arguments
    ///* `ctx` - The context of accounts
    ///* `param` - Parameter to update:
    ///- 0: Update trade_fee_rate
    ///- 1: Update fee owner
    ///* `value` - New value for the selected parameter
    UpdateConfig(UpdateConfigIxArgs),
    ///Update platform config
    ///# Arguments
    ///* `ctx` - The context of accounts
    ///* `param` - Parameter to update
    UpdatePlatformConfig(UpdatePlatformConfigIxArgs),
}
/// Parse instruction data based on 8-byte discriminator (Anchor contracts)
pub fn parse_instruction(data: &[u8]) -> Result<RaydiumLaunchpadInstruction, std::io::Error> {
    if data.len() < 8 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data too short for discriminator",
        ));
    }
    let discriminator: [u8; 8] = data[0..8].try_into().map_err(|_| {
        std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Failed to read discriminator",
        )
    })?;
    let mut ix_data = &data[8..];
    match discriminator {
        BUY_EXACT_IN_IX_DISCM => {
            let args = BuyExactInIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumLaunchpadInstruction::BuyExactIn(args))
        }
        BUY_EXACT_OUT_IX_DISCM => {
            let args = BuyExactOutIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumLaunchpadInstruction::BuyExactOut(args))
        }
        CLAIM_PLATFORM_FEE_IX_DISCM => Ok(RaydiumLaunchpadInstruction::ClaimPlatformFee),
        CLAIM_VESTED_TOKEN_IX_DISCM => Ok(RaydiumLaunchpadInstruction::ClaimVestedToken),
        COLLECT_FEE_IX_DISCM => Ok(RaydiumLaunchpadInstruction::CollectFee),
        COLLECT_MIGRATE_FEE_IX_DISCM => Ok(RaydiumLaunchpadInstruction::CollectMigrateFee),
        CREATE_CONFIG_IX_DISCM => {
            let args = CreateConfigIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumLaunchpadInstruction::CreateConfig(args))
        }
        CREATE_PLATFORM_CONFIG_IX_DISCM => {
            let args = CreatePlatformConfigIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumLaunchpadInstruction::CreatePlatformConfig(args))
        }
        CREATE_VESTING_ACCOUNT_IX_DISCM => {
            let args = CreateVestingAccountIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumLaunchpadInstruction::CreateVestingAccount(args))
        }
        INITIALIZE_IX_DISCM => {
            let args = InitializeIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumLaunchpadInstruction::Initialize(args))
        }
        MIGRATE_TO_AMM_IX_DISCM => {
            let args = MigrateToAmmIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumLaunchpadInstruction::MigrateToAmm(args))
        }
        MIGRATE_TO_CPSWAP_IX_DISCM => Ok(RaydiumLaunchpadInstruction::MigrateToCpswap),
        SELL_EXACT_IN_IX_DISCM => {
            let args = SellExactInIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumLaunchpadInstruction::SellExactIn(args))
        }
        SELL_EXACT_OUT_IX_DISCM => {
            let args = SellExactOutIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumLaunchpadInstruction::SellExactOut(args))
        }
        UPDATE_CONFIG_IX_DISCM => {
            let args = UpdateConfigIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumLaunchpadInstruction::UpdateConfig(args))
        }
        UPDATE_PLATFORM_CONFIG_IX_DISCM => {
            let args = UpdatePlatformConfigIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumLaunchpadInstruction::UpdatePlatformConfig(args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {:?}", discriminator),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_buy_exact_in_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = BuyExactInIxArgs {
            amount_in: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&BUY_EXACT_IN_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumLaunchpadInstruction::BuyExactIn(args)) => {
                assert_eq!(
                    args.amount_in, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(BuyExactIn)
                );
            }
        }
    }
    #[test]
    fn test_buy_exact_out_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = BuyExactOutIxArgs {
            amount_out: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&BUY_EXACT_OUT_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumLaunchpadInstruction::BuyExactOut(args)) => {
                assert_eq!(
                    args.amount_out, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(BuyExactOut)
                );
            }
        }
    }
    #[test]
    fn test_claim_platform_fee_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CLAIM_PLATFORM_FEE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            RaydiumLaunchpadInstruction::ClaimPlatformFee => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_claim_vested_token_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CLAIM_VESTED_TOKEN_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            RaydiumLaunchpadInstruction::ClaimVestedToken => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_collect_fee_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&COLLECT_FEE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            RaydiumLaunchpadInstruction::CollectFee => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_collect_migrate_fee_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&COLLECT_MIGRATE_FEE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            RaydiumLaunchpadInstruction::CollectMigrateFee => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_create_config_consistency() {
        let expected_first_arg = 100u8;
        let test_args = CreateConfigIxArgs {
            curve_type: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATE_CONFIG_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumLaunchpadInstruction::CreateConfig(args)) => {
                assert_eq!(
                    args.curve_type, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CreateConfig)
                );
            }
        }
    }
    #[test]
    fn test_create_platform_config_consistency() {
        let test_args = CreatePlatformConfigIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATE_PLATFORM_CONFIG_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumLaunchpadInstruction::CreatePlatformConfig(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CreatePlatformConfig)
                );
            }
        }
    }
    #[test]
    fn test_create_vesting_account_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = CreateVestingAccountIxArgs {
            share_amount: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATE_VESTING_ACCOUNT_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumLaunchpadInstruction::CreateVestingAccount(args)) => {
                assert_eq!(
                    args.share_amount, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CreateVestingAccount)
                );
            }
        }
    }
    #[test]
    fn test_initialize_consistency() {
        let test_args = InitializeIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumLaunchpadInstruction::Initialize(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Initialize)
                );
            }
        }
    }
    #[test]
    fn test_migrate_to_amm_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = MigrateToAmmIxArgs {
            base_lot_size: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MIGRATE_TO_AMM_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumLaunchpadInstruction::MigrateToAmm(args)) => {
                assert_eq!(
                    args.base_lot_size, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(MigrateToAmm)
                );
            }
        }
    }
    #[test]
    fn test_migrate_to_cpswap_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MIGRATE_TO_CPSWAP_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            RaydiumLaunchpadInstruction::MigrateToCpswap => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_sell_exact_in_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = SellExactInIxArgs {
            amount_in: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SELL_EXACT_IN_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumLaunchpadInstruction::SellExactIn(args)) => {
                assert_eq!(
                    args.amount_in, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SellExactIn)
                );
            }
        }
    }
    #[test]
    fn test_sell_exact_out_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = SellExactOutIxArgs {
            amount_out: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SELL_EXACT_OUT_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumLaunchpadInstruction::SellExactOut(args)) => {
                assert_eq!(
                    args.amount_out, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SellExactOut)
                );
            }
        }
    }
    #[test]
    fn test_update_config_consistency() {
        let expected_first_arg = 100u8;
        let test_args = UpdateConfigIxArgs {
            param: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&UPDATE_CONFIG_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumLaunchpadInstruction::UpdateConfig(args)) => {
                assert_eq!(
                    args.param, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(UpdateConfig)
                );
            }
        }
    }
    #[test]
    fn test_update_platform_config_consistency() {
        let test_args = UpdatePlatformConfigIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&UPDATE_PLATFORM_CONFIG_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumLaunchpadInstruction::UpdatePlatformConfig(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(UpdatePlatformConfig)
                );
            }
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_args = BuyExactInIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(BuyExactInIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &BUY_EXACT_IN_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumLaunchpadInstruction::BuyExactIn(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, BUY_EXACT_IN_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(BuyExactIn))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(BuyExactIn),
                    e
                );
            }
        }
        let test_args = BuyExactOutIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(BuyExactOutIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &BUY_EXACT_OUT_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumLaunchpadInstruction::BuyExactOut(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, BUY_EXACT_OUT_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(BuyExactOut))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(BuyExactOut),
                    e
                );
            }
        }
        let test_data = CLAIM_PLATFORM_FEE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumLaunchpadInstruction::ClaimPlatformFee => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ClaimPlatformFee)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ClaimPlatformFee),
                    e
                );
            }
        }
        let test_data = CLAIM_VESTED_TOKEN_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumLaunchpadInstruction::ClaimVestedToken => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ClaimVestedToken)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ClaimVestedToken),
                    e
                );
            }
        }
        let test_data = COLLECT_FEE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumLaunchpadInstruction::CollectFee => {}
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(CollectFee))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CollectFee),
                    e
                );
            }
        }
        let test_data = COLLECT_MIGRATE_FEE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumLaunchpadInstruction::CollectMigrateFee => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CollectMigrateFee)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CollectMigrateFee),
                    e
                );
            }
        }
        let test_args = CreateConfigIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CreateConfigIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CREATE_CONFIG_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumLaunchpadInstruction::CreateConfig(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CREATE_CONFIG_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(CreateConfig))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CreateConfig),
                    e
                );
            }
        }
        let test_args = CreatePlatformConfigIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CreatePlatformConfigIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CREATE_PLATFORM_CONFIG_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumLaunchpadInstruction::CreatePlatformConfig(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CREATE_PLATFORM_CONFIG_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CreatePlatformConfig)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CreatePlatformConfig),
                    e
                );
            }
        }
        let test_args = CreateVestingAccountIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CreateVestingAccountIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CREATE_VESTING_ACCOUNT_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumLaunchpadInstruction::CreateVestingAccount(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CREATE_VESTING_ACCOUNT_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CreateVestingAccount)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CreateVestingAccount),
                    e
                );
            }
        }
        let test_args = InitializeIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializeIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumLaunchpadInstruction::Initialize(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(Initialize))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Initialize),
                    e
                );
            }
        }
        let test_args = MigrateToAmmIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(MigrateToAmmIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &MIGRATE_TO_AMM_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumLaunchpadInstruction::MigrateToAmm(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, MIGRATE_TO_AMM_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(MigrateToAmm))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MigrateToAmm),
                    e
                );
            }
        }
        let test_data = MIGRATE_TO_CPSWAP_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumLaunchpadInstruction::MigrateToCpswap => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MigrateToCpswap)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MigrateToCpswap),
                    e
                );
            }
        }
        let test_args = SellExactInIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SellExactInIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SELL_EXACT_IN_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumLaunchpadInstruction::SellExactIn(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SELL_EXACT_IN_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(SellExactIn))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SellExactIn),
                    e
                );
            }
        }
        let test_args = SellExactOutIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SellExactOutIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SELL_EXACT_OUT_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumLaunchpadInstruction::SellExactOut(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SELL_EXACT_OUT_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(SellExactOut))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SellExactOut),
                    e
                );
            }
        }
        let test_args = UpdateConfigIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(UpdateConfigIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &UPDATE_CONFIG_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumLaunchpadInstruction::UpdateConfig(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, UPDATE_CONFIG_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(UpdateConfig))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(UpdateConfig),
                    e
                );
            }
        }
        let test_args = UpdatePlatformConfigIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(UpdatePlatformConfigIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &UPDATE_PLATFORM_CONFIG_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumLaunchpadInstruction::UpdatePlatformConfig(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, UPDATE_PLATFORM_CONFIG_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(UpdatePlatformConfig)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(UpdatePlatformConfig),
                    e
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = parse_instruction(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = parse_instruction(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
