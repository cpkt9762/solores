//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::accounts::*;
/// Program account types
#[derive(Clone, Debug, PartialEq)]
pub enum RaydiumLaunchpadAccount {
    GlobalConfig(GlobalConfig),
    PlatformConfig(PlatformConfig),
    PoolState(PoolState),
    VestingRecord(VestingRecord),
}
/// Parse account data based on discriminator (Anchor contracts)
pub fn try_unpack_account(data: &[u8]) -> Result<RaydiumLaunchpadAccount, std::io::Error> {
    if data.len() < 8 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Account data too short for discriminator",
        ));
    }
    let discriminator: [u8; 8] = data[0..8].try_into().map_err(|_| {
        std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Failed to read discriminator",
        )
    })?;
    match discriminator {
        [149u8, 8u8, 156u8, 202u8, 160u8, 252u8, 176u8, 217u8] => Ok(
            RaydiumLaunchpadAccount::GlobalConfig(GlobalConfig::from_bytes(data)?),
        ),
        [160u8, 78u8, 128u8, 0u8, 248u8, 83u8, 230u8, 160u8] => Ok(
            RaydiumLaunchpadAccount::PlatformConfig(PlatformConfig::from_bytes(data)?),
        ),
        [247u8, 237u8, 227u8, 245u8, 215u8, 195u8, 222u8, 70u8] => Ok(
            RaydiumLaunchpadAccount::PoolState(PoolState::from_bytes(data)?),
        ),
        [106u8, 243u8, 221u8, 205u8, 230u8, 126u8, 85u8, 83u8] => Ok(
            RaydiumLaunchpadAccount::VestingRecord(VestingRecord::from_bytes(data)?),
        ),
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown account discriminator: {:?}", discriminator),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    use borsh::{BorshDeserialize, BorshSerialize};
    #[test]
    fn test_global_config_consistency() {
        let expected_first_field = 42u64;
        let test_account = GlobalConfig {
            epoch: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(RaydiumLaunchpadAccount::GlobalConfig(account)) => {
                assert_eq!(
                    account.epoch, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [149u8, 8u8, 156u8, 202u8, 160u8, 252u8, 176u8, 217u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(GlobalConfig)
                );
            }
        }
    }
    #[test]
    fn test_platform_config_consistency() {
        let expected_first_field = 42u64;
        let test_account = PlatformConfig {
            epoch: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(RaydiumLaunchpadAccount::PlatformConfig(account)) => {
                assert_eq!(
                    account.epoch, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [160u8, 78u8, 128u8, 0u8, 248u8, 83u8, 230u8, 160u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(PlatformConfig)
                );
            }
        }
    }
    #[test]
    fn test_pool_state_consistency() {
        let expected_first_field = 42u64;
        let test_account = PoolState {
            epoch: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(RaydiumLaunchpadAccount::PoolState(account)) => {
                assert_eq!(
                    account.epoch, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [247u8, 237u8, 227u8, 245u8, 215u8, 195u8, 222u8, 70u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(PoolState)
                );
            }
        }
    }
    #[test]
    fn test_vesting_record_consistency() {
        let expected_first_field = 42u64;
        let test_account = VestingRecord {
            epoch: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(RaydiumLaunchpadAccount::VestingRecord(account)) => {
                assert_eq!(
                    account.epoch, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [106u8, 243u8, 221u8, 205u8, 230u8, 126u8, 85u8, 83u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(VestingRecord)
                );
            }
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_account = GlobalConfig::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert!(
            test_data.len() >= 8,
            "Test data should have at least 8 bytes for discriminator"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for account {}",
                    stringify!(GlobalConfig)
                );
            }
        }
        let test_account = PlatformConfig::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert!(
            test_data.len() >= 8,
            "Test data should have at least 8 bytes for discriminator"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for account {}",
                    stringify!(PlatformConfig)
                );
            }
        }
        let test_account = PoolState::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert!(
            test_data.len() >= 8,
            "Test data should have at least 8 bytes for discriminator"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for account {}",
                    stringify!(PoolState)
                );
            }
        }
        let test_account = VestingRecord::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert!(
            test_data.len() >= 8,
            "Test data should have at least 8 bytes for discriminator"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for account {}",
                    stringify!(VestingRecord)
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = try_unpack_account(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = try_unpack_account(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
