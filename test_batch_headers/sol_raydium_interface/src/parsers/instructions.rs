//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::instructions::*;
pub const INITIALIZE_IX_DISCM: u8 = 0u8;
pub const INITIALIZE2_IX_DISCM: u8 = 1u8;
pub const MONITOR_STEP_IX_DISCM: u8 = 2u8;
pub const DEPOSIT_IX_DISCM: u8 = 3u8;
pub const WITHDRAW_IX_DISCM: u8 = 4u8;
pub const MIGRATE_TO_OPEN_BOOK_IX_DISCM: u8 = 5u8;
pub const SET_PARAMS_IX_DISCM: u8 = 6u8;
pub const WITHDRAW_PNL_IX_DISCM: u8 = 7u8;
pub const WITHDRAW_SRM_IX_DISCM: u8 = 8u8;
pub const SWAP_BASE_IN_IX_DISCM: u8 = 9u8;
pub const PRE_INITIALIZE_IX_DISCM: u8 = 10u8;
pub const SWAP_BASE_OUT_IX_DISCM: u8 = 11u8;
pub const SIMULATE_INFO_IX_DISCM: u8 = 12u8;
pub const ADMIN_CANCEL_ORDERS_IX_DISCM: u8 = 13u8;
pub const CREATE_CONFIG_ACCOUNT_IX_DISCM: u8 = 14u8;
pub const UPDATE_CONFIG_ACCOUNT_IX_DISCM: u8 = 15u8;
/// Program instruction types
#[derive(Clone, Debug, PartialEq)]
pub enum RaydiumInstruction {
    Initialize(InitializeIxArgs),
    Initialize2(Initialize2IxArgs),
    MonitorStep(MonitorStepIxArgs),
    Deposit(DepositIxArgs),
    Withdraw(WithdrawIxArgs),
    MigrateToOpenBook,
    SetParams(SetParamsIxArgs),
    WithdrawPnl,
    WithdrawSrm(WithdrawSrmIxArgs),
    SwapBaseIn(SwapBaseInIxArgs),
    PreInitialize(PreInitializeIxArgs),
    SwapBaseOut(SwapBaseOutIxArgs),
    SimulateInfo(SimulateInfoIxArgs),
    AdminCancelOrders(AdminCancelOrdersIxArgs),
    CreateConfigAccount,
    UpdateConfigAccount(UpdateConfigAccountIxArgs),
}
/// Parse instruction data based on 1-byte discriminator (non-Anchor contracts)
pub fn parse_instruction(data: &[u8]) -> Result<RaydiumInstruction, std::io::Error> {
    if data.is_empty() {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data is empty",
        ));
    }
    let discriminator = data[0];
    let mut ix_data = &data[1..];
    match discriminator {
        0u8 => {
            let args = InitializeIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumInstruction::Initialize(args))
        }
        1u8 => {
            let args = Initialize2IxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumInstruction::Initialize2(args))
        }
        2u8 => {
            let args = MonitorStepIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumInstruction::MonitorStep(args))
        }
        3u8 => {
            let args = DepositIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumInstruction::Deposit(args))
        }
        4u8 => {
            let args = WithdrawIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumInstruction::Withdraw(args))
        }
        5u8 => Ok(RaydiumInstruction::MigrateToOpenBook),
        6u8 => {
            let args = SetParamsIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumInstruction::SetParams(args))
        }
        7u8 => Ok(RaydiumInstruction::WithdrawPnl),
        8u8 => {
            let args = WithdrawSrmIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumInstruction::WithdrawSrm(args))
        }
        9u8 => {
            let args = SwapBaseInIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumInstruction::SwapBaseIn(args))
        }
        10u8 => {
            let args = PreInitializeIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumInstruction::PreInitialize(args))
        }
        11u8 => {
            let args = SwapBaseOutIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumInstruction::SwapBaseOut(args))
        }
        12u8 => {
            let args = SimulateInfoIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumInstruction::SimulateInfo(args))
        }
        13u8 => {
            let args = AdminCancelOrdersIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumInstruction::AdminCancelOrders(args))
        }
        14u8 => Ok(RaydiumInstruction::CreateConfigAccount),
        15u8 => {
            let args = UpdateConfigAccountIxArgs::deserialize(&mut ix_data)?;
            Ok(RaydiumInstruction::UpdateConfigAccount(args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {}", discriminator),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_initialize_consistency() {
        let expected_first_arg = 100u8;
        let test_args = InitializeIxArgs {
            nonce: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumInstruction::Initialize(args)) => {
                assert_eq!(
                    args.nonce, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Initialize)
                );
            }
        }
    }
    #[test]
    fn test_initialize_2_consistency() {
        let expected_first_arg = 100u8;
        let test_args = Initialize2IxArgs {
            nonce: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE2_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumInstruction::Initialize2(args)) => {
                assert_eq!(
                    args.nonce, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Initialize2)
                );
            }
        }
    }
    #[test]
    fn test_monitor_step_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = MonitorStepIxArgs {
            plan_order_limit: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MONITOR_STEP_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumInstruction::MonitorStep(args)) => {
                assert_eq!(
                    args.plan_order_limit, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(MonitorStep)
                );
            }
        }
    }
    #[test]
    fn test_deposit_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = DepositIxArgs {
            max_coin_amount: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&DEPOSIT_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumInstruction::Deposit(args)) => {
                assert_eq!(
                    args.max_coin_amount, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Deposit)
                );
            }
        }
    }
    #[test]
    fn test_withdraw_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = WithdrawIxArgs {
            amount: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&WITHDRAW_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumInstruction::Withdraw(args)) => {
                assert_eq!(
                    args.amount, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Withdraw)
                );
            }
        }
    }
    #[test]
    fn test_migrate_to_open_book_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MIGRATE_TO_OPEN_BOOK_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            RaydiumInstruction::MigrateToOpenBook => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_set_params_consistency() {
        let expected_first_arg = 100u8;
        let test_args = SetParamsIxArgs {
            param: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_PARAMS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumInstruction::SetParams(args)) => {
                assert_eq!(
                    args.param, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SetParams)
                );
            }
        }
    }
    #[test]
    fn test_withdraw_pnl_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&WITHDRAW_PNL_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            RaydiumInstruction::WithdrawPnl => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_withdraw_srm_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = WithdrawSrmIxArgs {
            amount: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&WITHDRAW_SRM_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumInstruction::WithdrawSrm(args)) => {
                assert_eq!(
                    args.amount, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(WithdrawSrm)
                );
            }
        }
    }
    #[test]
    fn test_swap_base_in_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = SwapBaseInIxArgs {
            amount_in: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SWAP_BASE_IN_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumInstruction::SwapBaseIn(args)) => {
                assert_eq!(
                    args.amount_in, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SwapBaseIn)
                );
            }
        }
    }
    #[test]
    fn test_pre_initialize_consistency() {
        let expected_first_arg = 100u8;
        let test_args = PreInitializeIxArgs {
            nonce: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&PRE_INITIALIZE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumInstruction::PreInitialize(args)) => {
                assert_eq!(
                    args.nonce, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(PreInitialize)
                );
            }
        }
    }
    #[test]
    fn test_swap_base_out_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = SwapBaseOutIxArgs {
            max_amount_in: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SWAP_BASE_OUT_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumInstruction::SwapBaseOut(args)) => {
                assert_eq!(
                    args.max_amount_in, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SwapBaseOut)
                );
            }
        }
    }
    #[test]
    fn test_simulate_info_consistency() {
        let expected_first_arg = 100u8;
        let test_args = SimulateInfoIxArgs {
            param: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SIMULATE_INFO_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumInstruction::SimulateInfo(args)) => {
                assert_eq!(
                    args.param, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SimulateInfo)
                );
            }
        }
    }
    #[test]
    fn test_admin_cancel_orders_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = AdminCancelOrdersIxArgs {
            limit: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&ADMIN_CANCEL_ORDERS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumInstruction::AdminCancelOrders(args)) => {
                assert_eq!(
                    args.limit, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(AdminCancelOrders)
                );
            }
        }
    }
    #[test]
    fn test_create_config_account_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATE_CONFIG_ACCOUNT_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            RaydiumInstruction::CreateConfigAccount => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_update_config_account_consistency() {
        let expected_first_arg = 100u8;
        let test_args = UpdateConfigAccountIxArgs {
            param: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&UPDATE_CONFIG_ACCOUNT_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(RaydiumInstruction::UpdateConfigAccount(args)) => {
                assert_eq!(
                    args.param, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(UpdateConfigAccount)
                );
            }
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_args = InitializeIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializeIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumInstruction::Initialize(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(Initialize))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Initialize),
                    e
                );
            }
        }
        let test_args = Initialize2IxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(Initialize2IxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE2_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumInstruction::Initialize2(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE2_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(Initialize2))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Initialize2),
                    e
                );
            }
        }
        let test_args = MonitorStepIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(MonitorStepIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &MONITOR_STEP_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumInstruction::MonitorStep(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, MONITOR_STEP_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(MonitorStep))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MonitorStep),
                    e
                );
            }
        }
        let test_args = DepositIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(DepositIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &DEPOSIT_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumInstruction::Deposit(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, DEPOSIT_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(Deposit)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Deposit),
                    e
                );
            }
        }
        let test_args = WithdrawIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(WithdrawIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &WITHDRAW_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumInstruction::Withdraw(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, WITHDRAW_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(Withdraw)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Withdraw),
                    e
                );
            }
        }
        let test_data = MIGRATE_TO_OPEN_BOOK_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumInstruction::MigrateToOpenBook => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MigrateToOpenBook)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MigrateToOpenBook),
                    e
                );
            }
        }
        let test_args = SetParamsIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SetParamsIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SET_PARAMS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumInstruction::SetParams(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SET_PARAMS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(SetParams)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetParams),
                    e
                );
            }
        }
        let test_data = WITHDRAW_PNL_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumInstruction::WithdrawPnl => {}
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(WithdrawPnl))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(WithdrawPnl),
                    e
                );
            }
        }
        let test_args = WithdrawSrmIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(WithdrawSrmIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &WITHDRAW_SRM_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumInstruction::WithdrawSrm(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, WITHDRAW_SRM_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(WithdrawSrm))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(WithdrawSrm),
                    e
                );
            }
        }
        let test_args = SwapBaseInIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SwapBaseInIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SWAP_BASE_IN_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumInstruction::SwapBaseIn(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SWAP_BASE_IN_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(SwapBaseIn))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SwapBaseIn),
                    e
                );
            }
        }
        let test_args = PreInitializeIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(PreInitializeIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &PRE_INITIALIZE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumInstruction::PreInitialize(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, PRE_INITIALIZE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(PreInitialize))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(PreInitialize),
                    e
                );
            }
        }
        let test_args = SwapBaseOutIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SwapBaseOutIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SWAP_BASE_OUT_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumInstruction::SwapBaseOut(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SWAP_BASE_OUT_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(SwapBaseOut))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SwapBaseOut),
                    e
                );
            }
        }
        let test_args = SimulateInfoIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SimulateInfoIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SIMULATE_INFO_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumInstruction::SimulateInfo(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SIMULATE_INFO_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(SimulateInfo))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SimulateInfo),
                    e
                );
            }
        }
        let test_args = AdminCancelOrdersIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(AdminCancelOrdersIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &ADMIN_CANCEL_ORDERS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumInstruction::AdminCancelOrders(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, ADMIN_CANCEL_ORDERS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(AdminCancelOrders)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(AdminCancelOrders),
                    e
                );
            }
        }
        let test_data = CREATE_CONFIG_ACCOUNT_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumInstruction::CreateConfigAccount => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CreateConfigAccount)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CreateConfigAccount),
                    e
                );
            }
        }
        let test_args = UpdateConfigAccountIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(UpdateConfigAccountIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &UPDATE_CONFIG_ACCOUNT_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                RaydiumInstruction::UpdateConfigAccount(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, UPDATE_CONFIG_ACCOUNT_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(UpdateConfigAccount)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(UpdateConfigAccount),
                    e
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = parse_instruction(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = parse_instruction(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
