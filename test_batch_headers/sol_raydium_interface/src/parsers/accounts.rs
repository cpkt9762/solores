//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::accounts::*;
/// Program account types
#[derive(Clone, Debug, PartialEq)]
pub enum RaydiumAccount {
    TargetOrders(TargetOrders),
    AmmConfig(AmmConfig),
    AmmInfo(AmmInfo),
}
/// Parse account data based on data length (non-Anchor contracts)
pub fn try_unpack_account(data: &[u8]) -> Result<RaydiumAccount, std::io::Error> {
    let data_len = data.len();
    const TARGET_ORDERS_LEN: usize = std::mem::size_of::<TargetOrders>();
    const AMM_CONFIG_LEN: usize = std::mem::size_of::<AmmConfig>();
    const AMM_INFO_LEN: usize = std::mem::size_of::<AmmInfo>();
    match data_len {
        TARGET_ORDERS_LEN => Ok(RaydiumAccount::TargetOrders(TargetOrders::from_bytes(
            data,
        )?)),
        AMM_CONFIG_LEN => Ok(RaydiumAccount::AmmConfig(AmmConfig::from_bytes(data)?)),
        AMM_INFO_LEN => Ok(RaydiumAccount::AmmInfo(AmmInfo::from_bytes(data)?)),
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Invalid Account data length: {}", data_len),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    use borsh::{BorshDeserialize, BorshSerialize};
    #[test]
    fn test_target_orders_consistency() {
        let expected_first_field = [42u64; 4];
        let test_account = TargetOrders {
            owner: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(RaydiumAccount::TargetOrders(account)) => {
                assert_eq!(
                    account.owner, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [113u8, 225u8, 140u8, 255u8, 65u8, 144u8, 239u8, 231u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(TargetOrders)
                );
            }
        }
    }
    #[test]
    fn test_amm_config_consistency() {
        let expected_first_field = solana_program::pubkey::Pubkey::new_from_array([1u8; 32]);
        let test_account = AmmConfig {
            pnl_owner: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(RaydiumAccount::AmmConfig(account)) => {
                assert_eq!(
                    account.pnl_owner, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [218u8, 244u8, 33u8, 104u8, 203u8, 203u8, 43u8, 111u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(AmmConfig)
                );
            }
        }
    }
    #[test]
    fn test_amm_info_consistency() {
        let expected_first_field = 42u64;
        let test_account = AmmInfo {
            status: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(RaydiumAccount::AmmInfo(account)) => {
                assert_eq!(
                    account.status, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [33u8, 217u8, 2u8, 203u8, 184u8, 83u8, 235u8, 91u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(AmmInfo)
                );
            }
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_account = TargetOrders::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            TargetOrders::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(TargetOrders)
                );
            }
        }
        let test_account = AmmConfig::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            AmmConfig::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(AmmConfig)
                );
            }
        }
        let test_account = AmmInfo::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert_eq!(
            test_data.len(),
            AmmInfo::LEN,
            "Test data should match account struct size"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Invalid Account data length"),
                    "Should recognize account length for {}",
                    stringify!(AmmInfo)
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = try_unpack_account(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = try_unpack_account(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
