//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::accounts::*;
/// Program account types
#[derive(Clone, Debug, PartialEq)]
pub enum MeteoraDbcAccount {
    ClaimFeeOperator(ClaimFeeOperator),
    Config(Config),
    LockEscrow(LockEscrow),
    MeteoraDammMigrationMetadata(MeteoraDammMigrationMetadata),
    MeteoraDammV2Metadata(MeteoraDammV2Metadata),
    PartnerMetadata(PartnerMetadata),
    PoolConfig(PoolConfig),
    VirtualPool(VirtualPool),
    VirtualPoolMetadata(VirtualPoolMetadata),
}
/// Parse account data based on discriminator (Anchor contracts)
pub fn try_unpack_account(data: &[u8]) -> Result<MeteoraDbcAccount, std::io::Error> {
    if data.len() < 8 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Account data too short for discriminator",
        ));
    }
    let discriminator: [u8; 8] = data[0..8].try_into().map_err(|_| {
        std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Failed to read discriminator",
        )
    })?;
    match discriminator {
        [166u8, 48u8, 134u8, 86u8, 34u8, 200u8, 188u8, 150u8] => Ok(
            MeteoraDbcAccount::ClaimFeeOperator(ClaimFeeOperator::from_bytes(data)?),
        ),
        [155u8, 12u8, 170u8, 224u8, 30u8, 250u8, 204u8, 130u8] => {
            Ok(MeteoraDbcAccount::Config(Config::from_bytes(data)?))
        }
        [190u8, 106u8, 121u8, 6u8, 200u8, 182u8, 21u8, 75u8] => {
            Ok(MeteoraDbcAccount::LockEscrow(LockEscrow::from_bytes(data)?))
        }
        [17u8, 155u8, 141u8, 215u8, 207u8, 4u8, 133u8, 156u8] => {
            Ok(MeteoraDbcAccount::MeteoraDammMigrationMetadata(
                MeteoraDammMigrationMetadata::from_bytes(data)?,
            ))
        }
        [104u8, 221u8, 219u8, 203u8, 10u8, 142u8, 250u8, 163u8] => Ok(
            MeteoraDbcAccount::MeteoraDammV2Metadata(MeteoraDammV2Metadata::from_bytes(data)?),
        ),
        [68u8, 68u8, 130u8, 19u8, 16u8, 209u8, 98u8, 156u8] => Ok(
            MeteoraDbcAccount::PartnerMetadata(PartnerMetadata::from_bytes(data)?),
        ),
        [26u8, 108u8, 14u8, 123u8, 116u8, 230u8, 129u8, 43u8] => {
            Ok(MeteoraDbcAccount::PoolConfig(PoolConfig::from_bytes(data)?))
        }
        [213u8, 224u8, 5u8, 209u8, 98u8, 69u8, 119u8, 92u8] => Ok(MeteoraDbcAccount::VirtualPool(
            VirtualPool::from_bytes(data)?,
        )),
        [217u8, 37u8, 82u8, 250u8, 43u8, 47u8, 228u8, 254u8] => Ok(
            MeteoraDbcAccount::VirtualPoolMetadata(VirtualPoolMetadata::from_bytes(data)?),
        ),
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown account discriminator: {:?}", discriminator),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    use borsh::{BorshDeserialize, BorshSerialize};
    #[test]
    fn test_claim_fee_operator_consistency() {
        let expected_first_field = Default::default();
        let test_account = ClaimFeeOperator {
            operator: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(MeteoraDbcAccount::ClaimFeeOperator(account)) => {
                assert_eq!(
                    account.operator, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [166u8, 48u8, 134u8, 86u8, 34u8, 200u8, 188u8, 150u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ClaimFeeOperator)
                );
            }
        }
    }
    #[test]
    fn test_config_consistency() {
        let expected_first_field = Default::default();
        let test_account = Config {
            pool_fees: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(MeteoraDbcAccount::Config(account)) => {
                assert_eq!(
                    account.discriminator,
                    [155u8, 12u8, 170u8, 224u8, 30u8, 250u8, 204u8, 130u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Config)
                );
            }
        }
    }
    #[test]
    fn test_lock_escrow_consistency() {
        let expected_first_field = Default::default();
        let test_account = LockEscrow {
            pool: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(MeteoraDbcAccount::LockEscrow(account)) => {
                assert_eq!(
                    account.pool, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [190u8, 106u8, 121u8, 6u8, 200u8, 182u8, 21u8, 75u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(LockEscrow)
                );
            }
        }
    }
    #[test]
    fn test_meteora_damm_migration_metadata_consistency() {
        let expected_first_field = Default::default();
        let test_account = MeteoraDammMigrationMetadata {
            virtual_pool: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(MeteoraDbcAccount::MeteoraDammMigrationMetadata(account)) => {
                assert_eq!(
                    account.virtual_pool, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [17u8, 155u8, 141u8, 215u8, 207u8, 4u8, 133u8, 156u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(MeteoraDammMigrationMetadata)
                );
            }
        }
    }
    #[test]
    fn test_meteora_damm_v_2_metadata_consistency() {
        let expected_first_field = Default::default();
        let test_account = MeteoraDammV2Metadata {
            virtual_pool: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(MeteoraDbcAccount::MeteoraDammV2Metadata(account)) => {
                assert_eq!(
                    account.virtual_pool, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [104u8, 221u8, 219u8, 203u8, 10u8, 142u8, 250u8, 163u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(MeteoraDammV2Metadata)
                );
            }
        }
    }
    #[test]
    fn test_partner_metadata_consistency() {
        let expected_first_field = Default::default();
        let test_account = PartnerMetadata {
            fee_claimer: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(MeteoraDbcAccount::PartnerMetadata(account)) => {
                assert_eq!(
                    account.fee_claimer, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [68u8, 68u8, 130u8, 19u8, 16u8, 209u8, 98u8, 156u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(PartnerMetadata)
                );
            }
        }
    }
    #[test]
    fn test_pool_config_consistency() {
        let expected_first_field = Default::default();
        let test_account = PoolConfig {
            quote_mint: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(MeteoraDbcAccount::PoolConfig(account)) => {
                assert_eq!(
                    account.quote_mint, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [26u8, 108u8, 14u8, 123u8, 116u8, 230u8, 129u8, 43u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(PoolConfig)
                );
            }
        }
    }
    #[test]
    fn test_virtual_pool_consistency() {
        let expected_first_field = Default::default();
        let test_account = VirtualPool {
            volatility_tracker: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(MeteoraDbcAccount::VirtualPool(account)) => {
                assert_eq!(
                    account.discriminator,
                    [213u8, 224u8, 5u8, 209u8, 98u8, 69u8, 119u8, 92u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(VirtualPool)
                );
            }
        }
    }
    #[test]
    fn test_virtual_pool_metadata_consistency() {
        let expected_first_field = Default::default();
        let test_account = VirtualPoolMetadata {
            virtual_pool: expected_first_field,
            ..Default::default()
        };
        let test_data = test_account.try_to_vec().unwrap();
        match try_unpack_account(&test_data) {
            Ok(MeteoraDbcAccount::VirtualPoolMetadata(account)) => {
                assert_eq!(
                    account.virtual_pool, expected_first_field,
                    "First field value should match expected value"
                );
                assert_eq!(
                    account.discriminator,
                    [217u8, 37u8, 82u8, 250u8, 43u8, 47u8, 228u8, 254u8],
                    "Discriminator field should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong account type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(VirtualPoolMetadata)
                );
            }
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_account = ClaimFeeOperator::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert!(
            test_data.len() >= 8,
            "Test data should have at least 8 bytes for discriminator"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for account {}",
                    stringify!(ClaimFeeOperator)
                );
            }
        }
        let test_account = Config::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert!(
            test_data.len() >= 8,
            "Test data should have at least 8 bytes for discriminator"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for account {}",
                    stringify!(Config)
                );
            }
        }
        let test_account = LockEscrow::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert!(
            test_data.len() >= 8,
            "Test data should have at least 8 bytes for discriminator"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for account {}",
                    stringify!(LockEscrow)
                );
            }
        }
        let test_account = MeteoraDammMigrationMetadata::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert!(
            test_data.len() >= 8,
            "Test data should have at least 8 bytes for discriminator"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for account {}",
                    stringify!(MeteoraDammMigrationMetadata)
                );
            }
        }
        let test_account = MeteoraDammV2Metadata::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert!(
            test_data.len() >= 8,
            "Test data should have at least 8 bytes for discriminator"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for account {}",
                    stringify!(MeteoraDammV2Metadata)
                );
            }
        }
        let test_account = PartnerMetadata::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert!(
            test_data.len() >= 8,
            "Test data should have at least 8 bytes for discriminator"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for account {}",
                    stringify!(PartnerMetadata)
                );
            }
        }
        let test_account = PoolConfig::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert!(
            test_data.len() >= 8,
            "Test data should have at least 8 bytes for discriminator"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for account {}",
                    stringify!(PoolConfig)
                );
            }
        }
        let test_account = VirtualPool::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert!(
            test_data.len() >= 8,
            "Test data should have at least 8 bytes for discriminator"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for account {}",
                    stringify!(VirtualPool)
                );
            }
        }
        let test_account = VirtualPoolMetadata::default();
        let test_data = test_account.try_to_vec().unwrap();
        assert!(
            test_data.len() >= 8,
            "Test data should have at least 8 bytes for discriminator"
        );
        let result = try_unpack_account(&test_data);
        match result {
            Ok(_) => {}
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown account discriminator"),
                    "Should recognize discriminator for account {}",
                    stringify!(VirtualPoolMetadata)
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = try_unpack_account(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = try_unpack_account(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
