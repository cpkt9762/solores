//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::instructions::*;
pub const CLAIM_CREATOR_TRADING_FEE_IX_DISCM: [u8; 8] =
    [82u8, 220u8, 250u8, 189u8, 3u8, 85u8, 107u8, 45u8];
pub const CLAIM_PROTOCOL_FEE_IX_DISCM: [u8; 8] =
    [165u8, 228u8, 133u8, 48u8, 99u8, 249u8, 255u8, 33u8];
pub const CLAIM_TRADING_FEE_IX_DISCM: [u8; 8] = [8u8, 236u8, 89u8, 49u8, 152u8, 125u8, 177u8, 81u8];
pub const CLOSE_CLAIM_FEE_OPERATOR_IX_DISCM: [u8; 8] =
    [38u8, 134u8, 82u8, 216u8, 95u8, 124u8, 17u8, 99u8];
pub const CREATE_CLAIM_FEE_OPERATOR_IX_DISCM: [u8; 8] =
    [169u8, 62u8, 207u8, 107u8, 58u8, 187u8, 162u8, 109u8];
pub const CREATE_CONFIG_IX_DISCM: [u8; 8] = [201u8, 207u8, 243u8, 114u8, 75u8, 111u8, 47u8, 189u8];
pub const CREATE_LOCKER_IX_DISCM: [u8; 8] = [167u8, 90u8, 137u8, 154u8, 75u8, 47u8, 17u8, 84u8];
pub const CREATE_PARTNER_METADATA_IX_DISCM: [u8; 8] =
    [192u8, 168u8, 234u8, 191u8, 188u8, 226u8, 227u8, 255u8];
pub const CREATE_VIRTUAL_POOL_METADATA_IX_DISCM: [u8; 8] =
    [45u8, 97u8, 187u8, 103u8, 254u8, 109u8, 124u8, 134u8];
pub const CREATOR_WITHDRAW_SURPLUS_IX_DISCM: [u8; 8] =
    [165u8, 3u8, 137u8, 7u8, 28u8, 134u8, 76u8, 80u8];
pub const INITIALIZE_VIRTUAL_POOL_WITH_SPL_TOKEN_IX_DISCM: [u8; 8] =
    [140u8, 85u8, 215u8, 176u8, 102u8, 54u8, 104u8, 79u8];
pub const INITIALIZE_VIRTUAL_POOL_WITH_TOKEN2022_IX_DISCM: [u8; 8] =
    [169u8, 118u8, 51u8, 78u8, 145u8, 110u8, 220u8, 155u8];
pub const MIGRATE_METEORA_DAMM_IX_DISCM: [u8; 8] =
    [27u8, 1u8, 48u8, 22u8, 180u8, 63u8, 118u8, 217u8];
pub const MIGRATE_METEORA_DAMM_CLAIM_LP_TOKEN_IX_DISCM: [u8; 8] =
    [139u8, 133u8, 2u8, 30u8, 91u8, 145u8, 127u8, 154u8];
pub const MIGRATE_METEORA_DAMM_LOCK_LP_TOKEN_IX_DISCM: [u8; 8] =
    [177u8, 55u8, 238u8, 157u8, 251u8, 88u8, 165u8, 42u8];
pub const MIGRATION_DAMM_V2_IX_DISCM: [u8; 8] =
    [156u8, 169u8, 230u8, 103u8, 53u8, 228u8, 80u8, 64u8];
pub const MIGRATION_DAMM_V2_CREATE_METADATA_IX_DISCM: [u8; 8] =
    [109u8, 189u8, 19u8, 36u8, 195u8, 183u8, 222u8, 82u8];
pub const MIGRATION_METEORA_DAMM_CREATE_METADATA_IX_DISCM: [u8; 8] =
    [47u8, 94u8, 126u8, 115u8, 221u8, 226u8, 194u8, 133u8];
pub const PARTNER_WITHDRAW_SURPLUS_IX_DISCM: [u8; 8] =
    [168u8, 173u8, 72u8, 100u8, 201u8, 98u8, 38u8, 92u8];
pub const PROTOCOL_WITHDRAW_SURPLUS_IX_DISCM: [u8; 8] =
    [54u8, 136u8, 225u8, 138u8, 172u8, 182u8, 214u8, 167u8];
pub const SWAP_IX_DISCM: [u8; 8] = [248u8, 198u8, 158u8, 145u8, 225u8, 117u8, 135u8, 200u8];
pub const TRANSFER_POOL_CREATOR_IX_DISCM: [u8; 8] =
    [20u8, 7u8, 169u8, 33u8, 58u8, 147u8, 166u8, 33u8];
pub const WITHDRAW_LEFTOVER_IX_DISCM: [u8; 8] =
    [20u8, 198u8, 202u8, 237u8, 235u8, 243u8, 183u8, 66u8];
pub const WITHDRAW_MIGRATION_FEE_IX_DISCM: [u8; 8] =
    [237u8, 142u8, 45u8, 23u8, 129u8, 6u8, 222u8, 162u8];
/// Program instruction types
#[derive(Clone, Debug, PartialEq)]
pub enum MeteoraDbcInstruction {
    ClaimCreatorTradingFee(ClaimCreatorTradingFeeIxArgs),
    ClaimProtocolFee,
    ClaimTradingFee(ClaimTradingFeeIxArgs),
    CloseClaimFeeOperator,
    ///ADMIN FUNCTIONS ///
    CreateClaimFeeOperator,
    CreateConfig(CreateConfigIxArgs),
    ///PERMISSIONLESS FUNCTIONS ///
    ///create locker
    CreateLocker,
    ///PARTNER FUNCTIONS ////
    CreatePartnerMetadata(CreatePartnerMetadataIxArgs),
    CreateVirtualPoolMetadata(CreateVirtualPoolMetadataIxArgs),
    CreatorWithdrawSurplus,
    ///POOL CREATOR FUNCTIONS ////
    InitializeVirtualPoolWithSplToken(InitializeVirtualPoolWithSplTokenIxArgs),
    InitializeVirtualPoolWithToken2022(InitializeVirtualPoolWithToken2022IxArgs),
    MigrateMeteoraDamm,
    MigrateMeteoraDammClaimLpToken,
    MigrateMeteoraDammLockLpToken,
    MigrationDammV2,
    MigrationDammV2CreateMetadata,
    ///migrate damm v1
    MigrationMeteoraDammCreateMetadata,
    PartnerWithdrawSurplus,
    ProtocolWithdrawSurplus,
    ///TRADING BOTS FUNCTIONS ////
    Swap(SwapIxArgs),
    TransferPoolCreator,
    WithdrawLeftover,
    ///BOTH partner and creator FUNCTIONS ///
    WithdrawMigrationFee(WithdrawMigrationFeeIxArgs),
}
/// Parse instruction data based on 8-byte discriminator (Anchor contracts)
pub fn parse_instruction(data: &[u8]) -> Result<MeteoraDbcInstruction, std::io::Error> {
    if data.len() < 8 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data too short for discriminator",
        ));
    }
    let discriminator: [u8; 8] = data[0..8].try_into().map_err(|_| {
        std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Failed to read discriminator",
        )
    })?;
    let mut ix_data = &data[8..];
    match discriminator {
        CLAIM_CREATOR_TRADING_FEE_IX_DISCM => {
            let args = ClaimCreatorTradingFeeIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDbcInstruction::ClaimCreatorTradingFee(args))
        }
        CLAIM_PROTOCOL_FEE_IX_DISCM => Ok(MeteoraDbcInstruction::ClaimProtocolFee),
        CLAIM_TRADING_FEE_IX_DISCM => {
            let args = ClaimTradingFeeIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDbcInstruction::ClaimTradingFee(args))
        }
        CLOSE_CLAIM_FEE_OPERATOR_IX_DISCM => Ok(MeteoraDbcInstruction::CloseClaimFeeOperator),
        CREATE_CLAIM_FEE_OPERATOR_IX_DISCM => Ok(MeteoraDbcInstruction::CreateClaimFeeOperator),
        CREATE_CONFIG_IX_DISCM => {
            let args = CreateConfigIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDbcInstruction::CreateConfig(args))
        }
        CREATE_LOCKER_IX_DISCM => Ok(MeteoraDbcInstruction::CreateLocker),
        CREATE_PARTNER_METADATA_IX_DISCM => {
            let args = CreatePartnerMetadataIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDbcInstruction::CreatePartnerMetadata(args))
        }
        CREATE_VIRTUAL_POOL_METADATA_IX_DISCM => {
            let args = CreateVirtualPoolMetadataIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDbcInstruction::CreateVirtualPoolMetadata(args))
        }
        CREATOR_WITHDRAW_SURPLUS_IX_DISCM => Ok(MeteoraDbcInstruction::CreatorWithdrawSurplus),
        INITIALIZE_VIRTUAL_POOL_WITH_SPL_TOKEN_IX_DISCM => {
            let args = InitializeVirtualPoolWithSplTokenIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDbcInstruction::InitializeVirtualPoolWithSplToken(
                args,
            ))
        }
        INITIALIZE_VIRTUAL_POOL_WITH_TOKEN2022_IX_DISCM => {
            let args = InitializeVirtualPoolWithToken2022IxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDbcInstruction::InitializeVirtualPoolWithToken2022(
                args,
            ))
        }
        MIGRATE_METEORA_DAMM_IX_DISCM => Ok(MeteoraDbcInstruction::MigrateMeteoraDamm),
        MIGRATE_METEORA_DAMM_CLAIM_LP_TOKEN_IX_DISCM => {
            Ok(MeteoraDbcInstruction::MigrateMeteoraDammClaimLpToken)
        }
        MIGRATE_METEORA_DAMM_LOCK_LP_TOKEN_IX_DISCM => {
            Ok(MeteoraDbcInstruction::MigrateMeteoraDammLockLpToken)
        }
        MIGRATION_DAMM_V2_IX_DISCM => Ok(MeteoraDbcInstruction::MigrationDammV2),
        MIGRATION_DAMM_V2_CREATE_METADATA_IX_DISCM => {
            Ok(MeteoraDbcInstruction::MigrationDammV2CreateMetadata)
        }
        MIGRATION_METEORA_DAMM_CREATE_METADATA_IX_DISCM => {
            Ok(MeteoraDbcInstruction::MigrationMeteoraDammCreateMetadata)
        }
        PARTNER_WITHDRAW_SURPLUS_IX_DISCM => Ok(MeteoraDbcInstruction::PartnerWithdrawSurplus),
        PROTOCOL_WITHDRAW_SURPLUS_IX_DISCM => Ok(MeteoraDbcInstruction::ProtocolWithdrawSurplus),
        SWAP_IX_DISCM => {
            let args = SwapIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDbcInstruction::Swap(args))
        }
        TRANSFER_POOL_CREATOR_IX_DISCM => Ok(MeteoraDbcInstruction::TransferPoolCreator),
        WITHDRAW_LEFTOVER_IX_DISCM => Ok(MeteoraDbcInstruction::WithdrawLeftover),
        WITHDRAW_MIGRATION_FEE_IX_DISCM => {
            let args = WithdrawMigrationFeeIxArgs::deserialize(&mut ix_data)?;
            Ok(MeteoraDbcInstruction::WithdrawMigrationFee(args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {:?}", discriminator),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_claim_creator_trading_fee_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = ClaimCreatorTradingFeeIxArgs {
            max_base_amount: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CLAIM_CREATOR_TRADING_FEE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDbcInstruction::ClaimCreatorTradingFee(args)) => {
                assert_eq!(
                    args.max_base_amount, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ClaimCreatorTradingFee)
                );
            }
        }
    }
    #[test]
    fn test_claim_protocol_fee_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CLAIM_PROTOCOL_FEE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDbcInstruction::ClaimProtocolFee => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_claim_trading_fee_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = ClaimTradingFeeIxArgs {
            max_amount_a: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CLAIM_TRADING_FEE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDbcInstruction::ClaimTradingFee(args)) => {
                assert_eq!(
                    args.max_amount_a, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ClaimTradingFee)
                );
            }
        }
    }
    #[test]
    fn test_close_claim_fee_operator_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CLOSE_CLAIM_FEE_OPERATOR_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDbcInstruction::CloseClaimFeeOperator => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_create_claim_fee_operator_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATE_CLAIM_FEE_OPERATOR_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDbcInstruction::CreateClaimFeeOperator => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_create_config_consistency() {
        let test_args = CreateConfigIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATE_CONFIG_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDbcInstruction::CreateConfig(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CreateConfig)
                );
            }
        }
    }
    #[test]
    fn test_create_locker_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATE_LOCKER_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDbcInstruction::CreateLocker => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_create_partner_metadata_consistency() {
        let test_args = CreatePartnerMetadataIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATE_PARTNER_METADATA_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDbcInstruction::CreatePartnerMetadata(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CreatePartnerMetadata)
                );
            }
        }
    }
    #[test]
    fn test_create_virtual_pool_metadata_consistency() {
        let test_args = CreateVirtualPoolMetadataIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATE_VIRTUAL_POOL_METADATA_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDbcInstruction::CreateVirtualPoolMetadata(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CreateVirtualPoolMetadata)
                );
            }
        }
    }
    #[test]
    fn test_creator_withdraw_surplus_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATOR_WITHDRAW_SURPLUS_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDbcInstruction::CreatorWithdrawSurplus => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_initialize_virtual_pool_with_spl_token_consistency() {
        let test_args = InitializeVirtualPoolWithSplTokenIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_VIRTUAL_POOL_WITH_SPL_TOKEN_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDbcInstruction::InitializeVirtualPoolWithSplToken(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializeVirtualPoolWithSplToken)
                );
            }
        }
    }
    #[test]
    fn test_initialize_virtual_pool_with_token_2022_consistency() {
        let test_args = InitializeVirtualPoolWithToken2022IxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_VIRTUAL_POOL_WITH_TOKEN2022_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDbcInstruction::InitializeVirtualPoolWithToken2022(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitializeVirtualPoolWithToken2022)
                );
            }
        }
    }
    #[test]
    fn test_migrate_meteora_damm_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MIGRATE_METEORA_DAMM_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDbcInstruction::MigrateMeteoraDamm => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_migrate_meteora_damm_claim_lp_token_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MIGRATE_METEORA_DAMM_CLAIM_LP_TOKEN_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDbcInstruction::MigrateMeteoraDammClaimLpToken => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_migrate_meteora_damm_lock_lp_token_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MIGRATE_METEORA_DAMM_LOCK_LP_TOKEN_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDbcInstruction::MigrateMeteoraDammLockLpToken => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_migration_damm_v_2_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MIGRATION_DAMM_V2_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDbcInstruction::MigrationDammV2 => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_migration_damm_v_2_create_metadata_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MIGRATION_DAMM_V2_CREATE_METADATA_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDbcInstruction::MigrationDammV2CreateMetadata => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_migration_meteora_damm_create_metadata_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&MIGRATION_METEORA_DAMM_CREATE_METADATA_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDbcInstruction::MigrationMeteoraDammCreateMetadata => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_partner_withdraw_surplus_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&PARTNER_WITHDRAW_SURPLUS_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDbcInstruction::PartnerWithdrawSurplus => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_protocol_withdraw_surplus_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&PROTOCOL_WITHDRAW_SURPLUS_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDbcInstruction::ProtocolWithdrawSurplus => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_swap_consistency() {
        let test_args = SwapIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SWAP_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDbcInstruction::Swap(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Swap)
                );
            }
        }
    }
    #[test]
    fn test_transfer_pool_creator_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&TRANSFER_POOL_CREATOR_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDbcInstruction::TransferPoolCreator => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_withdraw_leftover_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&WITHDRAW_LEFTOVER_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            MeteoraDbcInstruction::WithdrawLeftover => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_withdraw_migration_fee_consistency() {
        let expected_first_arg = 100u8;
        let test_args = WithdrawMigrationFeeIxArgs {
            flag: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&WITHDRAW_MIGRATION_FEE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(MeteoraDbcInstruction::WithdrawMigrationFee(args)) => {
                assert_eq!(
                    args.flag, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(WithdrawMigrationFee)
                );
            }
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_args = ClaimCreatorTradingFeeIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ClaimCreatorTradingFeeIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CLAIM_CREATOR_TRADING_FEE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::ClaimCreatorTradingFee(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CLAIM_CREATOR_TRADING_FEE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ClaimCreatorTradingFee)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ClaimCreatorTradingFee),
                    e
                );
            }
        }
        let test_data = CLAIM_PROTOCOL_FEE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::ClaimProtocolFee => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ClaimProtocolFee)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ClaimProtocolFee),
                    e
                );
            }
        }
        let test_args = ClaimTradingFeeIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ClaimTradingFeeIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CLAIM_TRADING_FEE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::ClaimTradingFee(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CLAIM_TRADING_FEE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ClaimTradingFee)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ClaimTradingFee),
                    e
                );
            }
        }
        let test_data = CLOSE_CLAIM_FEE_OPERATOR_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::CloseClaimFeeOperator => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CloseClaimFeeOperator)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CloseClaimFeeOperator),
                    e
                );
            }
        }
        let test_data = CREATE_CLAIM_FEE_OPERATOR_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::CreateClaimFeeOperator => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CreateClaimFeeOperator)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CreateClaimFeeOperator),
                    e
                );
            }
        }
        let test_args = CreateConfigIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CreateConfigIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CREATE_CONFIG_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::CreateConfig(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CREATE_CONFIG_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(CreateConfig))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CreateConfig),
                    e
                );
            }
        }
        let test_data = CREATE_LOCKER_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::CreateLocker => {}
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(CreateLocker))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CreateLocker),
                    e
                );
            }
        }
        let test_args = CreatePartnerMetadataIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CreatePartnerMetadataIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CREATE_PARTNER_METADATA_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::CreatePartnerMetadata(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CREATE_PARTNER_METADATA_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CreatePartnerMetadata)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CreatePartnerMetadata),
                    e
                );
            }
        }
        let test_args = CreateVirtualPoolMetadataIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CreateVirtualPoolMetadataIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CREATE_VIRTUAL_POOL_METADATA_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::CreateVirtualPoolMetadata(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CREATE_VIRTUAL_POOL_METADATA_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CreateVirtualPoolMetadata)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CreateVirtualPoolMetadata),
                    e
                );
            }
        }
        let test_data = CREATOR_WITHDRAW_SURPLUS_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::CreatorWithdrawSurplus => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CreatorWithdrawSurplus)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CreatorWithdrawSurplus),
                    e
                );
            }
        }
        let test_args = InitializeVirtualPoolWithSplTokenIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializeVirtualPoolWithSplTokenIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_VIRTUAL_POOL_WITH_SPL_TOKEN_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::InitializeVirtualPoolWithSplToken(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_VIRTUAL_POOL_WITH_SPL_TOKEN_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializeVirtualPoolWithSplToken)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializeVirtualPoolWithSplToken),
                    e
                );
            }
        }
        let test_args = InitializeVirtualPoolWithToken2022IxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializeVirtualPoolWithToken2022IxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_VIRTUAL_POOL_WITH_TOKEN2022_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::InitializeVirtualPoolWithToken2022(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_VIRTUAL_POOL_WITH_TOKEN2022_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitializeVirtualPoolWithToken2022)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitializeVirtualPoolWithToken2022),
                    e
                );
            }
        }
        let test_data = MIGRATE_METEORA_DAMM_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::MigrateMeteoraDamm => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MigrateMeteoraDamm)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MigrateMeteoraDamm),
                    e
                );
            }
        }
        let test_data = MIGRATE_METEORA_DAMM_CLAIM_LP_TOKEN_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::MigrateMeteoraDammClaimLpToken => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MigrateMeteoraDammClaimLpToken)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MigrateMeteoraDammClaimLpToken),
                    e
                );
            }
        }
        let test_data = MIGRATE_METEORA_DAMM_LOCK_LP_TOKEN_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::MigrateMeteoraDammLockLpToken => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MigrateMeteoraDammLockLpToken)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MigrateMeteoraDammLockLpToken),
                    e
                );
            }
        }
        let test_data = MIGRATION_DAMM_V2_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::MigrationDammV2 => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MigrationDammV2)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MigrationDammV2),
                    e
                );
            }
        }
        let test_data = MIGRATION_DAMM_V2_CREATE_METADATA_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::MigrationDammV2CreateMetadata => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MigrationDammV2CreateMetadata)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MigrationDammV2CreateMetadata),
                    e
                );
            }
        }
        let test_data = MIGRATION_METEORA_DAMM_CREATE_METADATA_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::MigrationMeteoraDammCreateMetadata => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(MigrationMeteoraDammCreateMetadata)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(MigrationMeteoraDammCreateMetadata),
                    e
                );
            }
        }
        let test_data = PARTNER_WITHDRAW_SURPLUS_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::PartnerWithdrawSurplus => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(PartnerWithdrawSurplus)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(PartnerWithdrawSurplus),
                    e
                );
            }
        }
        let test_data = PROTOCOL_WITHDRAW_SURPLUS_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::ProtocolWithdrawSurplus => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ProtocolWithdrawSurplus)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ProtocolWithdrawSurplus),
                    e
                );
            }
        }
        let test_args = SwapIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SwapIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SWAP_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::Swap(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SWAP_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(Swap)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Swap),
                    e
                );
            }
        }
        let test_data = TRANSFER_POOL_CREATOR_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::TransferPoolCreator => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(TransferPoolCreator)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(TransferPoolCreator),
                    e
                );
            }
        }
        let test_data = WITHDRAW_LEFTOVER_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::WithdrawLeftover => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(WithdrawLeftover)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(WithdrawLeftover),
                    e
                );
            }
        }
        let test_args = WithdrawMigrationFeeIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(WithdrawMigrationFeeIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &WITHDRAW_MIGRATION_FEE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                MeteoraDbcInstruction::WithdrawMigrationFee(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, WITHDRAW_MIGRATION_FEE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(WithdrawMigrationFee)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(WithdrawMigrationFee),
                    e
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = parse_instruction(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = parse_instruction(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
