//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::AccountInfo,
    entrypoint::ProgramResult,
    instruction::{AccountMeta, Instruction},
    program::{invoke, invoke_signed},
    pubkey::Pubkey,
};
use std::io::Read;
fn invoke_instruction<'info, A: Into<[AccountInfo<'info>; N]>, const N: usize>(
    ix: &Instruction,
    accounts: A,
) -> ProgramResult {
    let account_info: [AccountInfo<'info>; N] = accounts.into();
    invoke(ix, &account_info)
}
fn invoke_instruction_signed<'info, A: Into<[AccountInfo<'info>; N]>, const N: usize>(
    ix: &Instruction,
    accounts: A,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let account_info: [AccountInfo<'info>; N] = accounts.into();
    invoke_signed(ix, &account_info, seeds)
}
pub mod accept_owner;
pub use accept_owner::*;
pub mod approve_strategy;
pub use approve_strategy::*;
pub mod change_amp_factor;
pub use change_amp_factor::*;
pub mod change_max_supply;
pub use change_max_supply::*;
pub mod change_swap_fee;
pub use change_swap_fee::*;
pub mod change_swap_fee_privileged;
pub use change_swap_fee_privileged::*;
pub mod close_strategy;
pub use close_strategy::*;
pub mod create_strategy;
pub use create_strategy::*;
pub mod deposit;
pub use deposit::*;
pub mod exec_strategy;
pub use exec_strategy::*;
pub mod initialize;
pub use initialize::*;
pub mod pause;
pub use pause::*;
pub mod reject_owner;
pub use reject_owner::*;
pub mod shutdown;
pub use shutdown::*;
pub mod swap;
pub use swap::*;
pub mod swap_v2;
pub use swap_v2::*;
pub mod transfer_owner;
pub use transfer_owner::*;
pub mod unpause;
pub use unpause::*;
pub mod withdraw;
pub use withdraw::*;
#[derive(Clone, Debug, PartialEq)]
pub enum StableSwapProgramIx {
    AcceptOwner,
    ApproveStrategy,
    ChangeAmpFactor(ChangeAmpFactorIxArgs),
    ChangeMaxSupply(ChangeMaxSupplyIxArgs),
    ChangeSwapFee(ChangeSwapFeeIxArgs),
    ChangeSwapFeePrivileged(ChangeSwapFeePrivilegedIxArgs),
    CloseStrategy,
    CreateStrategy(CreateStrategyIxArgs),
    Deposit(DepositIxArgs),
    ExecStrategy(ExecStrategyIxArgs),
    Initialize(InitializeIxArgs),
    Pause,
    RejectOwner,
    Shutdown,
    Swap(SwapIxArgs),
    SwapV2(SwapV2IxArgs),
    TransferOwner(TransferOwnerIxArgs),
    Unpause,
    Withdraw(WithdrawIxArgs),
}
impl StableSwapProgramIx {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        match maybe_discm {
            ACCEPT_OWNER_IX_DISCM => Ok(Self::AcceptOwner),
            APPROVE_STRATEGY_IX_DISCM => Ok(Self::ApproveStrategy),
            CHANGE_AMP_FACTOR_IX_DISCM => Ok(Self::ChangeAmpFactor(
                ChangeAmpFactorIxArgs::deserialize(&mut reader)?,
            )),
            CHANGE_MAX_SUPPLY_IX_DISCM => Ok(Self::ChangeMaxSupply(
                ChangeMaxSupplyIxArgs::deserialize(&mut reader)?,
            )),
            CHANGE_SWAP_FEE_IX_DISCM => Ok(Self::ChangeSwapFee(ChangeSwapFeeIxArgs::deserialize(
                &mut reader,
            )?)),
            CHANGE_SWAP_FEE_PRIVILEGED_IX_DISCM => Ok(Self::ChangeSwapFeePrivileged(
                ChangeSwapFeePrivilegedIxArgs::deserialize(&mut reader)?,
            )),
            CLOSE_STRATEGY_IX_DISCM => Ok(Self::CloseStrategy),
            CREATE_STRATEGY_IX_DISCM => Ok(Self::CreateStrategy(
                CreateStrategyIxArgs::deserialize(&mut reader)?,
            )),
            DEPOSIT_IX_DISCM => Ok(Self::Deposit(DepositIxArgs::deserialize(&mut reader)?)),
            EXEC_STRATEGY_IX_DISCM => Ok(Self::ExecStrategy(ExecStrategyIxArgs::deserialize(
                &mut reader,
            )?)),
            INITIALIZE_IX_DISCM => Ok(Self::Initialize(InitializeIxArgs::deserialize(
                &mut reader,
            )?)),
            PAUSE_IX_DISCM => Ok(Self::Pause),
            REJECT_OWNER_IX_DISCM => Ok(Self::RejectOwner),
            SHUTDOWN_IX_DISCM => Ok(Self::Shutdown),
            SWAP_IX_DISCM => Ok(Self::Swap(SwapIxArgs::deserialize(&mut reader)?)),
            SWAP_V2_IX_DISCM => Ok(Self::SwapV2(SwapV2IxArgs::deserialize(&mut reader)?)),
            TRANSFER_OWNER_IX_DISCM => Ok(Self::TransferOwner(TransferOwnerIxArgs::deserialize(
                &mut reader,
            )?)),
            UNPAUSE_IX_DISCM => Ok(Self::Unpause),
            WITHDRAW_IX_DISCM => Ok(Self::Withdraw(WithdrawIxArgs::deserialize(&mut reader)?)),
            _ => Err(std::io::Error::new(
                std::io::ErrorKind::Other,
                format!("discm {:?} not found", maybe_discm),
            )),
        }
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        match self {
            Self::AcceptOwner => writer.write_all(&ACCEPT_OWNER_IX_DISCM),
            Self::ApproveStrategy => writer.write_all(&APPROVE_STRATEGY_IX_DISCM),
            Self::ChangeAmpFactor(args) => {
                writer.write_all(&CHANGE_AMP_FACTOR_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::ChangeMaxSupply(args) => {
                writer.write_all(&CHANGE_MAX_SUPPLY_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::ChangeSwapFee(args) => {
                writer.write_all(&CHANGE_SWAP_FEE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::ChangeSwapFeePrivileged(args) => {
                writer.write_all(&CHANGE_SWAP_FEE_PRIVILEGED_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::CloseStrategy => writer.write_all(&CLOSE_STRATEGY_IX_DISCM),
            Self::CreateStrategy(args) => {
                writer.write_all(&CREATE_STRATEGY_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::Deposit(args) => {
                writer.write_all(&DEPOSIT_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::ExecStrategy(args) => {
                writer.write_all(&EXEC_STRATEGY_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::Initialize(args) => {
                writer.write_all(&INITIALIZE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::Pause => writer.write_all(&PAUSE_IX_DISCM),
            Self::RejectOwner => writer.write_all(&REJECT_OWNER_IX_DISCM),
            Self::Shutdown => writer.write_all(&SHUTDOWN_IX_DISCM),
            Self::Swap(args) => {
                writer.write_all(&SWAP_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::SwapV2(args) => {
                writer.write_all(&SWAP_V2_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::TransferOwner(args) => {
                writer.write_all(&TRANSFER_OWNER_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::Unpause => writer.write_all(&UNPAUSE_IX_DISCM),
            Self::Withdraw(args) => {
                writer.write_all(&WITHDRAW_IX_DISCM)?;
                args.serialize(&mut writer)
            }
        }
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
