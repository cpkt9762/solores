//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::instructions::*;
pub const ACCEPT_OWNER_IX_DISCM: [u8; 8] = [176u8, 23u8, 41u8, 28u8, 23u8, 111u8, 8u8, 4u8];
pub const APPROVE_STRATEGY_IX_DISCM: [u8; 8] = [7u8, 141u8, 162u8, 60u8, 71u8, 115u8, 26u8, 146u8];
pub const CHANGE_AMP_FACTOR_IX_DISCM: [u8; 8] =
    [56u8, 238u8, 189u8, 35u8, 200u8, 157u8, 42u8, 66u8];
pub const CHANGE_MAX_SUPPLY_IX_DISCM: [u8; 8] = [93u8, 176u8, 0u8, 205u8, 69u8, 63u8, 87u8, 80u8];
pub const CHANGE_SWAP_FEE_IX_DISCM: [u8; 8] = [231u8, 15u8, 132u8, 51u8, 132u8, 165u8, 64u8, 170u8];
pub const CHANGE_SWAP_FEE_PRIVILEGED_IX_DISCM: [u8; 8] =
    [155u8, 200u8, 14u8, 91u8, 105u8, 38u8, 220u8, 119u8];
pub const CLOSE_STRATEGY_IX_DISCM: [u8; 8] = [56u8, 247u8, 170u8, 246u8, 89u8, 221u8, 134u8, 200u8];
pub const CREATE_STRATEGY_IX_DISCM: [u8; 8] =
    [152u8, 160u8, 107u8, 148u8, 245u8, 190u8, 127u8, 224u8];
pub const DEPOSIT_IX_DISCM: [u8; 8] = [242u8, 35u8, 198u8, 137u8, 82u8, 225u8, 242u8, 182u8];
pub const EXEC_STRATEGY_IX_DISCM: [u8; 8] = [249u8, 46u8, 55u8, 57u8, 31u8, 38u8, 61u8, 27u8];
pub const INITIALIZE_IX_DISCM: [u8; 8] = [175u8, 175u8, 109u8, 31u8, 13u8, 152u8, 155u8, 237u8];
pub const PAUSE_IX_DISCM: [u8; 8] = [211u8, 22u8, 221u8, 251u8, 74u8, 121u8, 193u8, 47u8];
pub const REJECT_OWNER_IX_DISCM: [u8; 8] = [238u8, 206u8, 198u8, 215u8, 51u8, 178u8, 133u8, 228u8];
pub const SHUTDOWN_IX_DISCM: [u8; 8] = [146u8, 204u8, 241u8, 213u8, 86u8, 21u8, 253u8, 211u8];
pub const SWAP_IX_DISCM: [u8; 8] = [248u8, 198u8, 158u8, 145u8, 225u8, 117u8, 135u8, 200u8];
pub const SWAP_V2_IX_DISCM: [u8; 8] = [43u8, 4u8, 237u8, 11u8, 26u8, 201u8, 30u8, 98u8];
pub const TRANSFER_OWNER_IX_DISCM: [u8; 8] = [245u8, 25u8, 221u8, 175u8, 106u8, 229u8, 225u8, 45u8];
pub const UNPAUSE_IX_DISCM: [u8; 8] = [169u8, 144u8, 4u8, 38u8, 10u8, 141u8, 188u8, 255u8];
pub const WITHDRAW_IX_DISCM: [u8; 8] = [183u8, 18u8, 70u8, 156u8, 148u8, 109u8, 161u8, 34u8];
/// Program instruction types
#[derive(Clone, Debug, PartialEq)]
pub enum StableSwapInstruction {
    AcceptOwner,
    ApproveStrategy,
    ChangeAmpFactor(ChangeAmpFactorIxArgs),
    ChangeMaxSupply(ChangeMaxSupplyIxArgs),
    ChangeSwapFee(ChangeSwapFeeIxArgs),
    ChangeSwapFeePrivileged(ChangeSwapFeePrivilegedIxArgs),
    CloseStrategy,
    CreateStrategy(CreateStrategyIxArgs),
    ///add liquidity
    Deposit(DepositIxArgs),
    ExecStrategy(ExecStrategyIxArgs),
    ///initialize a pool
    Initialize(InitializeIxArgs),
    Pause,
    RejectOwner,
    ///shutdown the zero-liquidity pool
    Shutdown,
    ///swap
    Swap(SwapIxArgs),
    SwapV2(SwapV2IxArgs),
    TransferOwner(TransferOwnerIxArgs),
    Unpause,
    ///remove liquidity
    Withdraw(WithdrawIxArgs),
}
/// Parse instruction data based on 8-byte discriminator (Anchor contracts)
pub fn parse_instruction(data: &[u8]) -> Result<StableSwapInstruction, std::io::Error> {
    if data.len() < 8 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data too short for discriminator",
        ));
    }
    let discriminator: [u8; 8] = data[0..8].try_into().map_err(|_| {
        std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Failed to read discriminator",
        )
    })?;
    let mut ix_data = &data[8..];
    match discriminator {
        ACCEPT_OWNER_IX_DISCM => Ok(StableSwapInstruction::AcceptOwner),
        APPROVE_STRATEGY_IX_DISCM => Ok(StableSwapInstruction::ApproveStrategy),
        CHANGE_AMP_FACTOR_IX_DISCM => {
            let args = ChangeAmpFactorIxArgs::deserialize(&mut ix_data)?;
            Ok(StableSwapInstruction::ChangeAmpFactor(args))
        }
        CHANGE_MAX_SUPPLY_IX_DISCM => {
            let args = ChangeMaxSupplyIxArgs::deserialize(&mut ix_data)?;
            Ok(StableSwapInstruction::ChangeMaxSupply(args))
        }
        CHANGE_SWAP_FEE_IX_DISCM => {
            let args = ChangeSwapFeeIxArgs::deserialize(&mut ix_data)?;
            Ok(StableSwapInstruction::ChangeSwapFee(args))
        }
        CHANGE_SWAP_FEE_PRIVILEGED_IX_DISCM => {
            let args = ChangeSwapFeePrivilegedIxArgs::deserialize(&mut ix_data)?;
            Ok(StableSwapInstruction::ChangeSwapFeePrivileged(args))
        }
        CLOSE_STRATEGY_IX_DISCM => Ok(StableSwapInstruction::CloseStrategy),
        CREATE_STRATEGY_IX_DISCM => {
            let args = CreateStrategyIxArgs::deserialize(&mut ix_data)?;
            Ok(StableSwapInstruction::CreateStrategy(args))
        }
        DEPOSIT_IX_DISCM => {
            let args = DepositIxArgs::deserialize(&mut ix_data)?;
            Ok(StableSwapInstruction::Deposit(args))
        }
        EXEC_STRATEGY_IX_DISCM => {
            let args = ExecStrategyIxArgs::deserialize(&mut ix_data)?;
            Ok(StableSwapInstruction::ExecStrategy(args))
        }
        INITIALIZE_IX_DISCM => {
            let args = InitializeIxArgs::deserialize(&mut ix_data)?;
            Ok(StableSwapInstruction::Initialize(args))
        }
        PAUSE_IX_DISCM => Ok(StableSwapInstruction::Pause),
        REJECT_OWNER_IX_DISCM => Ok(StableSwapInstruction::RejectOwner),
        SHUTDOWN_IX_DISCM => Ok(StableSwapInstruction::Shutdown),
        SWAP_IX_DISCM => {
            let args = SwapIxArgs::deserialize(&mut ix_data)?;
            Ok(StableSwapInstruction::Swap(args))
        }
        SWAP_V2_IX_DISCM => {
            let args = SwapV2IxArgs::deserialize(&mut ix_data)?;
            Ok(StableSwapInstruction::SwapV2(args))
        }
        TRANSFER_OWNER_IX_DISCM => {
            let args = TransferOwnerIxArgs::deserialize(&mut ix_data)?;
            Ok(StableSwapInstruction::TransferOwner(args))
        }
        UNPAUSE_IX_DISCM => Ok(StableSwapInstruction::Unpause),
        WITHDRAW_IX_DISCM => {
            let args = WithdrawIxArgs::deserialize(&mut ix_data)?;
            Ok(StableSwapInstruction::Withdraw(args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {:?}", discriminator),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_accept_owner_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&ACCEPT_OWNER_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            StableSwapInstruction::AcceptOwner => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_approve_strategy_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&APPROVE_STRATEGY_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            StableSwapInstruction::ApproveStrategy => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_change_amp_factor_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = ChangeAmpFactorIxArgs {
            new_amp_factor: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CHANGE_AMP_FACTOR_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(StableSwapInstruction::ChangeAmpFactor(args)) => {
                assert_eq!(
                    args.new_amp_factor, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ChangeAmpFactor)
                );
            }
        }
    }
    #[test]
    fn test_change_max_supply_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = ChangeMaxSupplyIxArgs {
            new_max_supply: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CHANGE_MAX_SUPPLY_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(StableSwapInstruction::ChangeMaxSupply(args)) => {
                assert_eq!(
                    args.new_max_supply, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ChangeMaxSupply)
                );
            }
        }
    }
    #[test]
    fn test_change_swap_fee_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = ChangeSwapFeeIxArgs {
            new_swap_fee: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CHANGE_SWAP_FEE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(StableSwapInstruction::ChangeSwapFee(args)) => {
                assert_eq!(
                    args.new_swap_fee, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ChangeSwapFee)
                );
            }
        }
    }
    #[test]
    fn test_change_swap_fee_privileged_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = ChangeSwapFeePrivilegedIxArgs {
            new_swap_fee: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CHANGE_SWAP_FEE_PRIVILEGED_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(StableSwapInstruction::ChangeSwapFeePrivileged(args)) => {
                assert_eq!(
                    args.new_swap_fee, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ChangeSwapFeePrivileged)
                );
            }
        }
    }
    #[test]
    fn test_close_strategy_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CLOSE_STRATEGY_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            StableSwapInstruction::CloseStrategy => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_create_strategy_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = CreateStrategyIxArgs {
            amp_min_factor: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATE_STRATEGY_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(StableSwapInstruction::CreateStrategy(args)) => {
                assert_eq!(
                    args.amp_min_factor, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CreateStrategy)
                );
            }
        }
    }
    #[test]
    fn test_deposit_consistency() {
        let test_args = DepositIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&DEPOSIT_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(StableSwapInstruction::Deposit(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Deposit)
                );
            }
        }
    }
    #[test]
    fn test_exec_strategy_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = ExecStrategyIxArgs {
            ramp_step: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&EXEC_STRATEGY_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(StableSwapInstruction::ExecStrategy(args)) => {
                assert_eq!(
                    args.ramp_step, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(ExecStrategy)
                );
            }
        }
    }
    #[test]
    fn test_initialize_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = InitializeIxArgs {
            amp_factor: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(StableSwapInstruction::Initialize(args)) => {
                assert_eq!(
                    args.amp_factor, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Initialize)
                );
            }
        }
    }
    #[test]
    fn test_pause_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&PAUSE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            StableSwapInstruction::Pause => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_reject_owner_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&REJECT_OWNER_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            StableSwapInstruction::RejectOwner => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_shutdown_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SHUTDOWN_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            StableSwapInstruction::Shutdown => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_swap_consistency() {
        let test_args = SwapIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SWAP_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(StableSwapInstruction::Swap(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Swap)
                );
            }
        }
    }
    #[test]
    fn test_swap_v_2_consistency() {
        let test_args = SwapV2IxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SWAP_V2_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(StableSwapInstruction::SwapV2(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SwapV2)
                );
            }
        }
    }
    #[test]
    fn test_transfer_owner_consistency() {
        let test_args = TransferOwnerIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&TRANSFER_OWNER_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(StableSwapInstruction::TransferOwner(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(TransferOwner)
                );
            }
        }
    }
    #[test]
    fn test_unpause_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&UNPAUSE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            StableSwapInstruction::Unpause => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_withdraw_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = WithdrawIxArgs {
            amount: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&WITHDRAW_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(StableSwapInstruction::Withdraw(args)) => {
                assert_eq!(
                    args.amount, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Withdraw)
                );
            }
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_data = ACCEPT_OWNER_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::AcceptOwner => {}
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(AcceptOwner))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(AcceptOwner),
                    e
                );
            }
        }
        let test_data = APPROVE_STRATEGY_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::ApproveStrategy => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ApproveStrategy)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ApproveStrategy),
                    e
                );
            }
        }
        let test_args = ChangeAmpFactorIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ChangeAmpFactorIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CHANGE_AMP_FACTOR_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::ChangeAmpFactor(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CHANGE_AMP_FACTOR_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ChangeAmpFactor)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ChangeAmpFactor),
                    e
                );
            }
        }
        let test_args = ChangeMaxSupplyIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ChangeMaxSupplyIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CHANGE_MAX_SUPPLY_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::ChangeMaxSupply(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CHANGE_MAX_SUPPLY_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ChangeMaxSupply)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ChangeMaxSupply),
                    e
                );
            }
        }
        let test_args = ChangeSwapFeeIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ChangeSwapFeeIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CHANGE_SWAP_FEE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::ChangeSwapFee(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CHANGE_SWAP_FEE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(ChangeSwapFee))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ChangeSwapFee),
                    e
                );
            }
        }
        let test_args = ChangeSwapFeePrivilegedIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ChangeSwapFeePrivilegedIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CHANGE_SWAP_FEE_PRIVILEGED_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::ChangeSwapFeePrivileged(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CHANGE_SWAP_FEE_PRIVILEGED_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(ChangeSwapFeePrivileged)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ChangeSwapFeePrivileged),
                    e
                );
            }
        }
        let test_data = CLOSE_STRATEGY_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::CloseStrategy => {}
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(CloseStrategy))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CloseStrategy),
                    e
                );
            }
        }
        let test_args = CreateStrategyIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CreateStrategyIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CREATE_STRATEGY_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::CreateStrategy(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CREATE_STRATEGY_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CreateStrategy)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CreateStrategy),
                    e
                );
            }
        }
        let test_args = DepositIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(DepositIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &DEPOSIT_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::Deposit(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, DEPOSIT_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(Deposit)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Deposit),
                    e
                );
            }
        }
        let test_args = ExecStrategyIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(ExecStrategyIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &EXEC_STRATEGY_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::ExecStrategy(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, EXEC_STRATEGY_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(ExecStrategy))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ExecStrategy),
                    e
                );
            }
        }
        let test_args = InitializeIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializeIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::Initialize(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(Initialize))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Initialize),
                    e
                );
            }
        }
        let test_data = PAUSE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::Pause => {}
                _ => panic!("Parsed instruction should be {}", stringify!(Pause)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Pause),
                    e
                );
            }
        }
        let test_data = REJECT_OWNER_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::RejectOwner => {}
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(RejectOwner))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(RejectOwner),
                    e
                );
            }
        }
        let test_data = SHUTDOWN_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::Shutdown => {}
                _ => panic!("Parsed instruction should be {}", stringify!(Shutdown)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Shutdown),
                    e
                );
            }
        }
        let test_args = SwapIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SwapIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SWAP_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::Swap(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SWAP_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(Swap)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Swap),
                    e
                );
            }
        }
        let test_args = SwapV2IxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SwapV2IxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SWAP_V2_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::SwapV2(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SWAP_V2_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(SwapV2)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SwapV2),
                    e
                );
            }
        }
        let test_args = TransferOwnerIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(TransferOwnerIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &TRANSFER_OWNER_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::TransferOwner(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, TRANSFER_OWNER_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(TransferOwner))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(TransferOwner),
                    e
                );
            }
        }
        let test_data = UNPAUSE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::Unpause => {}
                _ => panic!("Parsed instruction should be {}", stringify!(Unpause)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Unpause),
                    e
                );
            }
        }
        let test_args = WithdrawIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(WithdrawIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &WITHDRAW_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                StableSwapInstruction::Withdraw(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, WITHDRAW_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(Withdraw)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Withdraw),
                    e
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = parse_instruction(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = parse_instruction(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
