//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::instructions::*;
pub const BUY_IX_DISCM: [u8; 8] = [102u8, 6u8, 61u8, 18u8, 1u8, 218u8, 235u8, 234u8];
pub const COLLECT_COIN_CREATOR_FEE_IX_DISCM: [u8; 8] =
    [160u8, 57u8, 89u8, 42u8, 181u8, 139u8, 43u8, 66u8];
pub const CREATE_CONFIG_IX_DISCM: [u8; 8] = [201u8, 207u8, 243u8, 114u8, 75u8, 111u8, 47u8, 189u8];
pub const CREATE_POOL_IX_DISCM: [u8; 8] = [233u8, 146u8, 209u8, 142u8, 207u8, 104u8, 64u8, 188u8];
pub const DEPOSIT_IX_DISCM: [u8; 8] = [242u8, 35u8, 198u8, 137u8, 82u8, 225u8, 242u8, 182u8];
pub const DISABLE_IX_DISCM: [u8; 8] = [185u8, 173u8, 187u8, 90u8, 216u8, 15u8, 238u8, 233u8];
pub const EXTEND_ACCOUNT_IX_DISCM: [u8; 8] = [234u8, 102u8, 194u8, 203u8, 150u8, 72u8, 62u8, 229u8];
pub const SELL_IX_DISCM: [u8; 8] = [51u8, 230u8, 133u8, 164u8, 1u8, 127u8, 131u8, 173u8];
pub const SET_COIN_CREATOR_IX_DISCM: [u8; 8] =
    [210u8, 149u8, 128u8, 45u8, 188u8, 58u8, 78u8, 175u8];
pub const UPDATE_ADMIN_IX_DISCM: [u8; 8] = [161u8, 176u8, 40u8, 213u8, 60u8, 184u8, 179u8, 228u8];
pub const UPDATE_FEE_CONFIG_IX_DISCM: [u8; 8] =
    [104u8, 184u8, 103u8, 242u8, 88u8, 151u8, 107u8, 20u8];
pub const WITHDRAW_IX_DISCM: [u8; 8] = [183u8, 18u8, 70u8, 156u8, 148u8, 109u8, 161u8, 34u8];
/// Program instruction types
#[derive(Clone, Debug, PartialEq)]
pub enum PumpAmmInstruction {
    Buy(BuyIxArgs),
    CollectCoinCreatorFee,
    CreateConfig(CreateConfigIxArgs),
    CreatePool(CreatePoolIxArgs),
    Deposit(DepositIxArgs),
    Disable(DisableIxArgs),
    ExtendAccount,
    Sell(SellIxArgs),
    ///Sets Pool::coin_creator from Metaplex metadata creator or BondingCurve::creator
    SetCoinCreator,
    UpdateAdmin,
    UpdateFeeConfig(UpdateFeeConfigIxArgs),
    Withdraw(WithdrawIxArgs),
}
/// Parse instruction data based on 8-byte discriminator (Anchor contracts)
pub fn parse_instruction(data: &[u8]) -> Result<PumpAmmInstruction, std::io::Error> {
    if data.len() < 8 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data too short for discriminator",
        ));
    }
    let discriminator: [u8; 8] = data[0..8].try_into().map_err(|_| {
        std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Failed to read discriminator",
        )
    })?;
    let mut ix_data = &data[8..];
    match discriminator {
        BUY_IX_DISCM => {
            let args = BuyIxArgs::deserialize(&mut ix_data)?;
            Ok(PumpAmmInstruction::Buy(args))
        }
        COLLECT_COIN_CREATOR_FEE_IX_DISCM => Ok(PumpAmmInstruction::CollectCoinCreatorFee),
        CREATE_CONFIG_IX_DISCM => {
            let args = CreateConfigIxArgs::deserialize(&mut ix_data)?;
            Ok(PumpAmmInstruction::CreateConfig(args))
        }
        CREATE_POOL_IX_DISCM => {
            let args = CreatePoolIxArgs::deserialize(&mut ix_data)?;
            Ok(PumpAmmInstruction::CreatePool(args))
        }
        DEPOSIT_IX_DISCM => {
            let args = DepositIxArgs::deserialize(&mut ix_data)?;
            Ok(PumpAmmInstruction::Deposit(args))
        }
        DISABLE_IX_DISCM => {
            let args = DisableIxArgs::deserialize(&mut ix_data)?;
            Ok(PumpAmmInstruction::Disable(args))
        }
        EXTEND_ACCOUNT_IX_DISCM => Ok(PumpAmmInstruction::ExtendAccount),
        SELL_IX_DISCM => {
            let args = SellIxArgs::deserialize(&mut ix_data)?;
            Ok(PumpAmmInstruction::Sell(args))
        }
        SET_COIN_CREATOR_IX_DISCM => Ok(PumpAmmInstruction::SetCoinCreator),
        UPDATE_ADMIN_IX_DISCM => Ok(PumpAmmInstruction::UpdateAdmin),
        UPDATE_FEE_CONFIG_IX_DISCM => {
            let args = UpdateFeeConfigIxArgs::deserialize(&mut ix_data)?;
            Ok(PumpAmmInstruction::UpdateFeeConfig(args))
        }
        WITHDRAW_IX_DISCM => {
            let args = WithdrawIxArgs::deserialize(&mut ix_data)?;
            Ok(PumpAmmInstruction::Withdraw(args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {:?}", discriminator),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_buy_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = BuyIxArgs {
            base_amount_out: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&BUY_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PumpAmmInstruction::Buy(args)) => {
                assert_eq!(
                    args.base_amount_out, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Buy)
                );
            }
        }
    }
    #[test]
    fn test_collect_coin_creator_fee_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&COLLECT_COIN_CREATOR_FEE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            PumpAmmInstruction::CollectCoinCreatorFee => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_create_config_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = CreateConfigIxArgs {
            lp_fee_basis_points: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATE_CONFIG_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PumpAmmInstruction::CreateConfig(args)) => {
                assert_eq!(
                    args.lp_fee_basis_points, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CreateConfig)
                );
            }
        }
    }
    #[test]
    fn test_create_pool_consistency() {
        let expected_first_arg = 1000u16;
        let test_args = CreatePoolIxArgs {
            index: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATE_POOL_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PumpAmmInstruction::CreatePool(args)) => {
                assert_eq!(
                    args.index, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CreatePool)
                );
            }
        }
    }
    #[test]
    fn test_deposit_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = DepositIxArgs {
            lp_token_amount_out: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&DEPOSIT_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PumpAmmInstruction::Deposit(args)) => {
                assert_eq!(
                    args.lp_token_amount_out, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Deposit)
                );
            }
        }
    }
    #[test]
    fn test_disable_consistency() {
        let expected_first_arg = true;
        let test_args = DisableIxArgs {
            disable_create_pool: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&DISABLE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PumpAmmInstruction::Disable(args)) => {
                assert_eq!(
                    args.disable_create_pool, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Disable)
                );
            }
        }
    }
    #[test]
    fn test_extend_account_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&EXTEND_ACCOUNT_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            PumpAmmInstruction::ExtendAccount => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_sell_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = SellIxArgs {
            base_amount_in: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SELL_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PumpAmmInstruction::Sell(args)) => {
                assert_eq!(
                    args.base_amount_in, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Sell)
                );
            }
        }
    }
    #[test]
    fn test_set_coin_creator_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SET_COIN_CREATOR_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            PumpAmmInstruction::SetCoinCreator => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_update_admin_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&UPDATE_ADMIN_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            PumpAmmInstruction::UpdateAdmin => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_update_fee_config_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = UpdateFeeConfigIxArgs {
            lp_fee_basis_points: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&UPDATE_FEE_CONFIG_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PumpAmmInstruction::UpdateFeeConfig(args)) => {
                assert_eq!(
                    args.lp_fee_basis_points, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(UpdateFeeConfig)
                );
            }
        }
    }
    #[test]
    fn test_withdraw_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = WithdrawIxArgs {
            lp_token_amount_in: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&WITHDRAW_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(PumpAmmInstruction::Withdraw(args)) => {
                assert_eq!(
                    args.lp_token_amount_in, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Withdraw)
                );
            }
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_args = BuyIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(BuyIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &BUY_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PumpAmmInstruction::Buy(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, BUY_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(Buy)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Buy),
                    e
                );
            }
        }
        let test_data = COLLECT_COIN_CREATOR_FEE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PumpAmmInstruction::CollectCoinCreatorFee => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CollectCoinCreatorFee)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CollectCoinCreatorFee),
                    e
                );
            }
        }
        let test_args = CreateConfigIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CreateConfigIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CREATE_CONFIG_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PumpAmmInstruction::CreateConfig(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CREATE_CONFIG_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(CreateConfig))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CreateConfig),
                    e
                );
            }
        }
        let test_args = CreatePoolIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CreatePoolIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CREATE_POOL_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PumpAmmInstruction::CreatePool(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CREATE_POOL_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(CreatePool))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CreatePool),
                    e
                );
            }
        }
        let test_args = DepositIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(DepositIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &DEPOSIT_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PumpAmmInstruction::Deposit(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, DEPOSIT_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(Deposit)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Deposit),
                    e
                );
            }
        }
        let test_args = DisableIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(DisableIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &DISABLE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PumpAmmInstruction::Disable(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, DISABLE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(Disable)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Disable),
                    e
                );
            }
        }
        let test_data = EXTEND_ACCOUNT_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PumpAmmInstruction::ExtendAccount => {}
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(ExtendAccount))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(ExtendAccount),
                    e
                );
            }
        }
        let test_args = SellIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SellIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SELL_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PumpAmmInstruction::Sell(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SELL_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(Sell)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Sell),
                    e
                );
            }
        }
        let test_data = SET_COIN_CREATOR_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PumpAmmInstruction::SetCoinCreator => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SetCoinCreator)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SetCoinCreator),
                    e
                );
            }
        }
        let test_data = UPDATE_ADMIN_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PumpAmmInstruction::UpdateAdmin => {}
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(UpdateAdmin))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(UpdateAdmin),
                    e
                );
            }
        }
        let test_args = UpdateFeeConfigIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(UpdateFeeConfigIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &UPDATE_FEE_CONFIG_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PumpAmmInstruction::UpdateFeeConfig(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, UPDATE_FEE_CONFIG_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(UpdateFeeConfig)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(UpdateFeeConfig),
                    e
                );
            }
        }
        let test_args = WithdrawIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(WithdrawIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &WITHDRAW_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                PumpAmmInstruction::Withdraw(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, WITHDRAW_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(Withdraw)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Withdraw),
                    e
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = parse_instruction(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = parse_instruction(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
