//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::{
    account_info::AccountInfo,
    entrypoint::ProgramResult,
    instruction::{AccountMeta, Instruction},
    program::{invoke, invoke_signed},
    pubkey::Pubkey,
};
use std::io::Read;
fn invoke_instruction<'info, A: Into<[AccountInfo<'info>; N]>, const N: usize>(
    ix: &Instruction,
    accounts: A,
) -> ProgramResult {
    let account_info: [AccountInfo<'info>; N] = accounts.into();
    invoke(ix, &account_info)
}
fn invoke_instruction_signed<'info, A: Into<[AccountInfo<'info>; N]>, const N: usize>(
    ix: &Instruction,
    accounts: A,
    seeds: &[&[&[u8]]],
) -> ProgramResult {
    let account_info: [AccountInfo<'info>; N] = accounts.into();
    invoke_signed(ix, &account_info, seeds)
}
pub mod add_operators;
pub use add_operators::*;
pub mod buy_token;
pub use buy_token::*;
pub mod cancel_authority_transfer;
pub use cancel_authority_transfer::*;
pub mod close_bonding_curve_vault;
pub use close_bonding_curve_vault::*;
pub mod collect_meteora_trading_fees;
pub use collect_meteora_trading_fees::*;
pub mod collect_trading_fees;
pub use collect_trading_fees::*;
pub mod complete_authority_transfer;
pub use complete_authority_transfer::*;
pub mod create_meteora_pool;
pub use create_meteora_pool::*;
pub mod create_raydium_pool;
pub use create_raydium_pool::*;
pub mod create_raydium_random_pool;
pub use create_raydium_random_pool::*;
pub mod create_token;
pub use create_token::*;
pub mod create_token_fallback;
pub use create_token_fallback::*;
pub mod deploy_bonding_curve;
pub use deploy_bonding_curve::*;
pub mod deploy_bonding_curve_fallback;
pub use deploy_bonding_curve_fallback::*;
pub mod deposit_into_raydium;
pub use deposit_into_raydium::*;
pub mod graduate;
pub use graduate::*;
pub mod initialize;
pub use initialize::*;
pub mod initiate_authority_transfer;
pub use initiate_authority_transfer::*;
pub mod lock_raydium_liquidity;
pub use lock_raydium_liquidity::*;
pub mod remove_operators;
pub use remove_operators::*;
pub mod sell_token;
pub use sell_token::*;
pub mod split_trading_fees;
pub use split_trading_fees::*;
pub mod swap_sol_for_tokens_on_raydium;
pub use swap_sol_for_tokens_on_raydium::*;
pub mod swap_tokens_for_sol_on_raydium;
pub use swap_tokens_for_sol_on_raydium::*;
pub mod toggle_paused;
pub use toggle_paused::*;
pub mod update_config;
pub use update_config::*;
#[derive(Clone, Debug, PartialEq)]
pub enum BoopProgramIx {
    AddOperators(AddOperatorsIxArgs),
    BuyToken(BuyTokenIxArgs),
    CancelAuthorityTransfer,
    CloseBondingCurveVault,
    CollectMeteoraTradingFees,
    CollectTradingFees,
    CompleteAuthorityTransfer,
    CreateMeteoraPool,
    CreateRaydiumPool,
    CreateRaydiumRandomPool,
    CreateToken(CreateTokenIxArgs),
    CreateTokenFallback(CreateTokenFallbackIxArgs),
    DeployBondingCurve(DeployBondingCurveIxArgs),
    DeployBondingCurveFallback(DeployBondingCurveFallbackIxArgs),
    DepositIntoRaydium(DepositIntoRaydiumIxArgs),
    Graduate,
    Initialize(InitializeIxArgs),
    InitiateAuthorityTransfer(InitiateAuthorityTransferIxArgs),
    LockRaydiumLiquidity,
    RemoveOperators(RemoveOperatorsIxArgs),
    SellToken(SellTokenIxArgs),
    SplitTradingFees,
    SwapSolForTokensOnRaydium(SwapSolForTokensOnRaydiumIxArgs),
    SwapTokensForSolOnRaydium(SwapTokensForSolOnRaydiumIxArgs),
    TogglePaused,
    UpdateConfig(UpdateConfigIxArgs),
}
impl BoopProgramIx {
    pub fn deserialize(buf: &[u8]) -> std::io::Result<Self> {
        let mut reader = buf;
        let mut maybe_discm = [0u8; 8];
        reader.read_exact(&mut maybe_discm)?;
        match maybe_discm {
            ADD_OPERATORS_IX_DISCM => Ok(Self::AddOperators(AddOperatorsIxArgs::deserialize(
                &mut reader,
            )?)),
            BUY_TOKEN_IX_DISCM => Ok(Self::BuyToken(BuyTokenIxArgs::deserialize(&mut reader)?)),
            CANCEL_AUTHORITY_TRANSFER_IX_DISCM => Ok(Self::CancelAuthorityTransfer),
            CLOSE_BONDING_CURVE_VAULT_IX_DISCM => Ok(Self::CloseBondingCurveVault),
            COLLECT_METEORA_TRADING_FEES_IX_DISCM => Ok(Self::CollectMeteoraTradingFees),
            COLLECT_TRADING_FEES_IX_DISCM => Ok(Self::CollectTradingFees),
            COMPLETE_AUTHORITY_TRANSFER_IX_DISCM => Ok(Self::CompleteAuthorityTransfer),
            CREATE_METEORA_POOL_IX_DISCM => Ok(Self::CreateMeteoraPool),
            CREATE_RAYDIUM_POOL_IX_DISCM => Ok(Self::CreateRaydiumPool),
            CREATE_RAYDIUM_RANDOM_POOL_IX_DISCM => Ok(Self::CreateRaydiumRandomPool),
            CREATE_TOKEN_IX_DISCM => Ok(Self::CreateToken(CreateTokenIxArgs::deserialize(
                &mut reader,
            )?)),
            CREATE_TOKEN_FALLBACK_IX_DISCM => Ok(Self::CreateTokenFallback(
                CreateTokenFallbackIxArgs::deserialize(&mut reader)?,
            )),
            DEPLOY_BONDING_CURVE_IX_DISCM => Ok(Self::DeployBondingCurve(
                DeployBondingCurveIxArgs::deserialize(&mut reader)?,
            )),
            DEPLOY_BONDING_CURVE_FALLBACK_IX_DISCM => Ok(Self::DeployBondingCurveFallback(
                DeployBondingCurveFallbackIxArgs::deserialize(&mut reader)?,
            )),
            DEPOSIT_INTO_RAYDIUM_IX_DISCM => Ok(Self::DepositIntoRaydium(
                DepositIntoRaydiumIxArgs::deserialize(&mut reader)?,
            )),
            GRADUATE_IX_DISCM => Ok(Self::Graduate),
            INITIALIZE_IX_DISCM => Ok(Self::Initialize(InitializeIxArgs::deserialize(
                &mut reader,
            )?)),
            INITIATE_AUTHORITY_TRANSFER_IX_DISCM => Ok(Self::InitiateAuthorityTransfer(
                InitiateAuthorityTransferIxArgs::deserialize(&mut reader)?,
            )),
            LOCK_RAYDIUM_LIQUIDITY_IX_DISCM => Ok(Self::LockRaydiumLiquidity),
            REMOVE_OPERATORS_IX_DISCM => Ok(Self::RemoveOperators(
                RemoveOperatorsIxArgs::deserialize(&mut reader)?,
            )),
            SELL_TOKEN_IX_DISCM => Ok(Self::SellToken(SellTokenIxArgs::deserialize(&mut reader)?)),
            SPLIT_TRADING_FEES_IX_DISCM => Ok(Self::SplitTradingFees),
            SWAP_SOL_FOR_TOKENS_ON_RAYDIUM_IX_DISCM => Ok(Self::SwapSolForTokensOnRaydium(
                SwapSolForTokensOnRaydiumIxArgs::deserialize(&mut reader)?,
            )),
            SWAP_TOKENS_FOR_SOL_ON_RAYDIUM_IX_DISCM => Ok(Self::SwapTokensForSolOnRaydium(
                SwapTokensForSolOnRaydiumIxArgs::deserialize(&mut reader)?,
            )),
            TOGGLE_PAUSED_IX_DISCM => Ok(Self::TogglePaused),
            UPDATE_CONFIG_IX_DISCM => Ok(Self::UpdateConfig(UpdateConfigIxArgs::deserialize(
                &mut reader,
            )?)),
            _ => Err(std::io::Error::new(
                std::io::ErrorKind::Other,
                format!("discm {:?} not found", maybe_discm),
            )),
        }
    }
    pub fn serialize<W: std::io::Write>(&self, mut writer: W) -> std::io::Result<()> {
        match self {
            Self::AddOperators(args) => {
                writer.write_all(&ADD_OPERATORS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::BuyToken(args) => {
                writer.write_all(&BUY_TOKEN_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::CancelAuthorityTransfer => writer.write_all(&CANCEL_AUTHORITY_TRANSFER_IX_DISCM),
            Self::CloseBondingCurveVault => writer.write_all(&CLOSE_BONDING_CURVE_VAULT_IX_DISCM),
            Self::CollectMeteoraTradingFees => {
                writer.write_all(&COLLECT_METEORA_TRADING_FEES_IX_DISCM)
            }
            Self::CollectTradingFees => writer.write_all(&COLLECT_TRADING_FEES_IX_DISCM),
            Self::CompleteAuthorityTransfer => {
                writer.write_all(&COMPLETE_AUTHORITY_TRANSFER_IX_DISCM)
            }
            Self::CreateMeteoraPool => writer.write_all(&CREATE_METEORA_POOL_IX_DISCM),
            Self::CreateRaydiumPool => writer.write_all(&CREATE_RAYDIUM_POOL_IX_DISCM),
            Self::CreateRaydiumRandomPool => writer.write_all(&CREATE_RAYDIUM_RANDOM_POOL_IX_DISCM),
            Self::CreateToken(args) => {
                writer.write_all(&CREATE_TOKEN_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::CreateTokenFallback(args) => {
                writer.write_all(&CREATE_TOKEN_FALLBACK_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::DeployBondingCurve(args) => {
                writer.write_all(&DEPLOY_BONDING_CURVE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::DeployBondingCurveFallback(args) => {
                writer.write_all(&DEPLOY_BONDING_CURVE_FALLBACK_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::DepositIntoRaydium(args) => {
                writer.write_all(&DEPOSIT_INTO_RAYDIUM_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::Graduate => writer.write_all(&GRADUATE_IX_DISCM),
            Self::Initialize(args) => {
                writer.write_all(&INITIALIZE_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::InitiateAuthorityTransfer(args) => {
                writer.write_all(&INITIATE_AUTHORITY_TRANSFER_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::LockRaydiumLiquidity => writer.write_all(&LOCK_RAYDIUM_LIQUIDITY_IX_DISCM),
            Self::RemoveOperators(args) => {
                writer.write_all(&REMOVE_OPERATORS_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::SellToken(args) => {
                writer.write_all(&SELL_TOKEN_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::SplitTradingFees => writer.write_all(&SPLIT_TRADING_FEES_IX_DISCM),
            Self::SwapSolForTokensOnRaydium(args) => {
                writer.write_all(&SWAP_SOL_FOR_TOKENS_ON_RAYDIUM_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::SwapTokensForSolOnRaydium(args) => {
                writer.write_all(&SWAP_TOKENS_FOR_SOL_ON_RAYDIUM_IX_DISCM)?;
                args.serialize(&mut writer)
            }
            Self::TogglePaused => writer.write_all(&TOGGLE_PAUSED_IX_DISCM),
            Self::UpdateConfig(args) => {
                writer.write_all(&UPDATE_CONFIG_IX_DISCM)?;
                args.serialize(&mut writer)
            }
        }
    }
    pub fn try_to_vec(&self) -> std::io::Result<Vec<u8>> {
        let mut data = Vec::new();
        self.serialize(&mut data)?;
        Ok(data)
    }
}
