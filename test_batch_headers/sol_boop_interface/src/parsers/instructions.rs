//! This file was automatically generated by Solores
//! Solana IDL to Rust interface generator
//!
//! GitHub: https://github.com/cpkt9762/solores
//!
//! Generated on: 2025-08-06
//!
//! DO NOT EDIT - This file is auto-generated
//! Changes will be lost when regenerating from IDL

use crate::instructions::*;
pub const ADD_OPERATORS_IX_DISCM: [u8; 8] = [165u8, 199u8, 62u8, 214u8, 81u8, 54u8, 4u8, 150u8];
pub const BUY_TOKEN_IX_DISCM: [u8; 8] = [138u8, 127u8, 14u8, 91u8, 38u8, 87u8, 115u8, 105u8];
pub const CANCEL_AUTHORITY_TRANSFER_IX_DISCM: [u8; 8] =
    [94u8, 131u8, 125u8, 184u8, 183u8, 24u8, 125u8, 229u8];
pub const CLOSE_BONDING_CURVE_VAULT_IX_DISCM: [u8; 8] =
    [189u8, 71u8, 189u8, 239u8, 113u8, 66u8, 59u8, 189u8];
pub const COLLECT_METEORA_TRADING_FEES_IX_DISCM: [u8; 8] =
    [249u8, 95u8, 126u8, 91u8, 81u8, 162u8, 83u8, 250u8];
pub const COLLECT_TRADING_FEES_IX_DISCM: [u8; 8] =
    [189u8, 38u8, 205u8, 234u8, 81u8, 77u8, 25u8, 1u8];
pub const COMPLETE_AUTHORITY_TRANSFER_IX_DISCM: [u8; 8] =
    [81u8, 233u8, 91u8, 132u8, 175u8, 31u8, 151u8, 141u8];
pub const CREATE_METEORA_POOL_IX_DISCM: [u8; 8] =
    [246u8, 254u8, 33u8, 37u8, 225u8, 176u8, 41u8, 232u8];
pub const CREATE_RAYDIUM_POOL_IX_DISCM: [u8; 8] =
    [65u8, 45u8, 119u8, 77u8, 204u8, 178u8, 84u8, 2u8];
pub const CREATE_RAYDIUM_RANDOM_POOL_IX_DISCM: [u8; 8] =
    [78u8, 44u8, 173u8, 29u8, 132u8, 180u8, 4u8, 172u8];
pub const CREATE_TOKEN_IX_DISCM: [u8; 8] = [84u8, 52u8, 204u8, 228u8, 24u8, 140u8, 234u8, 75u8];
pub const CREATE_TOKEN_FALLBACK_IX_DISCM: [u8; 8] =
    [253u8, 184u8, 126u8, 199u8, 235u8, 232u8, 172u8, 162u8];
pub const DEPLOY_BONDING_CURVE_IX_DISCM: [u8; 8] =
    [180u8, 89u8, 199u8, 76u8, 168u8, 236u8, 217u8, 138u8];
pub const DEPLOY_BONDING_CURVE_FALLBACK_IX_DISCM: [u8; 8] =
    [53u8, 230u8, 172u8, 84u8, 77u8, 174u8, 22u8, 61u8];
pub const DEPOSIT_INTO_RAYDIUM_IX_DISCM: [u8; 8] =
    [168u8, 89u8, 99u8, 30u8, 117u8, 49u8, 88u8, 224u8];
pub const GRADUATE_IX_DISCM: [u8; 8] = [45u8, 235u8, 225u8, 181u8, 17u8, 218u8, 64u8, 130u8];
pub const INITIALIZE_IX_DISCM: [u8; 8] = [175u8, 175u8, 109u8, 31u8, 13u8, 152u8, 155u8, 237u8];
pub const INITIATE_AUTHORITY_TRANSFER_IX_DISCM: [u8; 8] =
    [210u8, 43u8, 101u8, 215u8, 119u8, 140u8, 106u8, 218u8];
pub const LOCK_RAYDIUM_LIQUIDITY_IX_DISCM: [u8; 8] =
    [173u8, 255u8, 148u8, 6u8, 122u8, 99u8, 140u8, 22u8];
pub const REMOVE_OPERATORS_IX_DISCM: [u8; 8] = [42u8, 20u8, 89u8, 83u8, 222u8, 37u8, 4u8, 109u8];
pub const SELL_TOKEN_IX_DISCM: [u8; 8] = [109u8, 61u8, 40u8, 187u8, 230u8, 176u8, 135u8, 174u8];
pub const SPLIT_TRADING_FEES_IX_DISCM: [u8; 8] =
    [96u8, 126u8, 225u8, 47u8, 185u8, 213u8, 50u8, 58u8];
pub const SWAP_SOL_FOR_TOKENS_ON_RAYDIUM_IX_DISCM: [u8; 8] =
    [107u8, 248u8, 131u8, 239u8, 152u8, 234u8, 54u8, 35u8];
pub const SWAP_TOKENS_FOR_SOL_ON_RAYDIUM_IX_DISCM: [u8; 8] =
    [216u8, 172u8, 130u8, 148u8, 34u8, 98u8, 215u8, 163u8];
pub const TOGGLE_PAUSED_IX_DISCM: [u8; 8] = [54u8, 83u8, 147u8, 198u8, 123u8, 97u8, 218u8, 72u8];
pub const UPDATE_CONFIG_IX_DISCM: [u8; 8] = [29u8, 158u8, 252u8, 191u8, 10u8, 83u8, 219u8, 99u8];
/// Program instruction types
#[derive(Clone, Debug, PartialEq)]
pub enum BoopInstruction {
    AddOperators(AddOperatorsIxArgs),
    BuyToken(BuyTokenIxArgs),
    CancelAuthorityTransfer,
    CloseBondingCurveVault,
    CollectMeteoraTradingFees,
    CollectTradingFees,
    CompleteAuthorityTransfer,
    CreateMeteoraPool,
    CreateRaydiumPool,
    CreateRaydiumRandomPool,
    CreateToken(CreateTokenIxArgs),
    CreateTokenFallback(CreateTokenFallbackIxArgs),
    DeployBondingCurve(DeployBondingCurveIxArgs),
    DeployBondingCurveFallback(DeployBondingCurveFallbackIxArgs),
    DepositIntoRaydium(DepositIntoRaydiumIxArgs),
    Graduate,
    Initialize(InitializeIxArgs),
    InitiateAuthorityTransfer(InitiateAuthorityTransferIxArgs),
    LockRaydiumLiquidity,
    RemoveOperators(RemoveOperatorsIxArgs),
    SellToken(SellTokenIxArgs),
    SplitTradingFees,
    SwapSolForTokensOnRaydium(SwapSolForTokensOnRaydiumIxArgs),
    SwapTokensForSolOnRaydium(SwapTokensForSolOnRaydiumIxArgs),
    TogglePaused,
    UpdateConfig(UpdateConfigIxArgs),
}
/// Parse instruction data based on 8-byte discriminator (Anchor contracts)
pub fn parse_instruction(data: &[u8]) -> Result<BoopInstruction, std::io::Error> {
    if data.len() < 8 {
        return Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Instruction data too short for discriminator",
        ));
    }
    let discriminator: [u8; 8] = data[0..8].try_into().map_err(|_| {
        std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            "Failed to read discriminator",
        )
    })?;
    let mut ix_data = &data[8..];
    match discriminator {
        ADD_OPERATORS_IX_DISCM => {
            let args = AddOperatorsIxArgs::deserialize(&mut ix_data)?;
            Ok(BoopInstruction::AddOperators(args))
        }
        BUY_TOKEN_IX_DISCM => {
            let args = BuyTokenIxArgs::deserialize(&mut ix_data)?;
            Ok(BoopInstruction::BuyToken(args))
        }
        CANCEL_AUTHORITY_TRANSFER_IX_DISCM => Ok(BoopInstruction::CancelAuthorityTransfer),
        CLOSE_BONDING_CURVE_VAULT_IX_DISCM => Ok(BoopInstruction::CloseBondingCurveVault),
        COLLECT_METEORA_TRADING_FEES_IX_DISCM => Ok(BoopInstruction::CollectMeteoraTradingFees),
        COLLECT_TRADING_FEES_IX_DISCM => Ok(BoopInstruction::CollectTradingFees),
        COMPLETE_AUTHORITY_TRANSFER_IX_DISCM => Ok(BoopInstruction::CompleteAuthorityTransfer),
        CREATE_METEORA_POOL_IX_DISCM => Ok(BoopInstruction::CreateMeteoraPool),
        CREATE_RAYDIUM_POOL_IX_DISCM => Ok(BoopInstruction::CreateRaydiumPool),
        CREATE_RAYDIUM_RANDOM_POOL_IX_DISCM => Ok(BoopInstruction::CreateRaydiumRandomPool),
        CREATE_TOKEN_IX_DISCM => {
            let args = CreateTokenIxArgs::deserialize(&mut ix_data)?;
            Ok(BoopInstruction::CreateToken(args))
        }
        CREATE_TOKEN_FALLBACK_IX_DISCM => {
            let args = CreateTokenFallbackIxArgs::deserialize(&mut ix_data)?;
            Ok(BoopInstruction::CreateTokenFallback(args))
        }
        DEPLOY_BONDING_CURVE_IX_DISCM => {
            let args = DeployBondingCurveIxArgs::deserialize(&mut ix_data)?;
            Ok(BoopInstruction::DeployBondingCurve(args))
        }
        DEPLOY_BONDING_CURVE_FALLBACK_IX_DISCM => {
            let args = DeployBondingCurveFallbackIxArgs::deserialize(&mut ix_data)?;
            Ok(BoopInstruction::DeployBondingCurveFallback(args))
        }
        DEPOSIT_INTO_RAYDIUM_IX_DISCM => {
            let args = DepositIntoRaydiumIxArgs::deserialize(&mut ix_data)?;
            Ok(BoopInstruction::DepositIntoRaydium(args))
        }
        GRADUATE_IX_DISCM => Ok(BoopInstruction::Graduate),
        INITIALIZE_IX_DISCM => {
            let args = InitializeIxArgs::deserialize(&mut ix_data)?;
            Ok(BoopInstruction::Initialize(args))
        }
        INITIATE_AUTHORITY_TRANSFER_IX_DISCM => {
            let args = InitiateAuthorityTransferIxArgs::deserialize(&mut ix_data)?;
            Ok(BoopInstruction::InitiateAuthorityTransfer(args))
        }
        LOCK_RAYDIUM_LIQUIDITY_IX_DISCM => Ok(BoopInstruction::LockRaydiumLiquidity),
        REMOVE_OPERATORS_IX_DISCM => {
            let args = RemoveOperatorsIxArgs::deserialize(&mut ix_data)?;
            Ok(BoopInstruction::RemoveOperators(args))
        }
        SELL_TOKEN_IX_DISCM => {
            let args = SellTokenIxArgs::deserialize(&mut ix_data)?;
            Ok(BoopInstruction::SellToken(args))
        }
        SPLIT_TRADING_FEES_IX_DISCM => Ok(BoopInstruction::SplitTradingFees),
        SWAP_SOL_FOR_TOKENS_ON_RAYDIUM_IX_DISCM => {
            let args = SwapSolForTokensOnRaydiumIxArgs::deserialize(&mut ix_data)?;
            Ok(BoopInstruction::SwapSolForTokensOnRaydium(args))
        }
        SWAP_TOKENS_FOR_SOL_ON_RAYDIUM_IX_DISCM => {
            let args = SwapTokensForSolOnRaydiumIxArgs::deserialize(&mut ix_data)?;
            Ok(BoopInstruction::SwapTokensForSolOnRaydium(args))
        }
        TOGGLE_PAUSED_IX_DISCM => Ok(BoopInstruction::TogglePaused),
        UPDATE_CONFIG_IX_DISCM => {
            let args = UpdateConfigIxArgs::deserialize(&mut ix_data)?;
            Ok(BoopInstruction::UpdateConfig(args))
        }
        _ => Err(std::io::Error::new(
            std::io::ErrorKind::InvalidData,
            format!("Unknown instruction discriminator: {:?}", discriminator),
        )),
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_add_operators_consistency() {
        let test_args = AddOperatorsIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&ADD_OPERATORS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(BoopInstruction::AddOperators(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(AddOperators)
                );
            }
        }
    }
    #[test]
    fn test_buy_token_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = BuyTokenIxArgs {
            buy_amount: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&BUY_TOKEN_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(BoopInstruction::BuyToken(args)) => {
                assert_eq!(
                    args.buy_amount, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(BuyToken)
                );
            }
        }
    }
    #[test]
    fn test_cancel_authority_transfer_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CANCEL_AUTHORITY_TRANSFER_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            BoopInstruction::CancelAuthorityTransfer => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_close_bonding_curve_vault_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CLOSE_BONDING_CURVE_VAULT_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            BoopInstruction::CloseBondingCurveVault => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_collect_meteora_trading_fees_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&COLLECT_METEORA_TRADING_FEES_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            BoopInstruction::CollectMeteoraTradingFees => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_collect_trading_fees_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&COLLECT_TRADING_FEES_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            BoopInstruction::CollectTradingFees => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_complete_authority_transfer_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&COMPLETE_AUTHORITY_TRANSFER_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            BoopInstruction::CompleteAuthorityTransfer => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_create_meteora_pool_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATE_METEORA_POOL_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            BoopInstruction::CreateMeteoraPool => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_create_raydium_pool_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATE_RAYDIUM_POOL_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            BoopInstruction::CreateRaydiumPool => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_create_raydium_random_pool_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATE_RAYDIUM_RANDOM_POOL_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            BoopInstruction::CreateRaydiumRandomPool => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_create_token_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = CreateTokenIxArgs {
            salt: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATE_TOKEN_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(BoopInstruction::CreateToken(args)) => {
                assert_eq!(
                    args.salt, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CreateToken)
                );
            }
        }
    }
    #[test]
    fn test_create_token_fallback_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = CreateTokenFallbackIxArgs {
            salt: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&CREATE_TOKEN_FALLBACK_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(BoopInstruction::CreateTokenFallback(args)) => {
                assert_eq!(
                    args.salt, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(CreateTokenFallback)
                );
            }
        }
    }
    #[test]
    fn test_deploy_bonding_curve_consistency() {
        let test_args = DeployBondingCurveIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&DEPLOY_BONDING_CURVE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(BoopInstruction::DeployBondingCurve(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(DeployBondingCurve)
                );
            }
        }
    }
    #[test]
    fn test_deploy_bonding_curve_fallback_consistency() {
        let test_args = DeployBondingCurveFallbackIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&DEPLOY_BONDING_CURVE_FALLBACK_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(BoopInstruction::DeployBondingCurveFallback(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(DeployBondingCurveFallback)
                );
            }
        }
    }
    #[test]
    fn test_deposit_into_raydium_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = DepositIntoRaydiumIxArgs {
            lp_token_amount: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&DEPOSIT_INTO_RAYDIUM_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(BoopInstruction::DepositIntoRaydium(args)) => {
                assert_eq!(
                    args.lp_token_amount, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(DepositIntoRaydium)
                );
            }
        }
    }
    #[test]
    fn test_graduate_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&GRADUATE_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            BoopInstruction::Graduate => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_initialize_consistency() {
        let test_args = InitializeIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIALIZE_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(BoopInstruction::Initialize(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(Initialize)
                );
            }
        }
    }
    #[test]
    fn test_initiate_authority_transfer_consistency() {
        let test_args = InitiateAuthorityTransferIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&INITIATE_AUTHORITY_TRANSFER_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(BoopInstruction::InitiateAuthorityTransfer(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(InitiateAuthorityTransfer)
                );
            }
        }
    }
    #[test]
    fn test_lock_raydium_liquidity_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&LOCK_RAYDIUM_LIQUIDITY_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            BoopInstruction::LockRaydiumLiquidity => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_remove_operators_consistency() {
        let test_args = RemoveOperatorsIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&REMOVE_OPERATORS_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(BoopInstruction::RemoveOperators(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(RemoveOperators)
                );
            }
        }
    }
    #[test]
    fn test_sell_token_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = SellTokenIxArgs {
            sell_amount: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SELL_TOKEN_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(BoopInstruction::SellToken(args)) => {
                assert_eq!(
                    args.sell_amount, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SellToken)
                );
            }
        }
    }
    #[test]
    fn test_split_trading_fees_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SPLIT_TRADING_FEES_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            BoopInstruction::SplitTradingFees => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_swap_sol_for_tokens_on_raydium_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = SwapSolForTokensOnRaydiumIxArgs {
            amount_in: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SWAP_SOL_FOR_TOKENS_ON_RAYDIUM_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(BoopInstruction::SwapSolForTokensOnRaydium(args)) => {
                assert_eq!(
                    args.amount_in, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SwapSolForTokensOnRaydium)
                );
            }
        }
    }
    #[test]
    fn test_swap_tokens_for_sol_on_raydium_consistency() {
        let expected_first_arg = 1000u64;
        let test_args = SwapTokensForSolOnRaydiumIxArgs {
            amount_in: expected_first_arg,
            ..Default::default()
        };
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&SWAP_TOKENS_FOR_SOL_ON_RAYDIUM_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(BoopInstruction::SwapTokensForSolOnRaydium(args)) => {
                assert_eq!(
                    args.amount_in, expected_first_arg,
                    "First argument value should match expected value"
                );
            }
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(SwapTokensForSolOnRaydium)
                );
            }
        }
    }
    #[test]
    fn test_toggle_paused_consistency() {
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&TOGGLE_PAUSED_IX_DISCM);
        let parsed = parse_instruction(&test_data).expect("Failed to parse instruction");
        match parsed {
            BoopInstruction::TogglePaused => {}
            _ => panic!("Parsed instruction has wrong type"),
        }
    }
    #[test]
    fn test_update_config_consistency() {
        let test_args = UpdateConfigIxArgs::default();
        let mut test_data = Vec::new();
        test_data.extend_from_slice(&UPDATE_CONFIG_IX_DISCM);
        test_data.extend_from_slice(&test_args.try_to_vec().unwrap());
        match parse_instruction(&test_data) {
            Ok(BoopInstruction::UpdateConfig(_)) => {}
            Ok(_) => panic!("Discriminator matched wrong instruction type"),
            Err(e) => {
                let error_msg = e.to_string();
                assert!(
                    !error_msg.contains("Unknown instruction discriminator"),
                    "Should recognize discriminator for {}",
                    stringify!(UpdateConfig)
                );
            }
        }
    }
    #[test]
    fn test_discriminator_recognition() {
        let test_args = AddOperatorsIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(AddOperatorsIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &ADD_OPERATORS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::AddOperators(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, ADD_OPERATORS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(AddOperators))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(AddOperators),
                    e
                );
            }
        }
        let test_args = BuyTokenIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(BuyTokenIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &BUY_TOKEN_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::BuyToken(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, BUY_TOKEN_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(BuyToken)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(BuyToken),
                    e
                );
            }
        }
        let test_data = CANCEL_AUTHORITY_TRANSFER_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::CancelAuthorityTransfer => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CancelAuthorityTransfer)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CancelAuthorityTransfer),
                    e
                );
            }
        }
        let test_data = CLOSE_BONDING_CURVE_VAULT_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::CloseBondingCurveVault => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CloseBondingCurveVault)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CloseBondingCurveVault),
                    e
                );
            }
        }
        let test_data = COLLECT_METEORA_TRADING_FEES_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::CollectMeteoraTradingFees => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CollectMeteoraTradingFees)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CollectMeteoraTradingFees),
                    e
                );
            }
        }
        let test_data = COLLECT_TRADING_FEES_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::CollectTradingFees => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CollectTradingFees)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CollectTradingFees),
                    e
                );
            }
        }
        let test_data = COMPLETE_AUTHORITY_TRANSFER_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::CompleteAuthorityTransfer => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CompleteAuthorityTransfer)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CompleteAuthorityTransfer),
                    e
                );
            }
        }
        let test_data = CREATE_METEORA_POOL_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::CreateMeteoraPool => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CreateMeteoraPool)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CreateMeteoraPool),
                    e
                );
            }
        }
        let test_data = CREATE_RAYDIUM_POOL_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::CreateRaydiumPool => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CreateRaydiumPool)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CreateRaydiumPool),
                    e
                );
            }
        }
        let test_data = CREATE_RAYDIUM_RANDOM_POOL_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::CreateRaydiumRandomPool => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CreateRaydiumRandomPool)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CreateRaydiumRandomPool),
                    e
                );
            }
        }
        let test_args = CreateTokenIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CreateTokenIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CREATE_TOKEN_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::CreateToken(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CREATE_TOKEN_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(CreateToken))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CreateToken),
                    e
                );
            }
        }
        let test_args = CreateTokenFallbackIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(CreateTokenFallbackIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &CREATE_TOKEN_FALLBACK_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::CreateTokenFallback(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, CREATE_TOKEN_FALLBACK_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(CreateTokenFallback)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(CreateTokenFallback),
                    e
                );
            }
        }
        let test_args = DeployBondingCurveIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(DeployBondingCurveIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &DEPLOY_BONDING_CURVE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::DeployBondingCurve(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, DEPLOY_BONDING_CURVE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(DeployBondingCurve)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(DeployBondingCurve),
                    e
                );
            }
        }
        let test_args = DeployBondingCurveFallbackIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(DeployBondingCurveFallbackIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &DEPLOY_BONDING_CURVE_FALLBACK_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::DeployBondingCurveFallback(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, DEPLOY_BONDING_CURVE_FALLBACK_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(DeployBondingCurveFallback)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(DeployBondingCurveFallback),
                    e
                );
            }
        }
        let test_args = DepositIntoRaydiumIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(DepositIntoRaydiumIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &DEPOSIT_INTO_RAYDIUM_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::DepositIntoRaydium(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, DEPOSIT_INTO_RAYDIUM_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(DepositIntoRaydium)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(DepositIntoRaydium),
                    e
                );
            }
        }
        let test_data = GRADUATE_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::Graduate => {}
                _ => panic!("Parsed instruction should be {}", stringify!(Graduate)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Graduate),
                    e
                );
            }
        }
        let test_args = InitializeIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitializeIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIALIZE_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::Initialize(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIALIZE_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(Initialize))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(Initialize),
                    e
                );
            }
        }
        let test_args = InitiateAuthorityTransferIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(InitiateAuthorityTransferIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &INITIATE_AUTHORITY_TRANSFER_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::InitiateAuthorityTransfer(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, INITIATE_AUTHORITY_TRANSFER_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(InitiateAuthorityTransfer)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(InitiateAuthorityTransfer),
                    e
                );
            }
        }
        let test_data = LOCK_RAYDIUM_LIQUIDITY_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::LockRaydiumLiquidity => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(LockRaydiumLiquidity)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(LockRaydiumLiquidity),
                    e
                );
            }
        }
        let test_args = RemoveOperatorsIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(RemoveOperatorsIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &REMOVE_OPERATORS_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::RemoveOperators(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, REMOVE_OPERATORS_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(RemoveOperators)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(RemoveOperators),
                    e
                );
            }
        }
        let test_args = SellTokenIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SellTokenIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SELL_TOKEN_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::SellToken(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SELL_TOKEN_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => panic!("Parsed instruction should be {}", stringify!(SellToken)),
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SellToken),
                    e
                );
            }
        }
        let test_data = SPLIT_TRADING_FEES_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::SplitTradingFees => {}
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SplitTradingFees)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SplitTradingFees),
                    e
                );
            }
        }
        let test_args = SwapSolForTokensOnRaydiumIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SwapSolForTokensOnRaydiumIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SWAP_SOL_FOR_TOKENS_ON_RAYDIUM_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::SwapSolForTokensOnRaydium(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SWAP_SOL_FOR_TOKENS_ON_RAYDIUM_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SwapSolForTokensOnRaydium)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SwapSolForTokensOnRaydium),
                    e
                );
            }
        }
        let test_args = SwapTokensForSolOnRaydiumIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(SwapTokensForSolOnRaydiumIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &SWAP_TOKENS_FOR_SOL_ON_RAYDIUM_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::SwapTokensForSolOnRaydium(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, SWAP_TOKENS_FOR_SOL_ON_RAYDIUM_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!(
                        "Parsed instruction should be {}",
                        stringify!(SwapTokensForSolOnRaydium)
                    )
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(SwapTokensForSolOnRaydium),
                    e
                );
            }
        }
        let test_data = TOGGLE_PAUSED_IX_DISCM.to_vec();
        assert_eq!(
            test_data.len(),
            8,
            "Test data should be exactly 8 bytes for discriminator-only instruction"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::TogglePaused => {}
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(TogglePaused))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(TogglePaused),
                    e
                );
            }
        }
        let test_args = UpdateConfigIxArgs::default();
        let test_data = test_args.try_to_vec().unwrap();
        let expected_size = std::mem::size_of::<[u8; 8]>();
        assert!(
            test_data.len() >= expected_size,
            "Test data length should be at least {} bytes for {}",
            expected_size,
            stringify!(UpdateConfigIxArgs)
        );
        assert_eq!(
            &test_data[0..8],
            &UPDATE_CONFIG_IX_DISCM,
            "Discriminator should match expected value"
        );
        let result = parse_instruction(&test_data);
        match result {
            Ok(instruction) => match instruction {
                BoopInstruction::UpdateConfig(parsed_args) => {
                    assert_eq!(
                        parsed_args.discriminator, UPDATE_CONFIG_IX_DISCM,
                        "Parsed discriminator should match expected"
                    );
                }
                _ => {
                    panic!("Parsed instruction should be {}", stringify!(UpdateConfig))
                }
            },
            Err(e) => {
                panic!(
                    "Should successfully parse instruction {}: {}",
                    stringify!(UpdateConfig),
                    e
                );
            }
        }
    }
    #[test]
    fn test_invalid_discriminator() {
        let invalid_data = vec![255u8; 40];
        let result = parse_instruction(&invalid_data);
        assert!(result.is_err(), "Should fail with invalid discriminator");
    }
    #[test]
    fn test_insufficient_data() {
        let short_data = vec![1u8; 4];
        let result = parse_instruction(&short_data);
        assert!(result.is_err(), "Should fail with insufficient data");
    }
}
