//! {{ crate_name }} Accounts
//! Anchor-style account structures

use borsh::{BorshDeserialize, BorshSerialize};
use solana_program::pubkey::Pubkey;
{%- for feature in features %}
{%- if feature == "serde" %}
use serde::{Deserialize, Serialize};
{%- endif %}
{%- endfor %}

{%- for account in accounts %}

{%- if account.docs %}
/// {{ account.docs }}
{%- endif %}
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
{%- for feature in features %}
{%- if feature == "serde" %}
#[derive(Deserialize, Serialize)]
{%- endif %}
{%- endfor %}
pub struct {{ account.name }} {
    {%- for field in account.fields %}
    {%- if field.docs %}
    /// {{ field.docs }}
    {%- endif %}
    {%- if field.is_pubkey %}
    #[cfg_attr(feature = "serde", serde(with = "pubkey_serde"))]
    {%- endif %}
    pub {{ field.name }}: {{ field.rust_type }},
    {%- endfor %}
}

impl {{ account.name }} {
    {%- if account.discriminator %}
    /// Account discriminator
    pub const DISCRIMINATOR: [u8; 8] = {{ account.discriminator }};
    {%- endif %}
    
    /// Create new account
    pub fn new(
        {%- for field in account.fields %}
        {{ field.name }}: {{ field.rust_type }},
        {%- endfor %}
    ) -> Self {
        Self {
            {%- for field in account.fields %}
            {{ field.name }},
            {%- endfor %}
        }
    }
    
    /// Deserialize from bytes
    pub fn from_bytes(data: &[u8]) -> Result<Self, std::io::Error> {
        {%- if account.discriminator %}
        if data.len() < 8 {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Insufficient data for discriminator"
            ));
        }
        
        let discriminator = &data[0..8];
        if discriminator != Self::DISCRIMINATOR {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Invalid discriminator"
            ));
        }
        
        Self::try_from_slice(&data[8..])
        {%- else %}
        Self::try_from_slice(data)
        {%- endif %}
    }
    
    /// Serialize to bytes
    pub fn try_to_vec(&self) -> Result<Vec<u8>, std::io::Error> {
        {%- if account.discriminator %}
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(self)?);
        Ok(data)
        {%- else %}
        borsh::to_vec(self)
        {%- endif %}
    }
    
    {%- for feature in features %}
    {%- if feature == "serde" %}
    /// Serialize to JSON
    pub fn to_json(&self) -> String {
        serde_json::to_string(self).unwrap_or_default()
    }
    {%- endif %}
    {%- endfor %}
}

{%- endfor %}

{%- for feature in features %}
{%- if feature == "serde" %}
/// Pubkey serde helpers
pub mod pubkey_serde {
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use solana_program::pubkey::Pubkey;
    
    pub fn serialize<S>(pubkey: &Pubkey, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        pubkey.to_string().serialize(serializer)
    }
    
    pub fn deserialize<'de, D>(deserializer: D) -> Result<Pubkey, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}
{%- endif %}
{%- endfor %}