//! {{ crate_name }} Parsers
//! Anchor-style instruction and account parsers

use crate::*;

/// Parse instruction from instruction data and accounts
pub fn parse_instruction(
    instruction_data: &[u8],
    accounts: &[solana_program::pubkey::Pubkey],
) -> Result<Box<dyn std::fmt::Debug>, Box<dyn std::error::Error>> {
    if instruction_data.len() < 8 {
        return Err("Insufficient instruction data".into());
    }
    
    let discriminator = &instruction_data[0..8];
    
    {%- for instruction in instructions %}
    if discriminator == {{ instruction.name }}IxData::DISCRIMINATOR {
        let ix_data = {{ instruction.name }}IxData::from_bytes(instruction_data)?;
        {%- if instruction.accounts %}
        if accounts.len() < {{ instruction.accounts|length }} {
            return Err("Insufficient accounts for {{ instruction.name }}".into());
        }
        let keys = {{ instruction.name }}Keys::new(
            {%- for account in instruction.accounts %}
            accounts[{{ loop.index0 }}],
            {%- endfor %}
        );
        return Ok(Box::new((ix_data, keys)));
        {%- else %}
        return Ok(Box::new(ix_data));
        {%- endif %}
    }
    {%- endfor %}
    
    Err("Unknown instruction discriminator".into())
}

{%- if accounts %}
/// Parse account from account data
pub fn parse_account(account_data: &[u8]) -> Result<Box<dyn std::fmt::Debug>, Box<dyn std::error::Error>> {
    if account_data.len() < 8 {
        return Err("Insufficient account data".into());
    }
    
    let discriminator = &account_data[0..8];
    
    {%- for account in accounts %}
    {%- if account.discriminator %}
    if discriminator == {{ account.name }}::DISCRIMINATOR {
        let account = {{ account.name }}::from_bytes(account_data)?;
        return Ok(Box::new(account));
    }
    {%- endif %}
    {%- endfor %}
    
    Err("Unknown account discriminator".into())
}
{%- endif %}