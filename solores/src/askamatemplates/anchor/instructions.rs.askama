//! {{ crate_name }} Instructions
//! Anchor-style instructions with 8-byte discriminators

{% include "common/imports.askama" %}

{%- for instruction in instructions %}

{%- if instruction.docs %}
/// {{ instruction.docs }}
{%- endif %}
#[derive(BorshDeserialize, BorshSerialize, Clone, Debug, PartialEq)]
{%- for feature in features %}
{%- if feature == "serde" %}
#[derive(Deserialize, Serialize)]
{%- endif %}
{%- endfor %}
pub struct {{ instruction.name }}IxData {
    {%- for field in instruction.fields %}
    {%- if field.docs %}
    /// {{ field.docs }}
    {%- endif %}
    {%- if field.is_pubkey %}
    #[cfg_attr(feature = "serde", serde(with = "pubkey_serde"))]
    {%- endif %}
    pub {{ field.name }}: {{ field.rust_type }},
    {%- endfor %}
}

impl {{ instruction.name }}IxData {
    /// Instruction discriminator
    pub const DISCRIMINATOR: [u8; 8] = {{ instruction.discriminator }};
    
    /// Create new instruction data
    pub fn new(
        {%- for field in instruction.fields %}
        {{ field.name }}: {{ field.rust_type }},
        {%- endfor %}
    ) -> Self {
        Self {
            {%- for field in instruction.fields %}
            {{ field.name }},
            {%- endfor %}
        }
    }
    
    /// Deserialize from bytes
    pub fn from_bytes(data: &[u8]) -> Result<Self, std::io::Error> {
        if data.len() < 8 {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Insufficient data for discriminator"
            ));
        }
        
        let discriminator = &data[0..8];
        if discriminator != Self::DISCRIMINATOR {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Invalid discriminator"
            ));
        }
        
        Self::try_from_slice(&data[8..])
    }
    
    /// Serialize to bytes with discriminator
    pub fn try_to_vec(&self) -> Result<Vec<u8>, std::io::Error> {
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(self)?);
        Ok(data)
    }
    
    {%- for feature in features %}
    {%- if feature == "serde" %}
    /// Serialize to JSON
    pub fn to_json(&self) -> String {
        serde_json::to_string(self).unwrap_or_default()
    }
    {%- endif %}
    {%- endfor %}
}

{%- if instruction.accounts %}
/// {{ instruction.name }} accounts
#[derive(Clone, Debug, PartialEq)]
{%- for feature in features %}
{%- if feature == "serde" %}
#[derive(Deserialize, Serialize)]
{%- endif %}
{%- endfor %}
pub struct {{ instruction.name }}Keys {
    {%- for account in instruction.accounts %}
    {%- if account.docs %}
    /// {{ account.docs }}
    {%- endif %}
    {%- for feature in features %}
    {%- if feature == "serde" %}
    #[serde(with = "pubkey_serde")]
    {%- endif %}
    {%- endfor %}
    pub {{ account.name }}: Pubkey,
    {%- endfor %}
}

impl {{ instruction.name }}Keys {
    /// Create new keys
    pub fn new(
        {%- for account in instruction.accounts %}
        {{ account.name }}: Pubkey,
        {%- endfor %}
    ) -> Self {
        Self {
            {%- for account in instruction.accounts %}
            {{ account.name }},
            {%- endfor %}
        }
    }
    
    /// Convert to account metas
    pub fn to_account_metas(&self) -> Vec<solana_program::instruction::AccountMeta> {
        vec![
            {%- for account in instruction.accounts %}
            solana_program::instruction::AccountMeta {
                pubkey: self.{{ account.name }},
                is_signer: {{ account.is_signer }},
                is_writable: {{ account.is_mut }},
            },
            {%- endfor %}
        ]
    }
    
    /// Convert to pubkey vector  
    pub fn to_vec(&self) -> Vec<Pubkey> {
        vec![
            {%- for account in instruction.accounts %}
            self.{{ account.name }},
            {%- endfor %}
        ]
    }
    
    {%- for feature in features %}
    {%- if feature == "serde" %}
    /// Serialize to JSON
    pub fn to_json(&self) -> String {
        serde_json::to_string(self).unwrap_or_default()
    }
    {%- endif %}
    {%- endfor %}
}
{%- endif %}

{%- endfor %}

{# 包含公共serde helpers #}
{% include "common/serde_helpers.askama" %}