//! {{ crate_name }} Event Parsers
//! Non-Anchor style event parsing (length-based matching)

{% if events and events|length > 0 %}
use crate::errors::EventParseError;

/// Program event types
#[derive(Clone, Debug)]
pub enum ProgramEvent {
    {% for event in events %}
    {% if event.docs %}
    {{ event.docs | multiline_docs }}
    {% endif %}
    {{ event.name }}(crate::events::{{ event.name }}),
    {% endfor %}
}

impl ProgramEvent {
    /// Parse event from raw bytes using length-based matching
    pub fn try_parse(data: &[u8]) -> std::result::Result<Self, EventParseError> {
        if data.is_empty() {
            return Err(EventParseError::DataTooShort { expected: 1, found: 0 });
        }
        
        // NonAnchor events typically don't have discriminators
        // Try to parse as each event type based on data length or structure
        {% for event in events %}
        match crate::events::{{ event.name }}::from_bytes(data) {
            Ok(event) => return Ok(ProgramEvent::{{ event.name }}(event)),
            Err(EventParseError::DataTooShort { .. }) => {
                // Data too short, try next event type
            }
            Err(EventParseError::IncorrectLength { .. }) => {
                // Incorrect length, try next event type
            }
            Err(e) => {
                // Other errors should not continue to next event type
                return Err(e);
            }
        }
        {% endfor %}
        
        Err(EventParseError::DeserializationFailed(
            "Unable to parse data into any known event type".to_string()
        ))
    }

    /// Get parser identifier (static method)
    pub fn id() -> std::borrow::Cow<'static, str> {
        "{{ crate_name }}::EventParser".into()
    }
}


{% if has_serde %}
/// Parse event from JSON string (requires "serde" feature)
#[cfg(feature = "serde")]
pub fn parse_event_from_json(json: &str) -> std::result::Result<ProgramEvent, serde_json::Error> {
    // For JSON parsing, we try to deserialize as each event type
    let value: serde_json::Value = serde_json::from_str(json)?;
    
    {% for event in events %}
    if let Ok(event) = serde_json::from_value::<crate::events::{{ event.name }}>(value.clone()) {
        return Ok(ProgramEvent::{{ event.name }}(event));
    }
    {% endfor %}
    
    Err(serde_json::Error::custom("Unable to parse JSON into any known event type"))
}
{% endif %}
{% else %}
//! No events defined in this program
use crate::errors::EventParseError;

/// Program event types (empty)
#[derive(Clone, Debug)]
pub enum ProgramEvent {
    // No events defined in this program
}

impl ProgramEvent {
    /// Parse event from raw bytes (always fails for empty events)
    pub fn try_parse(_data: &[u8]) -> std::result::Result<Self, EventParseError> {
        Err(EventParseError::DeserializationFailed(
            "{{ crate_name }}::No events defined in this program".to_string()
        ))
    }

    /// Get parser identifier (static method)
    pub fn id() -> std::borrow::Cow<'static, str> {
        "{{ crate_name }}::EventParser".into()
    }
}

{% if has_serde %}
/// Parse event from JSON string (requires "serde" feature) - always fails for empty events
#[cfg(feature = "serde")]
pub fn parse_event_from_json(_json: &str) -> std::result::Result<ProgramEvent, serde_json::Error> {
    Err(serde_json::Error::custom("{{ crate_name }}::No events defined in this program"))
}
{% endif %}
{% endif %}