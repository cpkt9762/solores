//! {{ instruction.name }} Instruction
//! Single instruction definition for {{ crate_name }}

{% set instruction_upper = instruction.name | upper %}
pub const {{ instruction_upper }}_IX_DISCM: [u8; 8] = {{ instruction.discriminator }};
{% if instruction.accounts %}
pub const {{ instruction_upper }}_IX_ACCOUNTS_LEN: usize = {{ instruction.accounts | length }};
{% endif %}

{% if instruction.docs %}
{{ instruction.docs | multiline_docs }}
{% endif %}
#[derive(borsh::BorshDeserialize, borsh::BorshSerialize, Clone, Debug)]
{% if has_serde %}
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
{% endif %}
pub struct {{ instruction.name }}IxData {
    pub discriminator: [u8; 8],
    {% for field in instruction.fields %}
    {% if field.docs %}
    {{ field.docs | multiline_docs }}
    {% endif %}
    {% if has_serde %}
    {% if field.rust_type == "solana_pubkey::Pubkey" %}
    #[cfg_attr(feature = "serde", serde(with = "serde_with::As::<serde_with::DisplayFromStr>"))]
    {% elif field.is_big_array %}
    #[cfg_attr(feature = "serde", serde(with = "serde_big_array::BigArray"))]
    {% endif %}
    {% endif %}
    pub {{ field.name | rust_field }}: {{ field.rust_type | type_path }},
    {% endfor %}
}

impl Default for {{ instruction.name }}IxData {
    fn default() -> Self {
        Self {
            discriminator: {{ instruction_upper }}_IX_DISCM,
            {% for field in instruction.fields %}
            {{ field.name | rust_field }}: Default::default(),
            {% endfor %}
        }
    }
}

impl {{ instruction.name }}IxData {
    pub fn new(
        {% for field in instruction.fields %}
        {{ field.name | rust_field }}: {{ field.rust_type | type_path }},
        {% endfor %}
    ) -> Self {
        Self {
            discriminator: Self::discriminator(),
            {% for field in instruction.fields %}
            {{ field.name | rust_field }},
            {% endfor %}
        }
    }
    
    pub fn from_bytes(buf: &[u8]) -> std::io::Result<Self> {
        borsh::BorshDeserialize::deserialize(&mut &buf[..])
    }
    
    pub fn discriminator() -> [u8; 8] {
        {{ instruction_upper }}_IX_DISCM
    }
    
    pub fn try_to_vec(&self) -> std::io::Result<std::vec::Vec<u8>> {
        borsh::to_vec(self)
    }
}

{% if instruction.accounts %}
#[derive(Copy, Clone, Debug, Default)]
{% if has_serde %}
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
{% endif %}
pub struct {{ instruction.name }}Keys {
    {% for account in instruction.accounts %}
    {% if account.docs %}
    {{ account.docs | multiline_docs }}
    {% endif %}
    {% if has_serde %}
    #[cfg_attr(feature = "serde", serde(with = "serde_with::As::<serde_with::DisplayFromStr>"))]
    {% endif %}
    pub {{ account.name }}: solana_pubkey::Pubkey,
    {% endfor %}
}

impl From<&[solana_pubkey::Pubkey]> for {{ instruction.name }}Keys {
    fn from(pubkeys: &[solana_pubkey::Pubkey]) -> Self {
        Self {
            {% for account in instruction.accounts %}
            {{ account.name }}: pubkeys[{{ loop.index0 }}],
            {% endfor %}
        }
    }
}

impl {{ instruction.name }}Keys {
    /// Convert Keys to Vec<Pubkey>
    pub fn to_vec(&self) -> std::vec::Vec<solana_pubkey::Pubkey> {
        std::vec![
            {% for account in instruction.accounts %}
            self.{{ account.name }},
            {% endfor %}
        ]
    }
}

impl From<{{ instruction.name }}Keys> for [solana_instruction::AccountMeta; {{ instruction_upper }}_IX_ACCOUNTS_LEN] {
    fn from(keys: {{ instruction.name }}Keys) -> Self {
        [
            {% for account in instruction.accounts %}
            {% if account.is_mut %}
            solana_instruction::AccountMeta::new(keys.{{ account.name }}, {{ account.is_signer }}),
            {% else %}
            solana_instruction::AccountMeta::new_readonly(keys.{{ account.name }}, {{ account.is_signer }}),
            {% endif %}
            {% endfor %}
        ]
    }
}

pub fn {{ instruction.name | snake_case }}_ix_with_program_id(
    program_id: solana_pubkey::Pubkey,
    keys: {{ instruction.name }}Keys,
    args: {{ instruction.name }}IxData,
) -> std::result::Result<solana_instruction::Instruction, std::io::Error> {
    let metas: [solana_instruction::AccountMeta; {{ instruction_upper }}_IX_ACCOUNTS_LEN] = keys.into();
    std::result::Result::Ok(solana_instruction::Instruction {
        program_id,
        accounts: std::vec::Vec::from(metas),
        data: args.try_to_vec()?,
    })
}

pub fn {{ instruction.name | snake_case }}_ix(
    keys: {{ instruction.name }}Keys,
    args: {{ instruction.name }}IxData,
) -> std::result::Result<solana_instruction::Instruction, std::io::Error> {
    {{ instruction.name | snake_case }}_ix_with_program_id(crate::ID, keys, args)
}
{% endif %}