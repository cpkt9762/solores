//! {{ account.name }} Account  
//! Single account structure for {{ crate_name }}

{% if account.docs %}
{{ account.docs | multiline_docs }}
{% endif %}
#[derive(borsh::BorshDeserialize, borsh::BorshSerialize, Clone, Debug, PartialEq)]
{% if has_serde %}
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
{% endif %}
pub struct {{ account.name }} {
    /// Account discriminator for Anchor program
    pub discriminator: [u8; 8],
{% for field in account.fields %}
    {% if field.docs %}
    {{ field.docs | multiline_docs }}
    {% endif %}
    {% if field.rust_type == "solana_pubkey::Pubkey" %}
    #[cfg_attr(feature = "serde", serde(with = "serde_with::As::<serde_with::DisplayFromStr>"))]
    {% elif field.is_big_array %}
    #[cfg_attr(feature = "serde", serde(with = "serde_big_array::BigArray"))]
    {% elif field.rust_type | starts_with("std::collections::HashMap") %}
    #[cfg_attr(feature = "serde", serde(with = "serde_with::As::<std::collections::HashMap<serde_with::DisplayFromStr, _>>"))]
    {% elif field.rust_type | starts_with("std::option::Option<solana_pubkey::Pubkey>") %}
    #[cfg_attr(feature = "serde", serde(with = "serde_with::As::<std::option::Option<serde_with::DisplayFromStr>>"))]
    {% elif field.rust_type | starts_with("std::vec::Vec<solana_pubkey::Pubkey>") %}
    #[cfg_attr(feature = "serde", serde(with = "serde_with::As::<std::vec::Vec<serde_with::DisplayFromStr>>"))]
    {% endif %}
    pub {{ field.name | rust_field }}: {{ field.rust_type | type_path }},
{% endfor %}
}

impl {{ account.name }} {
    /// Account discriminator for Anchor program
    pub const DISCRIMINATOR: [u8; 8] = {{ account.discriminator if account.discriminator else "[0, 0, 0, 0, 0, 0, 0, 0]" }};

    /// Deserialize from bytes
    pub fn from_bytes(data: &[u8]) -> std::result::Result<Self, std::io::Error> {
        if data.len() < 8 {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Insufficient data for discriminator"
            ));
        }
        let discriminator = &data[0..8];
        if discriminator != Self::DISCRIMINATOR {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Invalid discriminator"
            ));
        }
        let mut account: Self = borsh::BorshDeserialize::deserialize(&mut &data[8..])?;
        account.discriminator = Self::DISCRIMINATOR;
        std::result::Result::Ok(account)
    }

    /// Serialize to bytes
    pub fn try_to_vec(&self) -> std::result::Result<std::vec::Vec<u8>, std::io::Error> {
        let mut data = Self::DISCRIMINATOR.to_vec();
        data.extend_from_slice(&borsh::to_vec(self)?);
        std::result::Result::Ok(data)
    }
}