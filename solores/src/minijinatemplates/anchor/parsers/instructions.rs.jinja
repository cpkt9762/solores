//! {{ crate_name }} Instruction Parsers
//! Anchor-style instruction parsing with 8-byte discriminators

/// Program instruction types for Anchor contract
#[derive(Clone, Debug, PartialEq)]
pub enum {{ program_name }}Instruction {
    {% for instruction in instructions %}
    {% if instruction.docs %}
    {{ instruction.docs | multiline_docs }}
    {% endif %}
    {% if instruction.accounts %}
    {{ instruction.name }}({{ instruction.name }}Keys, {{ instruction.name }}IxData),
    {% else %}
    {{ instruction.name }}({{ instruction.name }}IxData),
    {% endif %}
    {% endfor %}
}

impl {{ program_name }}Instruction {
    /// Parse instruction from instruction data and accounts
    pub fn from_bytes(
        instruction_data: &[u8],
        accounts: &[solana_pubkey::Pubkey],
    ) -> std::result::Result<Self, std::boxed::Box<dyn std::error::Error>> {
        if instruction_data.len() < 8 {
            return Err("Insufficient instruction data".into());
        }
        let discriminator = &instruction_data[0..8];
        {% for instruction in instructions %}
        if discriminator == {{ instruction.name | upper }}_IX_DISCM {
            let ix_data = {{ instruction.name }}IxData::from_bytes(instruction_data)?;
            {% if instruction.accounts %}
            if accounts.len() < {{ instruction.accounts|length }} {
                return Err("Insufficient accounts for {{ instruction.name }}".into());
            }
            let keys = {{ instruction.name }}Keys::from(&accounts[..{{ instruction.accounts|length }}]);
            return std::result::Result::Ok(Self::{{ instruction.name }}(keys, ix_data));
            {% else %}
            return std::result::Result::Ok(Self::{{ instruction.name }}(ix_data));
            {% endif %}
        }
        {% endfor %}
        Err("Unknown instruction discriminator".into())
    }

}

/// Parse instruction from instruction data and accounts
pub fn parse_instruction(
    instruction_data: &[u8],
    accounts: &[solana_pubkey::Pubkey],
) -> std::result::Result<{{ program_name }}Instruction, std::boxed::Box<dyn std::error::Error>> {
    {{ program_name }}Instruction::from_bytes(instruction_data, accounts)
}