//! 非 Anchor Instructions Parser 测试模板
//!
//! 为非 Anchor 合约生成 Instructions Parser 测试代码

use proc_macro2::TokenStream;
use quote::quote;
use convert_case::{Case, Casing};
use heck::ToShoutySnakeCase;

use crate::idl_format::non_anchor_idl::NonAnchorInstruction;
use crate::templates::{NonAnchorInstructionsParserTestGenerator, TemplateGenerator};

/// 非 Anchor Instructions Parser 测试模板
pub struct NonAnchorInstructionsParserTestTemplate;

impl NonAnchorInstructionsParserTestTemplate {
    /// 创建新的非 Anchor Instructions Parser 测试模板
    pub fn new() -> Self {
        Self
    }
}

impl NonAnchorInstructionsParserTestGenerator for NonAnchorInstructionsParserTestTemplate {
    fn generate_instructions_consistency_tests(&self, instructions: &[NonAnchorInstruction], program_name: &str) -> TokenStream {
        if instructions.is_empty() {
            return quote! {};
        }

        // Use the correct enum name for generated parsers
        let program_enum_name = syn::Ident::new(
            "ProgramInstruction", // This matches what's generated in parsers_template.rs
            proc_macro2::Span::call_site(),
        );

        // Generate consistency tests for each instruction
        let consistency_tests = instructions.iter().map(|ix| {
            let test_name = syn::Ident::new(
                &format!("test_{}_consistency", ix.name.to_case(Case::Snake)),
                proc_macro2::Span::call_site(),
            );
            let variant_name = syn::Ident::new(&ix.name.to_case(Case::Pascal), proc_macro2::Span::call_site());
            let keys_struct_name = syn::Ident::new(
                &format!("{}Keys", ix.name.to_case(Case::Pascal)), 
                proc_macro2::Span::call_site(),
            );
            let accounts_len_const = syn::Ident::new(
                &format!("{}_IX_ACCOUNTS_LEN", ix.name.to_shouty_snake_case()),
                proc_macro2::Span::call_site(),
            );

            // Every instruction now has Args struct (even if only contains discriminator)
            let args_struct_name = syn::Ident::new(
                &format!("{}IxData", ix.name.to_case(Case::Pascal)),
                proc_macro2::Span::call_site(),
            );

            // All non-Anchor instructions now have consistent (Keys, IxData) pattern matching
            // This matches the unified enum structure generated by NonAnchorParsersTemplate
            quote! {
                #[test]
                fn #test_name() {
                    let mock_accounts = vec![Pubkey::default(); #accounts_len_const];
                    let test_keys = #keys_struct_name::from(&mock_accounts[..#accounts_len_const]);
                    let test_args = #args_struct_name::default();
                    
                    // Use direct Args serialization (discriminator included in Default impl)
                    let test_data = test_args.try_to_vec().unwrap();
                    
                    match parse_instruction(&test_data, &mock_accounts) {
                        Ok(#program_enum_name::#variant_name(keys, args)) => {
                            // Verify key consistency
                            assert_eq!(keys, test_keys);
                            // Verify args consistency
                            assert_eq!(args, test_args);
                        }
                        Ok(_) => panic!("1-byte discriminator matched wrong instruction type"),
                        Err(e) => {
                            let error_msg = e.to_string();
                            assert!(
                                !error_msg.contains("Unknown instruction discriminator"),
                                "Should recognize 1-byte discriminator for {}",
                                stringify!(#variant_name)
                            );
                        }
                    }
                }
            }
        });

        // Generate discriminator recognition test for 1-byte discriminators
        let discriminator_test = {
            let instruction_tests = instructions.iter().map(|ix| {
                let variant_name = syn::Ident::new(&ix.name.to_case(Case::Pascal), proc_macro2::Span::call_site());
                let keys_struct_name = syn::Ident::new(
                    &format!("{}Keys", ix.name.to_case(Case::Pascal)), 
                    proc_macro2::Span::call_site(),
                );
                let accounts_len_const = syn::Ident::new(
                    &format!("{}_IX_ACCOUNTS_LEN", ix.name.to_shouty_snake_case()),
                    proc_macro2::Span::call_site(),
                );

                let args_struct_name = syn::Ident::new(
                    &format!("{}IxData", ix.name.to_case(Case::Pascal)),
                    proc_macro2::Span::call_site(),
                );
                
                quote! {
                    let mock_accounts = vec![Pubkey::default(); #accounts_len_const];
                    let test_keys = #keys_struct_name::from(&mock_accounts[..#accounts_len_const]);
                    let test_args = #args_struct_name::default();
                    let test_data = test_args.try_to_vec().unwrap();
                    assert!(
                        test_data.len() >= 1,
                        "Test data should have at least 1 byte for non-Anchor discriminator"
                    );
                    let result = parse_instruction(&test_data, &mock_accounts);
                    match result {
                        Ok(_) => {},
                        Err(e) => {
                            let error_msg = e.to_string();
                            assert!(
                                !error_msg.contains("Unknown instruction discriminator"),
                                "Should recognize 1-byte discriminator for instruction {}",
                                stringify!(#variant_name)
                            );
                        }
                    }
                }
            });
            
            quote! {
                #[test]
                fn test_non_anchor_discriminator_recognition() {
                    // Test 1-byte discriminator recognition for non-Anchor contracts
                    #(#instruction_tests)*
                }
            }
        };

        quote! {
            use solana_pubkey::Pubkey;
            
            #(#consistency_tests)*
            
            #discriminator_test
        }
    }
}

impl TemplateGenerator for NonAnchorInstructionsParserTestTemplate {
    fn get_standard_module_name(&self) -> &'static str {
        "tests"
    }

    fn gen_files(&self) -> Vec<(String, TokenStream)> {
        // This template is used as a component, not standalone
        vec![]
    }
    
    fn gen_mod_file(&self) -> TokenStream {
        quote! {}
    }
}